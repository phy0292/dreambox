diff -Naur ppp-2.4.4.0/pppd/chap-new.c ppp-2.4.4/pppd/chap-new.c
--- ppp-2.4.4.0/pppd/chap-new.c	2012-02-11 14:06:06.000000000 +0800
+++ ppp-2.4.4/pppd/chap-new.c	2012-02-11 14:03:10.000000000 +0800
@@ -36,6 +36,8 @@
 #include "chap-new.h"
 #include "chap-md5.h"
 
+#include "syncppp.h"
+
 #ifdef CHAPMS
 #include "chap_ms.h"
 #define MDTYPE_ALL (MDTYPE_MICROSOFT_V2 | MDTYPE_MICROSOFT | MDTYPE_MD5)
@@ -58,6 +60,7 @@
 int chap_max_transmits = 10;
 int chap_rechallenge_time = 0;
 int chapms_strip_domain = 0;
+bool syncpppd = 0;
 
 /*
  * Command-line options.
@@ -71,6 +74,8 @@
 	  "Set interval for rechallenge", OPT_PRIO },
 	{ "chapms-strip-domain", o_bool, &chapms_strip_domain,
 	  "Strip the domain prefix before the Username", 1 },
+    { "syncppp", o_bool, &syncpppd,
+      "sync among multiple pppd when sending chap respond", 1 },
 	{ NULL }
 };
 
@@ -475,6 +480,14 @@
 	p[2] = len >> 8;
 	p[3] = len;
 
+    if (syncpppd) {
+        if (syncppp() < 0) {
+            error("syncppp sync fail");
+        } else {
+            info("syncppp sync succeeded");
+        }   
+    }
+
 	output(0, response, PPP_HDRLEN + len);
 }
 
diff -Naur ppp-2.4.4.0/pppd/Makefile.linux ppp-2.4.4/pppd/Makefile.linux
--- ppp-2.4.4.0/pppd/Makefile.linux	2012-02-11 14:06:06.000000000 +0800
+++ ppp-2.4.4/pppd/Makefile.linux	2012-02-11 14:58:01.000000000 +0800
@@ -13,16 +13,16 @@
 
 PPPDSRCS = main.c magic.c fsm.c lcp.c ipcp.c upap.c chap-new.c md5.c ccp.c \
 	   ecp.c ipxcp.c auth.c options.c sys-linux.c md4.c chap_ms.c \
-	   demand.c utils.c tty.c eap.c chap-md5.c
+	   demand.c utils.c tty.c eap.c chap-md5.c syncppp.c
 
 HEADERS = ccp.h chap-new.h ecp.h fsm.h ipcp.h \
 	ipxcp.h lcp.h magic.h md5.h patchlevel.h pathnames.h pppd.h \
-	upap.h eap.h
+	upap.h eap.h syncppp.h
 
 MANPAGES = pppd.8
 PPPDOBJS = main.o magic.o fsm.o lcp.o ipcp.o upap.o chap-new.o md5.o ccp.o \
 	   ecp.o auth.o options.o demand.o utils.o sys-linux.o ipxcp.o tty.o \
-	   eap.o chap-md5.o
+	   eap.o chap-md5.o syncppp.o
 
 #
 # include dependencies if present
@@ -70,6 +70,9 @@
 # Enable plugins
 PLUGIN=y
 
+# Enable SYNC_PPP plugins
+SYNC_PPP=y
+
 # Enable Microsoft proprietary Callback Control Protocol
 #CBCP=y
 
@@ -97,6 +100,13 @@
 endif
 endif
 
+# syncppp 
+ifdef SYNC_PPP
+TARGETS	+= syncpppinit
+EXTRAINSTALL = $(INSTALL) -c -m 555 syncpppinit $(BINDIR)/syncpppinit
+EXTRACLEAN += syncpppinit.o
+endif
+
 # EAP SRP-SHA1
 ifdef USE_SRP
 CFLAGS	+= -DUSE_SRP -DOPENSSL -I/usr/local/ssl/include
@@ -219,6 +229,9 @@
 pppd: $(PPPDOBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o pppd $(PPPDOBJS) $(LIBS)
 
+syncpppinit:	syncpppinit.c
+	${CC} $(CFLAGS) $(LDFLAGS) -o syncpppinit syncpppinit.c $(LIBS)
+
 srp-entry:	srp-entry.c
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ srp-entry.c $(LIBS)
 
diff -Naur ppp-2.4.4.0/pppd/syncppp.c ppp-2.4.4/pppd/syncppp.c
--- ppp-2.4.4.0/pppd/syncppp.c	1970-01-01 08:00:00.000000000 +0800
+++ ppp-2.4.4/pppd/syncppp.c	2012-02-11 14:12:04.000000000 +0800
@@ -0,0 +1,56 @@
+#include <stdio.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "pppd.h"
+#include "syncppp.h"
+
+int syncppp(void)
+{
+    int fd; 
+    int fdlock;
+    npppvaltype buf;
+
+    /* open the npppfile, lock the file, read, increment, and write */
+    if ((fd = open(npppfilename,O_RDWR)) < 0) {
+        error("npppfile open error");
+        return -1;
+    }   
+
+    if (flock(fd, LOCK_EX) < 0) {
+        error("lock npppfile error");
+        return -1;
+    }
+    if (read(fd, &buf, sizeof(buf)) < 0) {
+        error("npppfile read error");
+        return -1;
+    }
+    buf++;
+    lseek(fd, 0, SEEK_SET);
+    if (write(fd, &buf, sizeof(buf)) != 1) {
+        error("npppfile write error");
+        return -1;
+    }
+
+    if (flock(fd, LOCK_UN) < 0) {
+        error("npppfile unlock error");
+        return -1;
+    }
+
+    /* try to lock the lockfile */
+    if ((fdlock = open(lockfilename, O_RDWR)) < 0) {
+        error("lockfile open error");
+        return -1;
+    }
+    flock(fdlock, LOCK_SH);
+
+    close(fd);
+    close(fdlock);
+
+    return 0;
+}
+
diff -Naur ppp-2.4.4.0/pppd/syncppp.h ppp-2.4.4/pppd/syncppp.h
--- ppp-2.4.4.0/pppd/syncppp.h	1970-01-01 08:00:00.000000000 +0800
+++ ppp-2.4.4/pppd/syncppp.h	2012-02-11 14:12:09.000000000 +0800
@@ -0,0 +1,7 @@
+#define MAX_PPP_NUM 30
+#define npppfilename "/tmp/nppp"
+#define lockfilename "/tmp/ppplockfile"
+#define npppvaltype char
+
+int syncppp(void);
+
diff -Naur ppp-2.4.4.0/pppd/syncpppinit.c ppp-2.4.4/pppd/syncpppinit.c
--- ppp-2.4.4.0/pppd/syncpppinit.c	1970-01-01 08:00:00.000000000 +0800
+++ ppp-2.4.4/pppd/syncpppinit.c	2012-02-11 14:11:59.000000000 +0800
@@ -0,0 +1,88 @@
+#include <stdio.h>
+#include <sys/file.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "syncppp.h"
+
+int main(int argc, char *argv[])
+{
+    int fd;
+    int fdlock;
+    int nppp = 0;
+    int oldnppp = 0;
+    npppvaltype buf;
+
+    if (argc != 2) {
+        fprintf(stderr, "Usage: %s <number of pppd>\n", argv[0]);
+        exit(1);
+    }
+
+    /* read number of pppd from cmdline, check the range */
+    nppp = atoi(argv[1]);
+    if (nppp <=0 || nppp > MAX_PPP_NUM) {
+        fprintf(stderr, "number of pppd should be >= 0 and <= %d\n", MAX_PPP_NUM);
+        exit(1);
+    }
+
+    /* lockfile: create, lock */
+    if ((fdlock = creat(lockfilename, 0644)) < 0) {
+        perror("lockfile creat error");
+        exit(1);
+    }
+    if (flock(fdlock, LOCK_EX) < 0) {
+        fprintf(stderr, "lock error\n");
+        exit(1);
+    } else {
+        fprintf(stderr, "lock success\n");
+    }
+
+    /* npppfile: create, write a 0 */
+    if ((fd = creat(npppfilename, 0644)) < 0) {
+        perror("npppfile creat error");
+        exit(1);
+    }
+    buf = 0;
+    if (write(fd, &buf, sizeof(buf)) != 1) {
+        perror("npppfile write error");
+        exit(1);
+    }
+    close(fd);
+    if ((fd = open(npppfilename,O_RDONLY)) < 0) {
+        perror("npppfile open error");
+        exit(1);
+    }   
+
+
+    /* spin lock: check npppfile */
+    while (1) {
+        if (lseek(fd, 0, SEEK_SET) < 0) {
+            perror("lseek");
+            exit(1);
+        }
+        if (read(fd, &buf, sizeof(buf)) < 0) {
+            fprintf(stderr, "read error\n");
+            exit(1);
+        }
+        if ((int)buf >= nppp) {
+            fprintf(stderr, "%d Challenges recieved, unlock the lockfile\n", nppp);
+            break;
+        } 
+        if (oldnppp != (int)buf) {
+            oldnppp = (int)buf;
+            fprintf(stderr, "%d Challenges recieved, waiting for the left %d\n", oldnppp, nppp-oldnppp);
+        }
+    }
+
+    /* unlock the lockfile */
+    if (flock(fdlock, LOCK_UN) < 0) {
+        fprintf(stderr, "unlock error\n");
+    } else {
+        fprintf(stderr, "unlock success\n");
+    }
+
+    return 0;
+}
diff -Naur ppp-2.4.4.0/pppd/upap.c ppp-2.4.4/pppd/upap.c
--- ppp-2.4.4.0/pppd/upap.c	2012-02-11 14:04:49.000000000 +0800
+++ ppp-2.4.4/pppd/upap.c	2012-02-22 21:46:27.000000000 +0800
@@ -52,9 +52,12 @@
 #include "pppd.h"
 #include "upap.h"
 
+#include "syncppp.h"
+
 static const char rcsid[] = RCSID;
 
 static bool hide_password = 1;
+static bool syncpppd = 0;
 
 /*
  * Command-line options.
@@ -72,6 +75,9 @@
     { "pap-timeout", o_int, &upap[0].us_reqtimeout,
       "Set time limit for peer PAP authentication", OPT_PRIO },
 
+    { "syncppp", o_bool, &syncpppd,
+      "sync among multiple pppd when sending chap respond", 1 },
+
     { NULL }
 };
 
@@ -568,6 +574,14 @@
     PUTCHAR(u->us_passwdlen, outp);
     BCOPY(u->us_passwd, outp, u->us_passwdlen);
 
+    if (syncpppd) {
+        if (syncppp() < 0) {
+            error("syncppp sync fail");
+        } else {
+            info("syncppp sync succeeded");
+        }   
+    }
+
     output(u->us_unit, outpacket_buf, outlen + PPP_HDRLEN);
 
     TIMEOUT(upap_timeout, u, u->us_timeouttime);
@@ -598,6 +612,7 @@
     PUTSHORT(outlen, outp);
     PUTCHAR(msglen, outp);
     BCOPY(msg, outp, msglen);
+
     output(u->us_unit, outpacket_buf, outlen + PPP_HDRLEN);
 }
 
