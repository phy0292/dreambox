diff -Nur linux-2.6.35.7/drivers/input/evdev.c tiny210/drivers/input/evdev.c
--- linux-2.6.35.7/drivers/input/evdev.c	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/evdev.c	2011-08-08 12:52:34.000000000 +0800
@@ -20,6 +20,7 @@
 #include <linux/input.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -43,6 +44,8 @@
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
+	struct wake_lock wake_lock;
+	char name[28];
 };
 
 static struct evdev *evdev_table[EVDEV_MINORS];
@@ -55,6 +58,7 @@
 	 * Interrupts are disabled, just acquire the lock
 	 */
 	spin_lock(&client->buffer_lock);
+	wake_lock_timeout(&client->wake_lock, 5 * HZ);
 	client->buffer[client->head++] = *event;
 	client->head &= EVDEV_BUFFER_SIZE - 1;
 	spin_unlock(&client->buffer_lock);
@@ -72,8 +76,11 @@
 	struct evdev *evdev = handle->private;
 	struct evdev_client *client;
 	struct input_event event;
+	struct timespec ts;
 
-	do_gettimeofday(&event.time);
+	ktime_get_ts(&ts);
+	event.time.tv_sec = ts.tv_sec;
+	event.time.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
 	event.type = type;
 	event.code = code;
 	event.value = value;
@@ -234,6 +241,7 @@
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -270,6 +278,9 @@
 	}
 
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d",
+			dev_name(&evdev->dev), task_tgid_vnr(current));
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -335,6 +346,8 @@
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= EVDEV_BUFFER_SIZE - 1;
+		if (client->head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
diff -Nur linux-2.6.35.7/drivers/input/Kconfig tiny210/drivers/input/Kconfig
--- linux-2.6.35.7/drivers/input/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/Kconfig	2011-08-08 12:52:34.000000000 +0800
@@ -161,6 +161,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 config XEN_KBDDEV_FRONTEND
 	tristate "Xen virtual keyboard and mouse support"
 	depends on XEN_FBDEV_FRONTEND
diff -Nur linux-2.6.35.7/drivers/input/keyboard/cypress-touchkey.c tiny210/drivers/input/keyboard/cypress-touchkey.c
--- linux-2.6.35.7/drivers/input/keyboard/cypress-touchkey.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/keyboard/cypress-touchkey.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,403 @@
+/*
+ * Copyright 2006-2010, Cypress Semiconductor Corporation.
+ * Copyright (C) 2010, Samsung Electronics Co. Ltd. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/earlysuspend.h>
+#include <linux/input/cypress-touchkey.h>
+
+#define SCANCODE_MASK		0x07
+#define UPDOWN_EVENT_MASK	0x08
+#define ESD_STATE_MASK		0x10
+
+#define BACKLIGHT_ON		0x10
+#define BACKLIGHT_OFF		0x20
+
+#define OLD_BACKLIGHT_ON	0x1
+#define OLD_BACKLIGHT_OFF	0x2
+
+#define DEVICE_NAME "cypress-touchkey"
+
+struct cypress_touchkey_devdata {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct touchkey_platform_data *pdata;
+	struct early_suspend early_suspend;
+	u8 backlight_on;
+	u8 backlight_off;
+	bool is_dead;
+	bool is_powering_on;
+	bool has_legacy_keycode;
+};
+
+static int i2c_touchkey_read_byte(struct cypress_touchkey_devdata *devdata,
+					u8 *val)
+{
+	int ret;
+	int retry = 2;
+
+	while (true) {
+		ret = i2c_smbus_read_byte(devdata->client);
+		if (ret >= 0) {
+			*val = ret;
+			return 0;
+		}
+
+		dev_err(&devdata->client->dev, "i2c read error\n");
+		if (!retry--)
+			break;
+		msleep(10);
+	}
+
+	return ret;
+}
+
+static int i2c_touchkey_write_byte(struct cypress_touchkey_devdata *devdata,
+					u8 val)
+{
+	int ret;
+	int retry = 2;
+
+	while (true) {
+		ret = i2c_smbus_write_byte(devdata->client, val);
+		if (!ret)
+			return 0;
+
+		dev_err(&devdata->client->dev, "i2c write error\n");
+		if (!retry--)
+			break;
+		msleep(10);
+	}
+
+	return ret;
+}
+
+static void all_keys_up(struct cypress_touchkey_devdata *devdata)
+{
+	int i;
+
+	for (i = 0; i < devdata->pdata->keycode_cnt; i++)
+		input_report_key(devdata->input_dev,
+						devdata->pdata->keycode[i], 0);
+
+	input_sync(devdata->input_dev);
+}
+
+static int recovery_routine(struct cypress_touchkey_devdata *devdata)
+{
+	int ret = -1;
+	int retry = 10;
+	u8 data;
+	int irq_eint;
+
+	if (unlikely(devdata->is_dead)) {
+		dev_err(&devdata->client->dev, "%s: Device is already dead, "
+				"skipping recovery\n", __func__);
+		return -ENODEV;
+	}
+
+	irq_eint = devdata->client->irq;
+
+	all_keys_up(devdata);
+
+	disable_irq_nosync(irq_eint);
+	while (retry--) {
+		devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+		devdata->pdata->touchkey_onoff(TOUCHKEY_ON);
+		ret = i2c_touchkey_read_byte(devdata, &data);
+		if (!ret) {
+			enable_irq(irq_eint);
+			goto out;
+		}
+		dev_err(&devdata->client->dev, "%s: i2c transfer error retry = "
+				"%d\n", __func__, retry);
+	}
+	devdata->is_dead = true;
+	devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+	dev_err(&devdata->client->dev, "%s: touchkey died\n", __func__);
+out:
+	return ret;
+}
+
+static irqreturn_t touchkey_interrupt_thread(int irq, void *touchkey_devdata)
+{
+	u8 data;
+	int i;
+	int ret;
+	int scancode;
+	struct cypress_touchkey_devdata *devdata = touchkey_devdata;
+
+	ret = i2c_touchkey_read_byte(devdata, &data);
+	if (ret || (data & ESD_STATE_MASK)) {
+		ret = recovery_routine(devdata);
+		if (ret) {
+			dev_err(&devdata->client->dev, "%s: touchkey recovery "
+					"failed!\n", __func__);
+			goto err;
+		}
+	}
+
+	if (devdata->has_legacy_keycode) {
+		scancode = (data & SCANCODE_MASK) - 1;
+		if (scancode < 0 || scancode >= devdata->pdata->keycode_cnt) {
+			dev_err(&devdata->client->dev, "%s: scancode is out of "
+				"range\n", __func__);
+			goto err;
+		}
+		input_report_key(devdata->input_dev,
+			devdata->pdata->keycode[scancode],
+			!(data & UPDOWN_EVENT_MASK));
+	} else {
+		for (i = 0; i < devdata->pdata->keycode_cnt; i++)
+			input_report_key(devdata->input_dev,
+				devdata->pdata->keycode[i],
+				!!(data & (1U << i)));
+	}
+
+	input_sync(devdata->input_dev);
+err:
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t touchkey_interrupt_handler(int irq, void *touchkey_devdata)
+{
+	struct cypress_touchkey_devdata *devdata = touchkey_devdata;
+
+	if (devdata->is_powering_on) {
+		dev_dbg(&devdata->client->dev, "%s: ignoring spurious boot "
+					"interrupt\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cypress_touchkey_early_suspend(struct early_suspend *h)
+{
+	struct cypress_touchkey_devdata *devdata =
+		container_of(h, struct cypress_touchkey_devdata, early_suspend);
+
+	devdata->is_powering_on = true;
+
+	if (unlikely(devdata->is_dead))
+		return;
+
+	disable_irq(devdata->client->irq);
+	devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+
+	all_keys_up(devdata);
+}
+
+static void cypress_touchkey_early_resume(struct early_suspend *h)
+{
+	struct cypress_touchkey_devdata *devdata =
+		container_of(h, struct cypress_touchkey_devdata, early_suspend);
+
+	devdata->pdata->touchkey_onoff(TOUCHKEY_ON);
+	if (i2c_touchkey_write_byte(devdata, devdata->backlight_on)) {
+		devdata->is_dead = true;
+		devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+		dev_err(&devdata->client->dev, "%s: touch keypad not responding"
+				" to commands, disabling\n", __func__);
+		return;
+	}
+	devdata->is_dead = false;
+	enable_irq(devdata->client->irq);
+	devdata->is_powering_on = false;
+}
+#endif
+
+static int cypress_touchkey_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct input_dev *input_dev;
+	struct cypress_touchkey_devdata *devdata;
+	u8 data[3];
+	int err;
+	int cnt;
+
+	if (!dev->platform_data) {
+		dev_err(dev, "%s: Platform data is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	devdata = kzalloc(sizeof(*devdata), GFP_KERNEL);
+	if (devdata == NULL) {
+		dev_err(dev, "%s: failed to create our state\n", __func__);
+		return -ENODEV;
+	}
+
+	devdata->client = client;
+	i2c_set_clientdata(client, devdata);
+
+	devdata->pdata = client->dev.platform_data;
+	if (!devdata->pdata->keycode) {
+		dev_err(dev, "%s: Invalid platform data\n", __func__);
+		err = -EINVAL;
+		goto err_null_keycodes;
+	}
+
+	strlcpy(devdata->client->name, DEVICE_NAME, I2C_NAME_SIZE);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		goto err_input_alloc_dev;
+	}
+
+	devdata->input_dev = input_dev;
+	dev_set_drvdata(&input_dev->dev, devdata);
+	input_dev->name = DEVICE_NAME;
+	input_dev->id.bustype = BUS_HOST;
+
+	for (cnt = 0; cnt < devdata->pdata->keycode_cnt; cnt++)
+		input_set_capability(input_dev, EV_KEY,
+					devdata->pdata->keycode[cnt]);
+
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_input_reg_dev;
+
+	devdata->is_powering_on = true;
+
+	devdata->pdata->touchkey_onoff(TOUCHKEY_ON);
+
+	err = i2c_master_recv(client, data, sizeof(data));
+	if (err < sizeof(data)) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(dev, "%s: error reading hardware version\n", __func__);
+		goto err_read;
+	}
+
+	dev_info(dev, "%s: hardware rev1 = %#02x, rev2 = %#02x\n", __func__,
+				data[1], data[2]);
+	if (data[1] < 0xc4 && (data[1] >= 0x8 ||
+				(data[1] == 0x8 && data[2] >= 0x9))) {
+		devdata->backlight_on = BACKLIGHT_ON;
+		devdata->backlight_off = BACKLIGHT_OFF;
+	} else {
+		devdata->backlight_on = OLD_BACKLIGHT_ON;
+		devdata->backlight_off = OLD_BACKLIGHT_OFF;
+	}
+
+	devdata->has_legacy_keycode = data[1] >= 0xc4 || data[1] < 0x9 ||
+					(data[1] == 0x9 && data[2] < 0x9);
+
+	err = i2c_touchkey_write_byte(devdata, devdata->backlight_on);
+	if (err) {
+		dev_err(dev, "%s: touch keypad backlight on failed\n",
+				__func__);
+		goto err_backlight_on;
+	}
+
+	if (request_threaded_irq(client->irq, touchkey_interrupt_handler,
+				touchkey_interrupt_thread, IRQF_TRIGGER_FALLING,
+				DEVICE_NAME, devdata)) {
+		dev_err(dev, "%s: Can't allocate irq.\n", __func__);
+		goto err_req_irq;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	devdata->early_suspend.suspend = cypress_touchkey_early_suspend;
+	devdata->early_suspend.resume = cypress_touchkey_early_resume;
+#endif
+	register_early_suspend(&devdata->early_suspend);
+
+	devdata->is_powering_on = false;
+
+	return 0;
+
+err_req_irq:
+err_backlight_on:
+err_read:
+	devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+	input_unregister_device(input_dev);
+	goto err_input_alloc_dev;
+err_input_reg_dev:
+	input_free_device(input_dev);
+err_input_alloc_dev:
+err_null_keycodes:
+	kfree(devdata);
+	return err;
+}
+
+static int __devexit i2c_touchkey_remove(struct i2c_client *client)
+{
+	struct cypress_touchkey_devdata *devdata = i2c_get_clientdata(client);
+
+	unregister_early_suspend(&devdata->early_suspend);
+	/* If the device is dead IRQs are disabled, we need to rebalance them */
+	if (unlikely(devdata->is_dead))
+		enable_irq(client->irq);
+	else
+		devdata->pdata->touchkey_onoff(TOUCHKEY_OFF);
+	free_irq(client->irq, devdata);
+	all_keys_up(devdata);
+	input_unregister_device(devdata->input_dev);
+	kfree(devdata);
+	return 0;
+}
+
+static const struct i2c_device_id cypress_touchkey_id[] = {
+	{ CYPRESS_TOUCHKEY_DEV_NAME, 0 },
+};
+
+MODULE_DEVICE_TABLE(i2c, cypress_touchkey_id);
+
+struct i2c_driver touchkey_i2c_driver = {
+	.driver = {
+		.name = "cypress_touchkey_driver",
+	},
+	.id_table = cypress_touchkey_id,
+	.probe = cypress_touchkey_probe,
+	.remove = __devexit_p(i2c_touchkey_remove),
+};
+
+static int __init touchkey_init(void)
+{
+	int ret = 0;
+
+	ret = i2c_add_driver(&touchkey_i2c_driver);
+	if (ret)
+		pr_err("%s: cypress touch keypad registration failed. (%d)\n",
+				__func__, ret);
+
+	return ret;
+}
+
+static void __exit touchkey_exit(void)
+{
+	i2c_del_driver(&touchkey_i2c_driver);
+}
+
+late_initcall(touchkey_init);
+module_exit(touchkey_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("@@@");
+MODULE_DESCRIPTION("cypress touch keypad");
diff -Nur linux-2.6.35.7/drivers/input/keyboard/Kconfig tiny210/drivers/input/keyboard/Kconfig
--- linux-2.6.35.7/drivers/input/keyboard/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/keyboard/Kconfig	2011-08-08 12:52:34.000000000 +0800
@@ -204,6 +204,49 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called matrix_keypad.
 
+config KEYPAD_S3C
+	tristate "S3C keypad support"
+	depends on CPU_S5PC100 || CPU_S5PC110 || CPU_S5P6442 || CPU_S5PV210
+	default n
+	help
+	  Say Y here if you want to use the S3C SMDK keypad.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c-keypad.
+
+config S3C_KEYPAD_DEBUG
+	bool "Print debug messages for S3C keypad"
+	depends on KEYPAD_S3C
+	default n
+	help
+	  Say Y here if you want to print debug messages for S3C keypad.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c-keypad.
+
+choice
+	prompt "Select keypad interface type"
+	depends on KEYPAD_S3C
+	default KEYPAD_S3C_INT
+
+config KEYPAD_S3C_INT
+	bool "Port0 : [KEYPAD : INT(8x8)]"
+	depends on KEYPAD_S3C
+	help
+	  Say Y here if you want to use the S3C SMDK keypad.(8x8)
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c-keypad.
+
+config KEYPAD_S3C_MSM
+	bool "Port1 : [KEYPAD : MSM(8x16)]"
+	depends on KEYPAD_S3C && CPU_S5PV210
+	help
+	  Say Y here if you want to use the S3C SMDK keypad.(8x16)
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c-keypad.
+endchoice
+
 config KEYBOARD_HIL_OLD
 	tristate "HP HIL keyboard support (simple driver)"
 	depends on GSC || HP300
@@ -426,4 +469,13 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called w90p910_keypad.
 
+config KEYPAD_CYPRESS_TOUCH
+	tristate "Cypress touch keypad support"
+	default n
+	help
+	  Say Y here if you want to use the Cypress touch keypad.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cypress-touchkey.
+
 endif
diff -Nur linux-2.6.35.7/drivers/input/keyboard/Makefile tiny210/drivers/input/keyboard/Makefile
--- linux-2.6.35.7/drivers/input/keyboard/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/keyboard/Makefile	2011-08-08 12:52:34.000000000 +0800
@@ -38,3 +38,7 @@
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYPAD_CYPRESS_TOUCH)      += cypress-touchkey.o
+obj-$(CONFIG_KEYPAD_MELFAS_TOUCH)                += melfas-touchkey.o
+obj-$(CONFIG_KEYPAD_MELFAS_TOUCH)                += melfas_download.o
+obj-$(CONFIG_KEYPAD_S3C)		+= s3c-keypad.o
diff -Nur linux-2.6.35.7/drivers/input/keyboard/s3c-keypad.c tiny210/drivers/input/keyboard/s3c-keypad.c
--- linux-2.6.35.7/drivers/input/keyboard/s3c-keypad.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/keyboard/s3c-keypad.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,394 @@
+/* drivers/input/keyboard/s3c-keypad.c
+ *
+ * Driver core for Samsung SoC onboard UARTs.
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#include <plat/regs-keypad.h>
+
+#include "s3c-keypad.h"
+
+#define DEVICE_NAME "s3c-keypad"
+
+#define TRUE 1
+#define FALSE 0
+
+static struct timer_list keypad_timer;
+static bool is_timer_on;
+static struct clk *keypad_clock;
+
+static u32 keymask[KEYPAD_COLUMNS];
+static u32 prevmask[KEYPAD_COLUMNS];
+
+static int keypad_scan(void)
+{
+	u32 col, cval, rval;
+
+	pr_debug("keypad_scan() is called\n");
+
+	pr_debug("row val = %x", readl(key_base + S3C_KEYIFROW));
+
+	for (col = 0; col < KEYPAD_COLUMNS; col++) {
+		/* clear that column number and make that normal output */
+		cval = KEYCOL_DMASK & ~((1 << col) | (1 << (col + 8)));
+		writel(cval, key_base + S3C_KEYIFCOL);
+
+		udelay(KEYPAD_DELAY);
+
+		rval = ~(readl(key_base + S3C_KEYIFROW)) &
+			((1<<KEYPAD_ROWS) - 1);
+		keymask[col] = rval;
+	}
+
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	return 0;
+}
+
+static void keypad_timer_handler(unsigned long data)
+{
+	u32 press_mask;
+	u32 release_mask;
+	u32 restart_timer = 0;
+	int i, col;
+	struct s3c_keypad *pdata = (struct s3c_keypad *)data;
+	struct input_dev *dev = pdata->dev;
+
+	keypad_scan();
+
+	for (col = 0; col < KEYPAD_COLUMNS; col++) {
+		press_mask = ((keymask[col] ^ prevmask[col]) & keymask[col]);
+		release_mask = ((keymask[col] ^ prevmask[col]) & prevmask[col]);
+		i = col * KEYPAD_ROWS;
+
+		while (press_mask) {
+			if (press_mask & 1) {
+				input_report_key(dev, pdata->keycodes[i], 1);
+				pr_debug("key Pressed : key %d map %d\n",
+						i, pdata->keycodes[i]);
+			}
+			press_mask >>= 1;
+			i++;
+		}
+
+		i = col * KEYPAD_ROWS;
+
+		while (release_mask) {
+			if (release_mask & 1) {
+				input_report_key(dev, pdata->keycodes[i], 0);
+				pr_debug("key Released : %d map %d\n",
+						i, pdata->keycodes[i]);
+			}
+			release_mask >>= 1;
+			i++;
+		}
+		prevmask[col] = keymask[col];
+
+		restart_timer |= keymask[col];
+	}
+
+	if (restart_timer) {
+		mod_timer(&keypad_timer, jiffies + HZ/10);
+	} else {
+		writel(KEYIFCON_INIT, key_base + S3C_KEYIFCON);
+		is_timer_on = false;
+	}
+}
+
+static irqreturn_t s3c_keypad_isr(int irq, void *dev_id)
+{
+	/* disable keypad interrupt and schedule for keypad timer handler */
+	writel(readl(key_base + S3C_KEYIFCON) & ~(INT_F_EN|INT_R_EN),
+			key_base + S3C_KEYIFCON);
+
+	keypad_timer.expires = jiffies + (HZ/100);
+	if (is_timer_on == false) {
+		add_timer(&keypad_timer);
+		is_timer_on = true;
+	} else {
+		mod_timer(&keypad_timer, keypad_timer.expires);
+	}
+	/*Clear the keypad interrupt status*/
+	writel(KEYIFSTSCLR_CLEAR, key_base + S3C_KEYIFSTSCLR);
+
+	return IRQ_HANDLED;
+}
+
+static int __init s3c_keypad_probe(struct platform_device *pdev)
+{
+	struct resource *res, *keypad_mem, *keypad_irq;
+	struct input_dev *input_dev;
+	struct s3c_keypad *s3c_keypad;
+	int ret, size;
+	int key, code;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+
+	keypad_mem = request_mem_region(res->start, size, pdev->name);
+	if (keypad_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+
+	key_base = ioremap(res->start, size);
+	if (key_base == NULL) {
+		pr_err("Failed to remap register block\n");
+		ret = -ENOMEM;
+		goto err_map;
+	}
+
+	keypad_clock = clk_get(&pdev->dev, "keypad");
+	if (IS_ERR(keypad_clock)) {
+		dev_err(&pdev->dev, "failed to find keypad clock source\n");
+		ret = PTR_ERR(keypad_clock);
+		goto err_clk;
+	}
+
+	clk_enable(keypad_clock);
+
+	s3c_keypad = kzalloc(sizeof(struct s3c_keypad), GFP_KERNEL);
+	input_dev = input_allocate_device();
+
+	if (!s3c_keypad || !input_dev) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+
+	platform_set_drvdata(pdev, s3c_keypad);
+	s3c_keypad->dev = input_dev;
+
+	writel(KEYIFCON_INIT, key_base+S3C_KEYIFCON);
+	writel(KEYIFFC_DIV, key_base+S3C_KEYIFFC);
+
+	/* Set GPIO Port for keypad mode and pull-up disable*/
+
+#if defined(CONFIG_KEYPAD_S3C_MSM)
+	s3c_setup_keypad_cfg_gpio();
+#else
+	s3c_setup_keypad_cfg_gpio(KEYPAD_ROWS, KEYPAD_COLUMNS);
+#endif
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	/* create and register the input driver */
+	set_bit(EV_KEY, input_dev->evbit);
+	s3c_keypad->nr_rows = KEYPAD_ROWS;
+	s3c_keypad->no_cols = KEYPAD_COLUMNS;
+	s3c_keypad->total_keys = MAX_KEYPAD_NR;
+
+	for (key = 0; key < s3c_keypad->total_keys; key++) {
+		code = s3c_keypad->keycodes[key] = keypad_keycode[key];
+		if (code <= 0)
+			continue;
+		set_bit(code & KEY_MAX, input_dev->keybit);
+	}
+
+	input_dev->name = DEVICE_NAME;
+	input_dev->phys = "s3c-keypad/input0";
+
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0001;
+
+	input_dev->keycode = keypad_keycode;
+
+	/* Scan timer init */
+	init_timer(&keypad_timer);
+	keypad_timer.function = keypad_timer_handler;
+	keypad_timer.data = (unsigned long)s3c_keypad;
+
+	/* For IRQ_KEYPAD */
+	keypad_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (keypad_irq == NULL) {
+		dev_err(&pdev->dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+	ret = request_irq(keypad_irq->start, s3c_keypad_isr, 0,
+		DEVICE_NAME, (void *) pdev);
+	if (ret) {
+		pr_err("request_irq failed (IRQ_KEYPAD)\n");
+		ret = -EIO;
+		goto err_irq;
+	}
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		pr_err("Unable to register s3c-keypad input device!!!\n");
+		goto out;
+	}
+
+	keypad_timer.expires = jiffies + (HZ/10);
+
+	if (is_timer_on == false) {
+		add_timer(&keypad_timer);
+		is_timer_on = true;
+	} else {
+		mod_timer(&keypad_timer, keypad_timer.expires);
+	}
+
+	pr_info(DEVICE_NAME " Initialized\n");
+	return 0;
+
+out:
+	free_irq(keypad_irq->start, input_dev);
+	free_irq(keypad_irq->end, input_dev);
+
+err_irq:
+	input_free_device(input_dev);
+	kfree(s3c_keypad);
+
+err_alloc:
+	clk_disable(keypad_clock);
+	clk_put(keypad_clock);
+
+err_clk:
+	iounmap(key_base);
+
+err_map:
+	release_resource(keypad_mem);
+	kfree(keypad_mem);
+
+err_req:
+	return ret;
+}
+
+static int s3c_keypad_remove(struct platform_device *pdev)
+{
+	struct input_dev *input_dev = platform_get_drvdata(pdev);
+	writel(KEYIFCON_CLEAR, key_base+S3C_KEYIFCON);
+
+	if (keypad_clock) {
+		clk_disable(keypad_clock);
+		clk_put(keypad_clock);
+		keypad_clock = NULL;
+	}
+
+	input_unregister_device(input_dev);
+	iounmap(key_base);
+	kfree(pdev->dev.platform_data);
+	free_irq(IRQ_KEYPAD, (void *) pdev);
+
+	del_timer(&keypad_timer);
+	pr_info(DEVICE_NAME " Removed.\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static unsigned int keyiffc;
+
+static int s3c_keypad_suspend(struct platform_device *dev, pm_message_t state)
+{
+	keyiffc = readl(key_base+S3C_KEYIFFC);
+
+	/* Clear the keypad interrupt status */
+	writel(KEYIFSTSCLR_CLEAR, key_base+S3C_KEYIFSTSCLR);
+
+	del_timer(&keypad_timer);
+	is_timer_on = false;
+
+	disable_irq(IRQ_KEYPAD);
+
+	clk_disable(keypad_clock);
+
+	return 0;
+}
+
+#define KEYCODE_UNKNOWN 10
+static int s3c_keypad_resume(struct platform_device *dev)
+{
+	struct s3c_keypad *s3c_keypad =
+		(struct s3c_keypad *) platform_get_drvdata(dev);
+	struct input_dev *idev = s3c_keypad->dev;
+	u32 mask;
+
+	clk_enable(keypad_clock);
+
+	writel(KEYIFCON_INIT, key_base+S3C_KEYIFCON);
+	writel(keyiffc, key_base+S3C_KEYIFFC);
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	mask = readl(S5P_WAKEUP_STAT);
+	if (mask & 0x21) {
+		input_report_key(idev, KEYCODE_UNKNOWN, 1);
+		udelay(5);
+		input_report_key(idev, KEYCODE_UNKNOWN, 0);
+	}
+
+	/* Clear the keypad interrupt status */
+	writel(KEYIFSTSCLR_CLEAR, key_base+S3C_KEYIFSTSCLR);
+
+	enable_irq(IRQ_KEYPAD);
+
+	return 0;
+}
+#else
+#define s3c_keypad_suspend NULL
+#define s3c_keypad_resume  NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver s3c_keypad_driver = {
+	.probe		= s3c_keypad_probe,
+	.remove		= s3c_keypad_remove,
+	.suspend	= s3c_keypad_suspend,
+	.resume		= s3c_keypad_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-keypad",
+	},
+};
+
+static int __init s3c_keypad_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&s3c_keypad_driver);
+
+	if (!ret)
+		pr_info("S3C Keypad Driver\n");
+
+	return ret;
+}
+
+static void __exit s3c_keypad_exit(void)
+{
+	platform_driver_unregister(&s3c_keypad_driver);
+}
+
+module_init(s3c_keypad_init);
+module_exit(s3c_keypad_exit);
+
+MODULE_AUTHOR("Samsung");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("KeyPad interface for Samsung S3C");
diff -Nur linux-2.6.35.7/drivers/input/keyboard/s3c-keypad.h tiny210/drivers/input/keyboard/s3c-keypad.h
--- linux-2.6.35.7/drivers/input/keyboard/s3c-keypad.h	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/keyboard/s3c-keypad.h	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,82 @@
+/* linux/drivers/input/keyboard/s3c-keypad.h
+ *
+ * Driver header for Samsung SoC keypad.
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef _S3C_KEYPAD_H_
+#define _S3C_KEYPAD_H_
+
+static void __iomem *key_base;
+
+#if defined(CONFIG_KEYPAD_S3C_MSM)
+#define KEYPAD_COLUMNS	8
+#define KEYPAD_ROWS	14
+#define MAX_KEYPAD_NR	112 /* 8*14 */
+#define MAX_KEYMASK_NR	56
+#else
+#define KEYPAD_COLUMNS	8
+#define KEYPAD_ROWS	8
+#define MAX_KEYPAD_NR	64  /* 8*8 */
+#define MAX_KEYMASK_NR	32
+#endif
+
+#if defined(CONFIG_KEYPAD_S3C_MSM)
+int keypad_keycode[] = {
+	1, 2, KEY_1, KEY_Q, KEY_A, 6, 7, KEY_LEFT, 64, 65, 66, 67, 68, 69,
+	9, 10, KEY_2, KEY_W, KEY_S, KEY_Z, KEY_RIGHT, 16, 70, 71, 72, 73, 74, 75,
+	17, 18, KEY_3, KEY_E, KEY_D, KEY_X, 23, KEY_UP, 76, 77, 78, 79, 80, 81,
+	25, 26, KEY_4, KEY_R, KEY_F, KEY_C, 31, 32, 82, 83, 84, 85, 86, 87,
+	33, KEY_O, KEY_5, KEY_T, KEY_G, KEY_V, KEY_DOWN, KEY_BACKSPACE, 88, 89, 90, 91, 92, 93,
+	KEY_P, KEY_0, KEY_6, KEY_Y, KEY_H, KEY_SPACE, 47, 48, 94, 95, 96, 97, 98, 99,
+	KEY_M, KEY_L, KEY_7, KEY_U, KEY_J, KEY_N, 55, KEY_ENTER, 100, 101, 102, 103, 104, 105,
+	KEY_LEFTSHIFT, KEY_9, KEY_8, KEY_I, KEY_K, KEY_B, 63, KEY_COMMA, 106, 107, 108, 109, 110, 111,
+};
+#else
+int keypad_keycode[] = {
+	1, 2, 3, 4, 5, 6, 7, 8,
+	9, 10, 11, 12, 13, 14, 15, 16,
+	17, 18, 19, 20, 21, 22, 23, 24,
+	25, 26, 27, 28, 29, 30, 31, 32,
+	33, 34, 35, 36, 37, 38, 39, 40,
+	41, 42, 43, 44, 45, 46, 47, 48,
+	49, 50, 51, 52, 53, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 63, 64
+};
+#endif
+
+#if defined(CONFIG_CPU_S3C6410)
+#define KEYPAD_DELAY		(50)
+#elif defined(CONFIG_CPU_S5PC100)
+#define KEYPAD_DELAY		(600)
+#elif defined(CONFIG_CPU_S5PV210)
+#define KEYPAD_DELAY		(900)
+#elif defined(CONFIG_CPU_S5P6442)
+#define KEYPAD_DELAY		(50)
+#endif
+
+#define	KEYIFCOL_CLEAR	(readl(key_base+S3C_KEYIFCOL) & ~0xffff)
+#define	KEYIFCON_CLEAR	(readl(key_base+S3C_KEYIFCON) & ~0x1f)
+#define	KEYIFFC_DIV	(readl(key_base+S3C_KEYIFFC) | 0x1)
+
+struct s3c_keypad {
+	struct input_dev *dev;
+	int nr_rows;
+	int no_cols;
+	int total_keys;
+	int keycodes[MAX_KEYPAD_NR];
+};
+
+#if defined(CONFIG_KEYPAD_S3C_MSM)
+extern void s3c_setup_keypad_cfg_gpio(void);
+#else
+extern void s3c_setup_keypad_cfg_gpio(int rows, int columns);
+#endif
+#endif /* _S3C_KEYIF_H_ */
diff -Nur linux-2.6.35.7/drivers/input/keyreset.c tiny210/drivers/input/keyreset.c
--- linux-2.6.35.7/drivers/input/keyreset.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/keyreset.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,230 @@
+/* drivers/input/keyreset.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/keyreset.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+
+
+struct keyreset_state {
+	struct input_handler input_handler;
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long upbit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long key[BITS_TO_LONGS(KEY_CNT)];
+	spinlock_t lock;
+	int key_down_target;
+	int key_down;
+	int key_up;
+	int restart_disabled;
+};
+
+int restart_requested;
+static void deferred_restart(struct work_struct *dummy)
+{
+	restart_requested = 2;
+	sys_sync();
+	restart_requested = 3;
+	kernel_restart(NULL);
+}
+static DECLARE_WORK(restart_work, deferred_restart);
+
+static void keyreset_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	unsigned long flags;
+	struct keyreset_state *state = handle->private;
+
+	if (type != EV_KEY)
+		return;
+
+	if (code >= KEY_MAX)
+		return;
+
+	if (!test_bit(code, state->keybit))
+		return;
+
+	spin_lock_irqsave(&state->lock, flags);
+	if (!test_bit(code, state->key) == !value)
+		goto done;
+	__change_bit(code, state->key);
+	if (test_bit(code, state->upbit)) {
+		if (value) {
+			state->restart_disabled = 1;
+			state->key_up++;
+		} else
+			state->key_up--;
+	} else {
+		if (value)
+			state->key_down++;
+		else
+			state->key_down--;
+	}
+	if (state->key_down == 0 && state->key_up == 0)
+		state->restart_disabled = 0;
+
+	pr_debug("reset key changed %d %d new state %d-%d-%d\n", code, value,
+		 state->key_down, state->key_up, state->restart_disabled);
+
+	if (value && !state->restart_disabled &&
+	    state->key_down == state->key_down_target) {
+		state->restart_disabled = 1;
+		if (restart_requested)
+			panic("keyboard reset failed, %d", restart_requested);
+		pr_info("keyboard reset\n");
+		schedule_work(&restart_work);
+		restart_requested = 1;
+	}
+done:
+	spin_unlock_irqrestore(&state->lock, flags);
+}
+
+static int keyreset_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i;
+	int ret;
+	struct input_handle *handle;
+	struct keyreset_state *state =
+		container_of(handler, struct keyreset_state, input_handler);
+
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, state->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "keyreset";
+	handle->private = state;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("using input dev %s for key reset\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keyreset_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id keyreset_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(input, keyreset_ids);
+
+static int keyreset_probe(struct platform_device *pdev)
+{
+	int ret;
+	int key, *keyp;
+	struct keyreset_state *state;
+	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	spin_lock_init(&state->lock);
+	keyp = pdata->keys_down;
+	while ((key = *keyp++)) {
+		if (key >= KEY_MAX)
+			continue;
+		state->key_down_target++;
+		__set_bit(key, state->keybit);
+	}
+	if (pdata->keys_up) {
+		keyp = pdata->keys_up;
+		while ((key = *keyp++)) {
+			if (key >= KEY_MAX)
+				continue;
+			__set_bit(key, state->keybit);
+			__set_bit(key, state->upbit);
+		}
+	}
+	state->input_handler.event = keyreset_event;
+	state->input_handler.connect = keyreset_connect;
+	state->input_handler.disconnect = keyreset_disconnect;
+	state->input_handler.name = KEYRESET_NAME;
+	state->input_handler.id_table = keyreset_ids;
+	ret = input_register_handler(&state->input_handler);
+	if (ret) {
+		kfree(state);
+		return ret;
+	}
+	platform_set_drvdata(pdev, state);
+	return 0;
+}
+
+int keyreset_remove(struct platform_device *pdev)
+{
+	struct keyreset_state *state = platform_get_drvdata(pdev);
+	input_unregister_handler(&state->input_handler);
+	kfree(state);
+	return 0;
+}
+
+
+struct platform_driver keyreset_driver = {
+	.driver.name = KEYRESET_NAME,
+	.probe = keyreset_probe,
+	.remove = keyreset_remove,
+};
+
+static int __init keyreset_init(void)
+{
+	return platform_driver_register(&keyreset_driver);
+}
+
+static void __exit keyreset_exit(void)
+{
+	return platform_driver_unregister(&keyreset_driver);
+}
+
+module_init(keyreset_init);
+module_exit(keyreset_exit);
diff -Nur linux-2.6.35.7/drivers/input/Makefile tiny210/drivers/input/Makefile
--- linux-2.6.35.7/drivers/input/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/Makefile	2011-08-08 12:52:34.000000000 +0800
@@ -24,5 +24,6 @@
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
 
 obj-$(CONFIG_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
diff -Nur linux-2.6.35.7/drivers/input/misc/gp2a.c tiny210/drivers/input/misc/gp2a.c
--- linux-2.6.35.7/drivers/input/misc/gp2a.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gp2a.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,664 @@
+/* linux/driver/input/misc/gp2a.c
+ * Copyright (C) 2010 Samsung Electronics. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/uaccess.h>
+#include <linux/gp2a.h>
+
+
+/* Note about power vs enable/disable:
+ *  The chip has two functions, proximity and ambient light sensing.
+ *  There is no separate power enablement to the two functions (unlike
+ *  the Capella CM3602/3623).
+ *  This module implements two drivers: /dev/proximity and /dev/light.
+ *  When either driver is enabled (via sysfs attributes), we give power
+ *  to the chip.  When both are disabled, we remove power from the chip.
+ *  In suspend, we remove power if light is disabled but not if proximity is
+ *  enabled (proximity is allowed to wakeup from suspend).
+ *
+ *  There are no ioctls for either driver interfaces.  Output is via
+ *  input device framework and control via sysfs attributes.
+ */
+
+
+#define gp2a_dbgmsg(str, args...) pr_debug("%s: " str, __func__, ##args)
+
+
+#define ADC_BUFFER_NUM	6
+
+/* ADDSEL is LOW */
+#define REGS_PROX		0x0 /* Read  Only */
+#define REGS_GAIN		0x1 /* Write Only */
+#define REGS_HYS		0x2 /* Write Only */
+#define REGS_CYCLE		0x3 /* Write Only */
+#define REGS_OPMOD		0x4 /* Write Only */
+
+/* sensor type */
+#define LIGHT           0
+#define PROXIMITY	1
+#define ALL		2
+
+static u8 reg_defaults[5] = {
+	0x00, /* PROX: read only register */
+	0x08, /* GAIN: large LED drive level */
+	0xC2, /* HYS: receiver sensitivity */
+	0x04, /* CYCLE: */
+	0x01, /* OPMOD: normal operating mode */
+};
+
+struct gp2a_data;
+
+enum {
+	LIGHT_ENABLED = BIT(0),
+	PROXIMITY_ENABLED = BIT(1),
+};
+
+/* driver data */
+struct gp2a_data {
+	struct input_dev *proximity_input_dev;
+	struct input_dev *light_input_dev;
+	struct gp2a_platform_data *pdata;
+	struct i2c_client *i2c_client;
+	int irq;
+	struct work_struct work_light;
+	struct hrtimer timer;
+	ktime_t light_poll_delay;
+	int adc_value_buf[ADC_BUFFER_NUM];
+	int adc_index_count;
+	bool adc_buf_initialized;
+	bool on;
+	u8 power_state;
+	struct mutex power_lock;
+	struct wake_lock prx_wake_lock;
+	struct workqueue_struct *wq;
+};
+
+int gp2a_i2c_write(struct gp2a_data *gp2a, u8 reg, u8 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int retry = 10;
+	struct i2c_client *client = gp2a->i2c_client;
+
+	if ((client == NULL) || (!client->adapter))
+		return -ENODEV;
+
+	while (retry--) {
+		data[0] = reg;
+		data[1] = *val;
+
+		msg->addr = client->addr;
+		msg->flags = 0; /* write */
+		msg->len = 2;
+		msg->buf = data;
+
+		err = i2c_transfer(client->adapter, msg, 1);
+
+		if (err >= 0)
+			return 0;
+	}
+	return err;
+}
+
+static void gp2a_light_enable(struct gp2a_data *gp2a)
+{
+	gp2a_dbgmsg("starting poll timer, delay %lldns\n",
+		    ktime_to_ns(gp2a->light_poll_delay));
+	hrtimer_start(&gp2a->timer, gp2a->light_poll_delay, HRTIMER_MODE_REL);
+}
+
+static void gp2a_light_disable(struct gp2a_data *gp2a)
+{
+	gp2a_dbgmsg("cancelling poll timer\n");
+	hrtimer_cancel(&gp2a->timer);
+	cancel_work_sync(&gp2a->work_light);
+}
+
+static ssize_t poll_delay_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%lld\n", ktime_to_ns(gp2a->light_poll_delay));
+}
+
+
+static ssize_t poll_delay_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	int64_t new_delay;
+	int err;
+
+	err = strict_strtoll(buf, 10, &new_delay);
+	if (err < 0)
+		return err;
+
+	gp2a_dbgmsg("new delay = %lldns, old delay = %lldns\n",
+		    new_delay, ktime_to_ns(gp2a->light_poll_delay));
+	mutex_lock(&gp2a->power_lock);
+	if (new_delay != ktime_to_ns(gp2a->light_poll_delay)) {
+		gp2a->light_poll_delay = ns_to_ktime(new_delay);
+		if (gp2a->power_state & LIGHT_ENABLED) {
+			gp2a_light_disable(gp2a);
+			gp2a_light_enable(gp2a);
+		}
+	}
+	mutex_unlock(&gp2a->power_lock);
+
+	return size;
+}
+
+static ssize_t light_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n",
+		       (gp2a->power_state & LIGHT_ENABLED) ? 1 : 0);
+}
+
+static ssize_t proximity_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n",
+		       (gp2a->power_state & PROXIMITY_ENABLED) ? 1 : 0);
+}
+
+static ssize_t light_enable_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	bool new_value;
+
+	if (sysfs_streq(buf, "1"))
+		new_value = true;
+	else if (sysfs_streq(buf, "0"))
+		new_value = false;
+	else {
+		pr_err("%s: invalid value %d\n", __func__, *buf);
+		return -EINVAL;
+	}
+
+	mutex_lock(&gp2a->power_lock);
+	gp2a_dbgmsg("new_value = %d, old state = %d\n",
+		    new_value, (gp2a->power_state & LIGHT_ENABLED) ? 1 : 0);
+	if (new_value && !(gp2a->power_state & LIGHT_ENABLED)) {
+		if (!gp2a->power_state)
+			gp2a->pdata->power(true);
+		gp2a->power_state |= LIGHT_ENABLED;
+		gp2a_light_enable(gp2a);
+	} else if (!new_value && (gp2a->power_state & LIGHT_ENABLED)) {
+		gp2a_light_disable(gp2a);
+		gp2a->power_state &= ~LIGHT_ENABLED;
+		if (!gp2a->power_state)
+			gp2a->pdata->power(false);
+	}
+	mutex_unlock(&gp2a->power_lock);
+	return size;
+}
+
+static ssize_t proximity_enable_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	bool new_value;
+
+	if (sysfs_streq(buf, "1"))
+		new_value = true;
+	else if (sysfs_streq(buf, "0"))
+		new_value = false;
+	else {
+		pr_err("%s: invalid value %d\n", __func__, *buf);
+		return -EINVAL;
+	}
+
+	mutex_lock(&gp2a->power_lock);
+	gp2a_dbgmsg("new_value = %d, old state = %d\n",
+		    new_value, (gp2a->power_state & PROXIMITY_ENABLED) ? 1 : 0);
+	if (new_value && !(gp2a->power_state & PROXIMITY_ENABLED)) {
+		if (!gp2a->power_state)
+			gp2a->pdata->power(true);
+		gp2a->power_state |= PROXIMITY_ENABLED;
+		enable_irq(gp2a->irq);
+		enable_irq_wake(gp2a->irq);
+		gp2a_i2c_write(gp2a, REGS_GAIN, &reg_defaults[1]);
+		gp2a_i2c_write(gp2a, REGS_HYS, &reg_defaults[2]);
+		gp2a_i2c_write(gp2a, REGS_CYCLE, &reg_defaults[3]);
+		gp2a_i2c_write(gp2a, REGS_OPMOD, &reg_defaults[4]);
+	} else if (!new_value && (gp2a->power_state & PROXIMITY_ENABLED)) {
+		disable_irq_wake(gp2a->irq);
+		disable_irq(gp2a->irq);
+		gp2a_i2c_write(gp2a, REGS_OPMOD, &reg_defaults[0]);
+		gp2a->power_state &= ~PROXIMITY_ENABLED;
+		if (!gp2a->power_state)
+			gp2a->pdata->power(false);
+	}
+	mutex_unlock(&gp2a->power_lock);
+	return size;
+}
+
+static DEVICE_ATTR(poll_delay, S_IRUGO | S_IWUSR | S_IWGRP,
+		   poll_delay_show, poll_delay_store);
+
+static struct device_attribute dev_attr_light_enable =
+	__ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
+	       light_enable_show, light_enable_store);
+
+static struct device_attribute dev_attr_proximity_enable =
+	__ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
+	       proximity_enable_show, proximity_enable_store);
+
+static struct attribute *light_sysfs_attrs[] = {
+	&dev_attr_light_enable.attr,
+	&dev_attr_poll_delay.attr,
+	NULL
+};
+
+static struct attribute_group light_attribute_group = {
+	.attrs = light_sysfs_attrs,
+};
+
+static struct attribute *proximity_sysfs_attrs[] = {
+	&dev_attr_proximity_enable.attr,
+	NULL
+};
+
+static struct attribute_group proximity_attribute_group = {
+	.attrs = proximity_sysfs_attrs,
+};
+
+static int lightsensor_get_adcvalue(struct gp2a_data *gp2a)
+{
+	int i = 0;
+	int j = 0;
+	unsigned int adc_total = 0;
+	int adc_avr_value;
+	unsigned int adc_index = 0;
+	unsigned int adc_max = 0;
+	unsigned int adc_min = 0;
+	int value = 0;
+
+	/* get ADC */
+	value = gp2a->pdata->light_adc_value();
+
+	adc_index = (gp2a->adc_index_count++) % ADC_BUFFER_NUM;
+
+	/*ADC buffer initialize (light sensor off ---> light sensor on) */
+	if (!gp2a->adc_buf_initialized) {
+		gp2a->adc_buf_initialized = true;
+		for (j = 0; j < ADC_BUFFER_NUM; j++)
+			gp2a->adc_value_buf[j] = value;
+	} else
+		gp2a->adc_value_buf[adc_index] = value;
+
+	adc_max = gp2a->adc_value_buf[0];
+	adc_min = gp2a->adc_value_buf[0];
+
+	for (i = 0; i < ADC_BUFFER_NUM; i++) {
+		adc_total += gp2a->adc_value_buf[i];
+
+		if (adc_max < gp2a->adc_value_buf[i])
+			adc_max = gp2a->adc_value_buf[i];
+
+		if (adc_min > gp2a->adc_value_buf[i])
+			adc_min = gp2a->adc_value_buf[i];
+	}
+	adc_avr_value = (adc_total-(adc_max+adc_min))/(ADC_BUFFER_NUM-2);
+
+	if (gp2a->adc_index_count == ADC_BUFFER_NUM-1)
+		gp2a->adc_index_count = 0;
+
+	return adc_avr_value;
+}
+
+static void gp2a_work_func_light(struct work_struct *work)
+{
+	struct gp2a_data *gp2a = container_of(work, struct gp2a_data,
+					      work_light);
+	int adc = lightsensor_get_adcvalue(gp2a);
+	input_report_abs(gp2a->light_input_dev, ABS_MISC, adc);
+	input_sync(gp2a->light_input_dev);
+}
+
+/* This function is for light sensor.  It operates every a few seconds.
+ * It asks for work to be done on a thread because i2c needs a thread
+ * context (slow and blocking) and then reschedules the timer to run again.
+ */
+static enum hrtimer_restart gp2a_timer_func(struct hrtimer *timer)
+{
+	struct gp2a_data *gp2a = container_of(timer, struct gp2a_data, timer);
+	queue_work(gp2a->wq, &gp2a->work_light);
+	hrtimer_forward_now(&gp2a->timer, gp2a->light_poll_delay);
+	return HRTIMER_RESTART;
+}
+
+/* interrupt happened due to transition/change of near/far proximity state */
+irqreturn_t gp2a_irq_handler(int irq, void *data)
+{
+	struct gp2a_data *ip = data;
+	int val = gpio_get_value(ip->pdata->p_out);
+	if (val < 0) {
+		pr_err("%s: gpio_get_value error %d\n", __func__, val);
+		return IRQ_HANDLED;
+	}
+
+	gp2a_dbgmsg("gp2a: proximity val=%d\n", val);
+
+	/* 0 is close, 1 is far */
+	input_report_abs(ip->proximity_input_dev, ABS_DISTANCE, val);
+	input_sync(ip->proximity_input_dev);
+	wake_lock_timeout(&ip->prx_wake_lock, 3*HZ);
+
+	return IRQ_HANDLED;
+}
+
+static int gp2a_setup_irq(struct gp2a_data *gp2a)
+{
+	int rc = -EIO;
+	struct gp2a_platform_data *pdata = gp2a->pdata;
+	int irq;
+
+	gp2a_dbgmsg("start\n");
+
+	rc = gpio_request(pdata->p_out, "gpio_proximity_out");
+	if (rc < 0) {
+		pr_err("%s: gpio %d request failed (%d)\n",
+			__func__, pdata->p_out, rc);
+		return rc;
+	}
+
+	rc = gpio_direction_input(pdata->p_out);
+	if (rc < 0) {
+		pr_err("%s: failed to set gpio %d as input (%d)\n",
+			__func__, pdata->p_out, rc);
+		goto err_gpio_direction_input;
+	}
+
+	irq = gpio_to_irq(pdata->p_out);
+	rc = request_irq(irq,
+			 gp2a_irq_handler,
+			 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			 "proximity_int",
+			 gp2a);
+	if (rc < 0) {
+		pr_err("%s: request_irq(%d) failed for gpio %d (%d)\n",
+			__func__, irq,
+			pdata->p_out, rc);
+		goto err_request_irq;
+	}
+
+	/* start with interrupts disabled */
+	disable_irq(irq);
+	gp2a->irq = irq;
+
+	gp2a_dbgmsg("success\n");
+
+	goto done;
+
+err_request_irq:
+err_gpio_direction_input:
+	gpio_free(pdata->p_out);
+done:
+	return rc;
+}
+
+static int gp2a_i2c_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
+{
+	int ret = -ENODEV;
+	struct input_dev *input_dev;
+	struct gp2a_data *gp2a;
+	struct gp2a_platform_data *pdata = client->dev.platform_data;
+
+	if (!pdata) {
+		pr_err("%s: missing pdata!\n", __func__);
+		return ret;
+	}
+	if (!pdata->power || !pdata->light_adc_value) {
+		pr_err("%s: incomplete pdata!\n", __func__);
+		return ret;
+	}
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: i2c functionality check failed!\n", __func__);
+		return ret;
+	}
+
+	gp2a = kzalloc(sizeof(struct gp2a_data), GFP_KERNEL);
+	if (!gp2a) {
+		pr_err("%s: failed to alloc memory for module data\n",
+		       __func__);
+		return -ENOMEM;
+	}
+
+	gp2a->pdata = pdata;
+	gp2a->i2c_client = client;
+	i2c_set_clientdata(client, gp2a);
+
+	/* wake lock init */
+	wake_lock_init(&gp2a->prx_wake_lock, WAKE_LOCK_SUSPEND,
+		       "prx_wake_lock");
+	mutex_init(&gp2a->power_lock);
+
+	ret = gp2a_setup_irq(gp2a);
+	if (ret) {
+		pr_err("%s: could not setup irq\n", __func__);
+		goto err_setup_irq;
+	}
+
+	/* allocate proximity input_device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("%s: could not allocate input device\n", __func__);
+		goto err_input_allocate_device_proximity;
+	}
+	gp2a->proximity_input_dev = input_dev;
+	input_set_drvdata(input_dev, gp2a);
+	input_dev->name = "proximity";
+	input_set_capability(input_dev, EV_ABS, ABS_DISTANCE);
+	input_set_abs_params(input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	gp2a_dbgmsg("registering proximity input device\n");
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		pr_err("%s: could not register input device\n", __func__);
+		input_free_device(input_dev);
+		goto err_input_register_device_proximity;
+	}
+	ret = sysfs_create_group(&input_dev->dev.kobj,
+				 &proximity_attribute_group);
+	if (ret) {
+		pr_err("%s: could not create sysfs group\n", __func__);
+		goto err_sysfs_create_group_proximity;
+	}
+
+	/* hrtimer settings.  we poll for light values using a timer. */
+	hrtimer_init(&gp2a->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	gp2a->light_poll_delay = ns_to_ktime(200 * NSEC_PER_MSEC);
+	gp2a->timer.function = gp2a_timer_func;
+
+	/* the timer just fires off a work queue request.  we need a thread
+	   to read the i2c (can be slow and blocking). */
+	gp2a->wq = create_singlethread_workqueue("gp2a_wq");
+	if (!gp2a->wq) {
+		ret = -ENOMEM;
+		pr_err("%s: could not create workqueue\n", __func__);
+		goto err_create_workqueue;
+	}
+	/* this is the thread function we run on the work queue */
+	INIT_WORK(&gp2a->work_light, gp2a_work_func_light);
+
+	/* allocate lightsensor-level input_device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("%s: could not allocate input device\n", __func__);
+		ret = -ENOMEM;
+		goto err_input_allocate_device_light;
+	}
+	input_set_drvdata(input_dev, gp2a);
+	input_dev->name = "lightsensor-level";
+	input_set_capability(input_dev, EV_ABS, ABS_MISC);
+	input_set_abs_params(input_dev, ABS_MISC, 0, 1, 0, 0);
+
+	gp2a_dbgmsg("registering lightsensor-level input device\n");
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		pr_err("%s: could not register input device\n", __func__);
+		input_free_device(input_dev);
+		goto err_input_register_device_light;
+	}
+	gp2a->light_input_dev = input_dev;
+	ret = sysfs_create_group(&input_dev->dev.kobj,
+				 &light_attribute_group);
+	if (ret) {
+		pr_err("%s: could not create sysfs group\n", __func__);
+		goto err_sysfs_create_group_light;
+	}
+	goto done;
+
+	/* error, unwind it all */
+err_sysfs_create_group_light:
+	input_unregister_device(gp2a->light_input_dev);
+err_input_register_device_light:
+err_input_allocate_device_light:
+	destroy_workqueue(gp2a->wq);
+err_create_workqueue:
+	sysfs_remove_group(&gp2a->proximity_input_dev->dev.kobj,
+			   &proximity_attribute_group);
+err_sysfs_create_group_proximity:
+	input_unregister_device(gp2a->proximity_input_dev);
+err_input_register_device_proximity:
+err_input_allocate_device_proximity:
+	free_irq(gp2a->irq, 0);
+	gpio_free(gp2a->pdata->p_out);
+err_setup_irq:
+	mutex_destroy(&gp2a->power_lock);
+	wake_lock_destroy(&gp2a->prx_wake_lock);
+	kfree(gp2a);
+done:
+	return ret;
+}
+
+static int gp2a_suspend(struct device *dev)
+{
+	/* We disable power only if proximity is disabled.  If proximity
+	   is enabled, we leave power on because proximity is allowed
+	   to wake up device.  We remove power without changing
+	   gp2a->power_state because we use that state in resume.
+	*/
+	struct i2c_client *client = to_i2c_client(dev);
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	if (gp2a->power_state & LIGHT_ENABLED)
+		gp2a_light_disable(gp2a);
+	if (gp2a->power_state == LIGHT_ENABLED)
+		gp2a->pdata->power(false);
+	return 0;
+}
+
+static int gp2a_resume(struct device *dev)
+{
+	/* Turn power back on if we were before suspend. */
+	struct i2c_client *client = to_i2c_client(dev);
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	if (gp2a->power_state == LIGHT_ENABLED)
+		gp2a->pdata->power(true);
+	if (gp2a->power_state & LIGHT_ENABLED)
+		gp2a_light_enable(gp2a);
+	return 0;
+}
+
+static int gp2a_i2c_remove(struct i2c_client *client)
+{
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	sysfs_remove_group(&gp2a->light_input_dev->dev.kobj,
+			   &light_attribute_group);
+	input_unregister_device(gp2a->light_input_dev);
+	sysfs_remove_group(&gp2a->proximity_input_dev->dev.kobj,
+			   &proximity_attribute_group);
+	input_unregister_device(gp2a->proximity_input_dev);
+	free_irq(gp2a->irq, NULL);
+	gpio_free(gp2a->pdata->p_out);
+	if (gp2a->power_state) {
+		gp2a->power_state = 0;
+		if (gp2a->power_state & LIGHT_ENABLED)
+			gp2a_light_disable(gp2a);
+		gp2a->pdata->power(false);
+	}
+	destroy_workqueue(gp2a->wq);
+	mutex_destroy(&gp2a->power_lock);
+	wake_lock_destroy(&gp2a->prx_wake_lock);
+	kfree(gp2a);
+	return 0;
+}
+
+static const struct i2c_device_id gp2a_device_id[] = {
+	{"gp2a", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, gp2a_device_id);
+
+static const struct dev_pm_ops gp2a_pm_ops = {
+	.suspend = gp2a_suspend,
+	.resume = gp2a_resume
+};
+
+static struct i2c_driver gp2a_i2c_driver = {
+	.driver = {
+		.name = "gp2a",
+		.owner = THIS_MODULE,
+		.pm = &gp2a_pm_ops
+	},
+	.probe		= gp2a_i2c_probe,
+	.remove		= gp2a_i2c_remove,
+	.id_table	= gp2a_device_id,
+};
+
+
+static int __init gp2a_init(void)
+{
+	return i2c_add_driver(&gp2a_i2c_driver);
+}
+
+static void __exit gp2a_exit(void)
+{
+	i2c_del_driver(&gp2a_i2c_driver);
+}
+
+module_init(gp2a_init);
+module_exit(gp2a_exit);
+
+MODULE_AUTHOR("mjchen@sta.samsung.com");
+MODULE_DESCRIPTION("Optical Sensor driver for gp2ap002a00f");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/input/misc/gpio_axis.c tiny210/drivers/input/misc/gpio_axis.c
--- linux-2.6.35.7/drivers/input/misc/gpio_axis.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gpio_axis.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,192 @@
+/* drivers/input/misc/gpio_axis.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+struct gpio_axis_state {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_axis_info *info;
+	uint32_t pos;
+};
+
+uint16_t gpio_axis_4bit_gray_map_table[] = {
+	[0x0] = 0x0, [0x1] = 0x1, /* 0000 0001 */
+	[0x3] = 0x2, [0x2] = 0x3, /* 0011 0010 */
+	[0x6] = 0x4, [0x7] = 0x5, /* 0110 0111 */
+	[0x5] = 0x6, [0x4] = 0x7, /* 0101 0100 */
+	[0xc] = 0x8, [0xd] = 0x9, /* 1100 1101 */
+	[0xf] = 0xa, [0xe] = 0xb, /* 1111 1110 */
+	[0xa] = 0xc, [0xb] = 0xd, /* 1010 1011 */
+	[0x9] = 0xe, [0x8] = 0xf, /* 1001 1000 */
+};
+uint16_t gpio_axis_4bit_gray_map(struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_4bit_gray_map_table[in];
+}
+
+uint16_t gpio_axis_5bit_singletrack_map_table[] = {
+	[0x10] = 0x00, [0x14] = 0x01, [0x1c] = 0x02, /*     10000 10100 11100 */
+	[0x1e] = 0x03, [0x1a] = 0x04, [0x18] = 0x05, /*     11110 11010 11000 */
+	[0x08] = 0x06, [0x0a] = 0x07, [0x0e] = 0x08, /*    01000 01010 01110  */
+	[0x0f] = 0x09, [0x0d] = 0x0a, [0x0c] = 0x0b, /*    01111 01101 01100  */
+	[0x04] = 0x0c, [0x05] = 0x0d, [0x07] = 0x0e, /*   00100 00101 00111   */
+	[0x17] = 0x0f, [0x16] = 0x10, [0x06] = 0x11, /*   10111 10110 00110   */
+	[0x02] = 0x12, [0x12] = 0x13, [0x13] = 0x14, /*  00010 10010 10011    */
+	[0x1b] = 0x15, [0x0b] = 0x16, [0x03] = 0x17, /*  11011 01011 00011    */
+	[0x01] = 0x18, [0x09] = 0x19, [0x19] = 0x1a, /* 00001 01001 11001     */
+	[0x1d] = 0x1b, [0x15] = 0x1c, [0x11] = 0x1d, /* 11101 10101 10001     */
+};
+uint16_t gpio_axis_5bit_singletrack_map(
+	struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_5bit_singletrack_map_table[in];
+}
+
+static void gpio_event_update_axis(struct gpio_axis_state *as, int report)
+{
+	struct gpio_event_axis_info *ai = as->info;
+	int i;
+	int change;
+	uint16_t state = 0;
+	uint16_t pos;
+	uint16_t old_pos = as->pos;
+	for (i = ai->count - 1; i >= 0; i--)
+		state = (state << 1) | gpio_get_value(ai->gpio[i]);
+	pos = ai->map(ai, state);
+	if (ai->flags & GPIOEAF_PRINT_RAW)
+		pr_info("axis %d-%d raw %x, pos %d -> %d\n",
+			ai->type, ai->code, state, old_pos, pos);
+	if (report && pos != old_pos) {
+		if (ai->type == EV_REL) {
+			change = (ai->decoded_size + pos - old_pos) %
+				  ai->decoded_size;
+			if (change > ai->decoded_size / 2)
+				change -= ai->decoded_size;
+			if (change == ai->decoded_size / 2) {
+				if (ai->flags & GPIOEAF_PRINT_EVENT)
+					pr_info("axis %d-%d unknown direction, "
+						"pos %d -> %d\n", ai->type,
+						ai->code, old_pos, pos);
+				change = 0; /* no closest direction */
+			}
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d change %d\n",
+					ai->type, ai->code, change);
+			input_report_rel(as->input_devs->dev[ai->dev],
+						ai->code, change);
+		} else {
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d now %d\n",
+					ai->type, ai->code, pos);
+			input_event(as->input_devs->dev[ai->dev],
+					ai->type, ai->code, pos);
+		}
+		input_sync(as->input_devs->dev[ai->dev]);
+	}
+	as->pos = pos;
+}
+
+static irqreturn_t gpio_axis_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_axis_state *as = dev_id;
+	gpio_event_update_axis(as, 1);
+	return IRQ_HANDLED;
+}
+
+int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			 struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	int irq;
+	struct gpio_event_axis_info *ai;
+	struct gpio_axis_state *as;
+
+	ai = container_of(info, struct gpio_event_axis_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		for (i = 0; i < ai->count; i++)
+			disable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		for (i = 0; i < ai->count; i++)
+			enable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		*data = as = kmalloc(sizeof(*as), GFP_KERNEL);
+		if (as == NULL) {
+			ret = -ENOMEM;
+			goto err_alloc_axis_state_failed;
+		}
+		as->input_devs = input_devs;
+		as->info = ai;
+		if (ai->dev >= input_devs->count) {
+			pr_err("gpio_event_axis: bad device index %d >= %d "
+				"for %d:%d\n", ai->dev, input_devs->count,
+				ai->type, ai->code);
+			ret = -EINVAL;
+			goto err_bad_device_index;
+		}
+
+		input_set_capability(input_devs->dev[ai->dev],
+				     ai->type, ai->code);
+		if (ai->type == EV_ABS) {
+			input_set_abs_params(input_devs->dev[ai->dev], ai->code,
+					     0, ai->decoded_size - 1, 0, 0);
+		}
+		for (i = 0; i < ai->count; i++) {
+			ret = gpio_request(ai->gpio[i], "gpio_event_axis");
+			if (ret < 0)
+				goto err_request_gpio_failed;
+			ret = gpio_direction_input(ai->gpio[i]);
+			if (ret < 0)
+				goto err_gpio_direction_input_failed;
+			ret = irq = gpio_to_irq(ai->gpio[i]);
+			if (ret < 0)
+				goto err_get_irq_num_failed;
+			ret = request_irq(irq, gpio_axis_irq_handler,
+					  IRQF_TRIGGER_RISING |
+					  IRQF_TRIGGER_FALLING,
+					  "gpio_event_axis", as);
+			if (ret < 0)
+				goto err_request_irq_failed;
+		}
+		gpio_event_update_axis(as, 0);
+		return 0;
+	}
+
+	ret = 0;
+	as = *data;
+	for (i = ai->count - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ai->gpio[i]), as);
+err_request_irq_failed:
+err_get_irq_num_failed:
+err_gpio_direction_input_failed:
+		gpio_free(ai->gpio[i]);
+err_request_gpio_failed:
+		;
+	}
+err_bad_device_index:
+	kfree(as);
+	*data = NULL;
+err_alloc_axis_state_failed:
+	return ret;
+}
diff -Nur linux-2.6.35.7/drivers/input/misc/gpio_event.c tiny210/drivers/input/misc/gpio_event.c
--- linux-2.6.35.7/drivers/input/misc/gpio_event.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gpio_event.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,260 @@
+/* drivers/input/misc/gpio_event.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+struct gpio_event {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_platform_data *info;
+	struct early_suspend early_suspend;
+	void *state[0];
+};
+
+static int gpio_input_event(
+	struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	int i;
+	int devnr;
+	int ret = 0;
+	int tmp_ret;
+	struct gpio_event_info **ii;
+	struct gpio_event *ip = input_get_drvdata(dev);
+
+	for (devnr = 0; devnr < ip->input_devs->count; devnr++)
+		if (ip->input_devs->dev[devnr] == dev)
+			break;
+	if (devnr == ip->input_devs->count) {
+		pr_err("gpio_input_event: unknown device %p\n", dev);
+		return -EIO;
+	}
+
+	for (i = 0, ii = ip->info->info; i < ip->info->info_count; i++, ii++) {
+		if ((*ii)->event) {
+			tmp_ret = (*ii)->event(ip->input_devs, *ii,
+						&ip->state[i],
+						devnr, type, code, value);
+			if (tmp_ret)
+				ret = tmp_ret;
+		}
+	}
+	return ret;
+}
+
+static int gpio_event_call_all_func(struct gpio_event *ip, int func)
+{
+	int i;
+	int ret;
+	struct gpio_event_info **ii;
+
+	if (func == GPIO_EVENT_FUNC_INIT || func == GPIO_EVENT_FUNC_RESUME) {
+		ii = ip->info->info;
+		for (i = 0; i < ip->info->info_count; i++, ii++) {
+			if ((*ii)->func == NULL) {
+				ret = -ENODEV;
+				pr_err("gpio_event_probe: Incomplete pdata, "
+					"no function\n");
+				goto err_no_func;
+			}
+			if (func == GPIO_EVENT_FUNC_RESUME && (*ii)->no_suspend)
+				continue;
+			ret = (*ii)->func(ip->input_devs, *ii, &ip->state[i],
+					  func);
+			if (ret) {
+				pr_err("gpio_event_probe: function failed\n");
+				goto err_func_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	i = ip->info->info_count;
+	ii = ip->info->info + i;
+	while (i > 0) {
+		i--;
+		ii--;
+		if ((func & ~1) == GPIO_EVENT_FUNC_SUSPEND && (*ii)->no_suspend)
+			continue;
+		(*ii)->func(ip->input_devs, *ii, &ip->state[i], func & ~1);
+err_func_failed:
+err_no_func:
+		;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void gpio_event_suspend(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_SUSPEND);
+	ip->info->power(ip->info, 0);
+}
+
+void gpio_event_resume(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	ip->info->power(ip->info, 1);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_RESUME);
+}
+#endif
+
+static int gpio_event_probe(struct platform_device *pdev)
+{
+	int err;
+	struct gpio_event *ip;
+	struct gpio_event_platform_data *event_info;
+	int dev_count = 1;
+	int i;
+	int registered = 0;
+
+	event_info = pdev->dev.platform_data;
+	if (event_info == NULL) {
+		pr_err("gpio_event_probe: No pdata\n");
+		return -ENODEV;
+	}
+	if ((!event_info->name && !event_info->names[0]) ||
+	    !event_info->info || !event_info->info_count) {
+		pr_err("gpio_event_probe: Incomplete pdata\n");
+		return -ENODEV;
+	}
+	if (!event_info->name)
+		while (event_info->names[dev_count])
+			dev_count++;
+	ip = kzalloc(sizeof(*ip) +
+		     sizeof(ip->state[0]) * event_info->info_count +
+		     sizeof(*ip->input_devs) +
+		     sizeof(ip->input_devs->dev[0]) * dev_count, GFP_KERNEL);
+	if (ip == NULL) {
+		err = -ENOMEM;
+		pr_err("gpio_event_probe: Failed to allocate private data\n");
+		goto err_kp_alloc_failed;
+	}
+	ip->input_devs = (void*)&ip->state[event_info->info_count];
+	platform_set_drvdata(pdev, ip);
+
+	for (i = 0; i < dev_count; i++) {
+		struct input_dev *input_dev = input_allocate_device();
+		if (input_dev == NULL) {
+			err = -ENOMEM;
+			pr_err("gpio_event_probe: "
+				"Failed to allocate input device\n");
+			goto err_input_dev_alloc_failed;
+		}
+		input_set_drvdata(input_dev, ip);
+		input_dev->name = event_info->name ?
+					event_info->name : event_info->names[i];
+		input_dev->event = gpio_input_event;
+		ip->input_devs->dev[i] = input_dev;
+	}
+	ip->input_devs->count = dev_count;
+	ip->info = event_info;
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		ip->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+		ip->early_suspend.suspend = gpio_event_suspend;
+		ip->early_suspend.resume = gpio_event_resume;
+		register_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 1);
+	}
+
+	err = gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_INIT);
+	if (err)
+		goto err_call_all_func_failed;
+
+	for (i = 0; i < dev_count; i++) {
+		err = input_register_device(ip->input_devs->dev[i]);
+		if (err) {
+			pr_err("gpio_event_probe: Unable to register %s "
+				"input device\n", ip->input_devs->dev[i]->name);
+			goto err_input_register_device_failed;
+		}
+		registered++;
+	}
+
+	return 0;
+
+err_input_register_device_failed:
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+err_call_all_func_failed:
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < registered; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	for (i = dev_count - 1; i >= registered; i--) {
+		input_free_device(ip->input_devs->dev[i]);
+err_input_dev_alloc_failed:
+		;
+	}
+	kfree(ip);
+err_kp_alloc_failed:
+	return err;
+}
+
+static int gpio_event_remove(struct platform_device *pdev)
+{
+	struct gpio_event *ip = platform_get_drvdata(pdev);
+	int i;
+
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+	if (ip->info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < ip->input_devs->count; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	kfree(ip);
+	return 0;
+}
+
+static struct platform_driver gpio_event_driver = {
+	.probe		= gpio_event_probe,
+	.remove		= gpio_event_remove,
+	.driver		= {
+		.name	= GPIO_EVENT_DEV_NAME,
+	},
+};
+
+static int __devinit gpio_event_init(void)
+{
+	return platform_driver_register(&gpio_event_driver);
+}
+
+static void __exit gpio_event_exit(void)
+{
+	platform_driver_unregister(&gpio_event_driver);
+}
+
+module_init(gpio_event_init);
+module_exit(gpio_event_exit);
+
+MODULE_DESCRIPTION("GPIO Event Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.35.7/drivers/input/misc/gpio_input.c tiny210/drivers/input/misc/gpio_input.c
--- linux-2.6.35.7/drivers/input/misc/gpio_input.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gpio_input.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,367 @@
+/* drivers/input/misc/gpio_input.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+
+enum {
+	DEBOUNCE_UNSTABLE     = BIT(0),	/* Got irq, while debouncing */
+	DEBOUNCE_PRESSED      = BIT(1),
+	DEBOUNCE_NOTPRESSED   = BIT(2),
+	DEBOUNCE_WAIT_IRQ     = BIT(3),	/* Stable irq state */
+	DEBOUNCE_POLL         = BIT(4),	/* Stable polling state */
+
+	DEBOUNCE_UNKNOWN =
+		DEBOUNCE_PRESSED | DEBOUNCE_NOTPRESSED,
+};
+
+struct gpio_key_state {
+	struct gpio_input_state *ds;
+	uint8_t debounce;
+};
+
+struct gpio_input_state {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_input_info *info;
+	struct hrtimer timer;
+	int use_irq;
+	int debounce_count;
+	spinlock_t irq_lock;
+	struct wake_lock wake_lock;
+	struct gpio_key_state key_state[0];
+};
+
+static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
+{
+	int i;
+	int pressed;
+	struct gpio_input_state *ds =
+		container_of(timer, struct gpio_input_state, timer);
+	unsigned gpio_flags = ds->info->flags;
+	unsigned npolarity;
+	int nkeys = ds->info->keymap_size;
+	const struct gpio_event_direct_entry *key_entry;
+	struct gpio_key_state *key_state;
+	unsigned long irqflags;
+	uint8_t debounce;
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++)
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+#endif
+	key_entry = ds->info->keymap;
+	key_state = ds->key_state;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		debounce = key_state->debounce;
+		if (debounce & DEBOUNCE_WAIT_IRQ)
+			continue;
+		if (key_state->debounce & DEBOUNCE_UNSTABLE) {
+			debounce = key_state->debounce = DEBOUNCE_UNKNOWN;
+			enable_irq(gpio_to_irq(key_entry->gpio));
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+				"(%d) continue debounce\n",
+				ds->info->type, key_entry->code,
+				i, key_entry->gpio);
+		}
+		npolarity = !(gpio_flags & GPIOEDF_ACTIVE_HIGH);
+		pressed = gpio_get_value(key_entry->gpio) ^ npolarity;
+		if (debounce & DEBOUNCE_POLL) {
+			if (pressed == !(debounce & DEBOUNCE_PRESSED)) {
+				ds->debounce_count++;
+				key_state->debounce = DEBOUNCE_UNKNOWN;
+				if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+					pr_info("gpio_keys_scan_keys: key %x-"
+						"%x, %d (%d) start debounce\n",
+						ds->info->type, key_entry->code,
+						i, key_entry->gpio);
+			}
+			continue;
+		}
+		if (pressed && (debounce & DEBOUNCE_NOTPRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 1\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_PRESSED;
+			continue;
+		}
+		if (!pressed && (debounce & DEBOUNCE_PRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 0\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_NOTPRESSED;
+			continue;
+		}
+		/* key is stable */
+		ds->debounce_count--;
+		if (ds->use_irq)
+			key_state->debounce |= DEBOUNCE_WAIT_IRQ;
+		else
+			key_state->debounce |= DEBOUNCE_POLL;
+		if (gpio_flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d (%d) "
+				"changed to %d\n", ds->info->type,
+				key_entry->code, i, key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+	}
+#endif
+
+	if (ds->debounce_count)
+		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
+	else if (!ds->use_irq)
+		hrtimer_start(timer, ds->info->poll_time, HRTIMER_MODE_REL);
+	else
+		wake_unlock(&ds->wake_lock);
+
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_key_state *ks = dev_id;
+	struct gpio_input_state *ds = ks->ds;
+	int keymap_index = ks - ds->key_state;
+	const struct gpio_event_direct_entry *key_entry;
+	unsigned long irqflags;
+	int pressed;
+
+	if (!ds->use_irq)
+		return IRQ_HANDLED;
+
+	key_entry = &ds->info->keymap[keymap_index];
+
+	if (ds->info->debounce_time.tv64) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ks->debounce & DEBOUNCE_WAIT_IRQ) {
+			ks->debounce = DEBOUNCE_UNKNOWN;
+			if (ds->debounce_count++ == 0) {
+				wake_lock(&ds->wake_lock);
+				hrtimer_start(
+					&ds->timer, ds->info->debounce_time,
+					HRTIMER_MODE_REL);
+			}
+			if (ds->info->flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_event_input_irq_handler: "
+					"key %x-%x, %d (%d) start debounce\n",
+					ds->info->type, key_entry->code,
+					keymap_index, key_entry->gpio);
+		} else {
+			disable_irq_nosync(irq);
+			ks->debounce = DEBOUNCE_UNSTABLE;
+		}
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+	} else {
+		pressed = gpio_get_value(key_entry->gpio) ^
+			!(ds->info->flags & GPIOEDF_ACTIVE_HIGH);
+		if (ds->info->flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_event_input_irq_handler: key %x-%x, %d "
+				"(%d) changed to %d\n",
+				ds->info->type, key_entry->code, keymap_index,
+				key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+	return IRQ_HANDLED;
+}
+
+static int gpio_event_input_request_irqs(struct gpio_input_state *ds)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long req_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+
+	for (i = 0; i < ds->info->keymap_size; i++) {
+		err = irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_event_input_irq_handler,
+				  req_flags, "gpio_keys", &ds->key_state[i]);
+		if (err) {
+			pr_err("gpio_event_input_request_irqs: request_irq "
+				"failed for input %d, irq %d\n",
+				ds->info->keymap[i].gpio, irq);
+			goto err_request_irq_failed;
+		}
+		if (ds->info->info.no_suspend) {
+			err = enable_irq_wake(irq);
+			if (err) {
+				pr_err("gpio_event_input_request_irqs: "
+					"enable_irq_wake failed for input %d, "
+					"irq %d\n",
+					ds->info->keymap[i].gpio, irq);
+				goto err_enable_irq_wake_failed;
+			}
+		}
+	}
+	return 0;
+
+	for (i = ds->info->keymap_size - 1; i >= 0; i--) {
+		irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (ds->info->info.no_suspend)
+			disable_irq_wake(irq);
+err_enable_irq_wake_failed:
+		free_irq(irq, &ds->key_state[i]);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	unsigned long irqflags;
+	struct gpio_event_input_info *di;
+	struct gpio_input_state *ds = *data;
+
+	di = container_of(info, struct gpio_event_input_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				disable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_cancel(&ds->timer);
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				enable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (ktime_to_ns(di->poll_time) <= 0)
+			di->poll_time = ktime_set(0, 20 * NSEC_PER_MSEC);
+
+		*data = ds = kzalloc(sizeof(*ds) + sizeof(ds->key_state[0]) *
+					di->keymap_size, GFP_KERNEL);
+		if (ds == NULL) {
+			ret = -ENOMEM;
+			pr_err("gpio_event_input_func: "
+				"Failed to allocate private data\n");
+			goto err_ds_alloc_failed;
+		}
+		ds->debounce_count = di->keymap_size;
+		ds->input_devs = input_devs;
+		ds->info = di;
+		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
+		spin_lock_init(&ds->irq_lock);
+
+		for (i = 0; i < di->keymap_size; i++) {
+			int dev = di->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_input_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					di->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], di->type,
+					     di->keymap[i].code);
+			ds->key_state[i].ds = ds;
+			ds->key_state[i].debounce = DEBOUNCE_UNKNOWN;
+		}
+
+		for (i = 0; i < di->keymap_size; i++) {
+			ret = gpio_request(di->keymap[i].gpio, "gpio_kp_in");
+			if (ret) {
+				pr_err("gpio_event_input_func: gpio_request "
+					"failed for %d\n", di->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_input(di->keymap[i].gpio);
+			if (ret) {
+				pr_err("gpio_event_input_func: "
+					"gpio_direction_input failed for %d\n",
+					di->keymap[i].gpio);
+				goto err_gpio_configure_failed;
+			}
+		}
+
+		ret = gpio_event_input_request_irqs(ds);
+
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		ds->use_irq = ret == 0;
+
+		pr_info("GPIO Input Driver: Start gpio inputs for %s%s in %s "
+			"mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			ret == 0 ? "interrupt" : "polling");
+
+		hrtimer_init(&ds->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ds->timer.function = gpio_event_input_timer_func;
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	ret = 0;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	hrtimer_cancel(&ds->timer);
+	if (ds->use_irq) {
+		for (i = di->keymap_size - 1; i >= 0; i--) {
+			int irq = gpio_to_irq(di->keymap[i].gpio);
+			if (ds->info->info.no_suspend)
+				disable_irq_wake(irq);
+			free_irq(irq, &ds->key_state[i]);
+		}
+	}
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	for (i = di->keymap_size - 1; i >= 0; i--) {
+err_gpio_configure_failed:
+		gpio_free(di->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	wake_lock_destroy(&ds->wake_lock);
+	kfree(ds);
+err_ds_alloc_failed:
+	return ret;
+}
diff -Nur linux-2.6.35.7/drivers/input/misc/gpio_matrix.c tiny210/drivers/input/misc/gpio_matrix.c
--- linux-2.6.35.7/drivers/input/misc/gpio_matrix.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gpio_matrix.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,432 @@
+/* drivers/input/misc/gpio_matrix.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+
+struct gpio_kp {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_matrix_info *keypad_info;
+	struct hrtimer timer;
+	struct wake_lock wake_lock;
+	int current_output;
+	unsigned int use_irq:1;
+	unsigned int key_state_changed:1;
+	unsigned int last_key_state_changed:1;
+	unsigned int some_keys_pressed:2;
+	unsigned int disabled_irq:1;
+	unsigned long keys_pressed[0];
+};
+
+static void clear_phantom_key(struct gpio_kp *kp, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int key_index = out * mi->ninputs + in;
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (!test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+		__clear_bit(key_index, kp->keys_pressed);
+	} else {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"not cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+	}
+}
+
+static int restore_keys_for_input(struct gpio_kp *kp, int out, int in)
+{
+	int rv = 0;
+	int key_index;
+
+	key_index = out * kp->keypad_info->ninputs + in;
+	while (out < kp->keypad_info->noutputs) {
+		if (test_bit(key_index, kp->keys_pressed)) {
+			rv = 1;
+			clear_phantom_key(kp, out, in);
+		}
+		key_index += kp->keypad_info->ninputs;
+		out++;
+	}
+	return rv;
+}
+
+static void remove_phantom_keys(struct gpio_kp *kp)
+{
+	int out, in, inp;
+	int key_index;
+
+	if (kp->some_keys_pressed < 3)
+		return;
+
+	for (out = 0; out < kp->keypad_info->noutputs; out++) {
+		inp = -1;
+		key_index = out * kp->keypad_info->ninputs;
+		for (in = 0; in < kp->keypad_info->ninputs; in++, key_index++) {
+			if (test_bit(key_index, kp->keys_pressed)) {
+				if (inp == -1) {
+					inp = in;
+					continue;
+				}
+				if (inp >= 0) {
+					if (!restore_keys_for_input(kp, out + 1,
+									inp))
+						break;
+					clear_phantom_key(kp, out, inp);
+					inp = -2;
+				}
+				restore_keys_for_input(kp, out, in);
+			}
+		}
+	}
+}
+
+static void report_key(struct gpio_kp *kp, int key_index, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int pressed = test_bit(key_index, kp->keys_pressed);
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (keycode == KEY_RESERVED) {
+			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
+				pr_info("gpiomatrix: unmapped key, %d-%d "
+					"(%d-%d) changed to %d\n",
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+		} else {
+			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS)
+				pr_info("gpiomatrix: key %x, %d-%d (%d-%d) "
+					"changed to %d\n", keycode,
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+			input_report_key(kp->input_devs->dev[dev], keycode, pressed);
+		}
+	}
+}
+
+static enum hrtimer_restart gpio_keypad_timer_func(struct hrtimer *timer)
+{
+	int out, in;
+	int key_index;
+	int gpio;
+	struct gpio_kp *kp = container_of(timer, struct gpio_kp, timer);
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+	unsigned polarity = !!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH);
+
+	out = kp->current_output;
+	if (out == mi->noutputs) {
+		out = 0;
+		kp->last_key_state_changed = kp->key_state_changed;
+		kp->key_state_changed = 0;
+		kp->some_keys_pressed = 0;
+	} else {
+		key_index = out * mi->ninputs;
+		for (in = 0; in < mi->ninputs; in++, key_index++) {
+			gpio = mi->input_gpios[in];
+			if (gpio_get_value(gpio) ^ !polarity) {
+				if (kp->some_keys_pressed < 3)
+					kp->some_keys_pressed++;
+				kp->key_state_changed |= !__test_and_set_bit(
+						key_index, kp->keys_pressed);
+			} else
+				kp->key_state_changed |= __test_and_clear_bit(
+						key_index, kp->keys_pressed);
+		}
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, !polarity);
+		else
+			gpio_direction_input(gpio);
+		out++;
+	}
+	kp->current_output = out;
+	if (out < mi->noutputs) {
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, polarity);
+		else
+			gpio_direction_output(gpio, polarity);
+		hrtimer_start(timer, mi->settle_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+	if (gpio_keypad_flags & GPIOKPF_DEBOUNCE) {
+		if (kp->key_state_changed) {
+			hrtimer_start(&kp->timer, mi->debounce_delay,
+				      HRTIMER_MODE_REL);
+			return HRTIMER_NORESTART;
+		}
+		kp->key_state_changed = kp->last_key_state_changed;
+	}
+	if (kp->key_state_changed) {
+		if (gpio_keypad_flags & GPIOKPF_REMOVE_SOME_PHANTOM_KEYS)
+			remove_phantom_keys(kp);
+		key_index = 0;
+		for (out = 0; out < mi->noutputs; out++)
+			for (in = 0; in < mi->ninputs; in++, key_index++)
+				report_key(kp, key_index, out, in);
+	}
+	if (!kp->use_irq || kp->some_keys_pressed) {
+		hrtimer_start(timer, mi->poll_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+
+	/* No keys are pressed, reenable interrupt */
+	for (out = 0; out < mi->noutputs; out++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[out], polarity);
+		else
+			gpio_direction_output(mi->output_gpios[out], polarity);
+	}
+	for (in = 0; in < mi->ninputs; in++)
+		enable_irq(gpio_to_irq(mi->input_gpios[in]));
+	wake_unlock(&kp->wake_lock);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_keypad_irq_handler(int irq_in, void *dev_id)
+{
+	int i;
+	struct gpio_kp *kp = dev_id;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+
+	if (!kp->use_irq) {
+		/* ignore interrupt while registering the handler */
+		kp->disabled_irq = 1;
+		disable_irq_nosync(irq_in);
+		return IRQ_HANDLED;
+	}
+
+	for (i = 0; i < mi->ninputs; i++)
+		disable_irq_nosync(gpio_to_irq(mi->input_gpios[i]));
+	for (i = 0; i < mi->noutputs; i++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[i],
+				!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH));
+		else
+			gpio_direction_input(mi->output_gpios[i]);
+	}
+	wake_lock(&kp->wake_lock);
+	hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+	return IRQ_HANDLED;
+}
+
+static int gpio_keypad_request_irqs(struct gpio_kp *kp)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long request_flags;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+
+	switch (mi->flags & (GPIOKPF_ACTIVE_HIGH|GPIOKPF_LEVEL_TRIGGERED_IRQ)) {
+	default:
+		request_flags = IRQF_TRIGGER_FALLING;
+		break;
+	case GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_RISING;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ:
+		request_flags = IRQF_TRIGGER_LOW;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_HIGH;
+		break;
+	}
+
+	for (i = 0; i < mi->ninputs; i++) {
+		err = irq = gpio_to_irq(mi->input_gpios[i]);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_keypad_irq_handler, request_flags,
+				  "gpio_kp", kp);
+		if (err) {
+			pr_err("gpiomatrix: request_irq failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+			goto err_request_irq_failed;
+		}
+		err = set_irq_wake(irq, 1);
+		if (err) {
+			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+		}
+		disable_irq(irq);
+		if (kp->disabled_irq) {
+			kp->disabled_irq = 0;
+			enable_irq(irq);
+		}
+	}
+	return 0;
+
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+	struct gpio_event_info *info, void **data, int func)
+{
+	int i;
+	int err;
+	int key_count;
+	struct gpio_kp *kp;
+	struct gpio_event_matrix_info *mi;
+
+	mi = container_of(info, struct gpio_event_matrix_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME) {
+		/* TODO: disable scanning */
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (mi->keymap == NULL ||
+		   mi->input_gpios == NULL ||
+		   mi->output_gpios == NULL) {
+			err = -ENODEV;
+			pr_err("gpiomatrix: Incomplete pdata\n");
+			goto err_invalid_platform_data;
+		}
+		key_count = mi->ninputs * mi->noutputs;
+
+		*data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
+				     BITS_TO_LONGS(key_count), GFP_KERNEL);
+		if (kp == NULL) {
+			err = -ENOMEM;
+			pr_err("gpiomatrix: Failed to allocate private data\n");
+			goto err_kp_alloc_failed;
+		}
+		kp->input_devs = input_devs;
+		kp->keypad_info = mi;
+		for (i = 0; i < key_count; i++) {
+			unsigned short keyentry = mi->keymap[i];
+			unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+			unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+			if (dev >= input_devs->count) {
+				pr_err("gpiomatrix: bad device index %d >= "
+					"%d for key code %d\n",
+					dev, input_devs->count, keycode);
+				err = -EINVAL;
+				goto err_bad_keymap;
+			}
+			if (keycode && keycode <= KEY_MAX)
+				input_set_capability(input_devs->dev[dev],
+							EV_KEY, keycode);
+		}
+
+		for (i = 0; i < mi->noutputs; i++) {
+			err = gpio_request(mi->output_gpios[i], "gpio_kp_out");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_request_output_gpio_failed;
+			}
+			if (gpio_cansleep(mi->output_gpios[i])) {
+				pr_err("gpiomatrix: unsupported output gpio %d,"
+					" can sleep\n", mi->output_gpios[i]);
+				err = -EINVAL;
+				goto err_output_gpio_configure_failed;
+			}
+			if (mi->flags & GPIOKPF_DRIVE_INACTIVE)
+				err = gpio_direction_output(mi->output_gpios[i],
+					!(mi->flags & GPIOKPF_ACTIVE_HIGH));
+			else
+				err = gpio_direction_input(mi->output_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_configure failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_output_gpio_configure_failed;
+			}
+		}
+		for (i = 0; i < mi->ninputs; i++) {
+			err = gpio_request(mi->input_gpios[i], "gpio_kp_in");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"input %d\n", mi->input_gpios[i]);
+				goto err_request_input_gpio_failed;
+			}
+			err = gpio_direction_input(mi->input_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_direction_input failed"
+					" for input %d\n", mi->input_gpios[i]);
+				goto err_gpio_direction_input_failed;
+			}
+		}
+		kp->current_output = mi->noutputs;
+		kp->key_state_changed = 1;
+
+		hrtimer_init(&kp->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		kp->timer.function = gpio_keypad_timer_func;
+		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
+		err = gpio_keypad_request_irqs(kp);
+		kp->use_irq = err == 0;
+
+		pr_info("GPIO Matrix Keypad Driver: Start keypad matrix for "
+			"%s%s in %s mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			kp->use_irq ? "interrupt" : "polling");
+
+		if (kp->use_irq)
+			wake_lock(&kp->wake_lock);
+		hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+		return 0;
+	}
+
+	err = 0;
+	kp = *data;
+
+	if (kp->use_irq)
+		for (i = mi->noutputs - 1; i >= 0; i--)
+			free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+
+	hrtimer_cancel(&kp->timer);
+	wake_lock_destroy(&kp->wake_lock);
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_gpio_direction_input_failed:
+		gpio_free(mi->input_gpios[i]);
+err_request_input_gpio_failed:
+		;
+	}
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_output_gpio_configure_failed:
+		gpio_free(mi->output_gpios[i]);
+err_request_output_gpio_failed:
+		;
+	}
+err_bad_keymap:
+	kfree(kp);
+err_kp_alloc_failed:
+err_invalid_platform_data:
+	return err;
+}
diff -Nur linux-2.6.35.7/drivers/input/misc/gpio_output.c tiny210/drivers/input/misc/gpio_output.c
--- linux-2.6.35.7/drivers/input/misc/gpio_output.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/gpio_output.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,97 @@
+/* drivers/input/misc/gpio_output.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+
+int gpio_event_output_event(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, unsigned int dev, unsigned int type,
+	unsigned int code, int value)
+{
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+	if (type != oi->type)
+		return 0;
+	if (!(oi->flags & GPIOEDF_ACTIVE_HIGH))
+		value = !value;
+	for (i = 0; i < oi->keymap_size; i++)
+		if (dev == oi->keymap[i].dev && code == oi->keymap[i].code)
+			gpio_set_value(oi->keymap[i].gpio, value);
+	return 0;
+}
+
+int gpio_event_output_func(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, int func)
+{
+	int ret;
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME)
+		return 0;
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		int output_level = !(oi->flags & GPIOEDF_ACTIVE_HIGH);
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			int dev = oi->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_output_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					oi->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], oi->type,
+					     oi->keymap[i].code);
+		}
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			ret = gpio_request(oi->keymap[i].gpio,
+					   "gpio_event_output");
+			if (ret) {
+				pr_err("gpio_event_output_func: gpio_request "
+					"failed for %d\n", oi->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_output(oi->keymap[i].gpio,
+						    output_level);
+			if (ret) {
+				pr_err("gpio_event_output_func: "
+					"gpio_direction_output failed for %d\n",
+					oi->keymap[i].gpio);
+				goto err_gpio_direction_output_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	for (i = oi->keymap_size - 1; i >= 0; i--) {
+err_gpio_direction_output_failed:
+		gpio_free(oi->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	return ret;
+}
+
diff -Nur linux-2.6.35.7/drivers/input/misc/k3g.c tiny210/drivers/input/misc/k3g.c
--- linux-2.6.35.7/drivers/input/misc/k3g.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/k3g.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,704 @@
+/*
+ *  Copyright (C) 2010, Samsung Electronics Co. Ltd. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <asm/div64.h>
+#include <linux/input/k3g.h>
+#include <linux/delay.h>
+
+/* k3g chip id */
+#define DEVICE_ID	0xD3
+/* k3g gyroscope registers */
+#define WHO_AM_I	0x0F
+#define CTRL_REG1	0x20  /* power control reg */
+#define CTRL_REG2	0x21  /* power control reg */
+#define CTRL_REG3	0x22  /* power control reg */
+#define CTRL_REG4	0x23  /* interrupt control reg */
+#define CTRL_REG5	0x24  /* interrupt control reg */
+#define OUT_TEMP	0x26  /* Temperature data */
+#define STATUS_REG	0x27
+#define AXISDATA_REG	0x28
+#define OUT_Y_L		0x2A
+#define FIFO_CTRL_REG	0x2E
+#define FIFO_SRC_REG	0x2F
+#define PM_OFF		0x00
+#define PM_NORMAL	0x08
+#define ENABLE_ALL_AXES	0x07
+#define BYPASS_MODE	0x00
+#define FIFO_MODE	0x20
+
+#define FIFO_EMPTY	0x20
+#define FSS_MASK	0x1F
+#define ODR_MASK	0xF0
+#define ODR105_BW12_5	0x00  /* ODR = 105Hz; BW = 12.5Hz */
+#define ODR105_BW25	0x10  /* ODR = 105Hz; BW = 25Hz   */
+#define ODR210_BW12_5	0x40  /* ODR = 210Hz; BW = 12.5Hz */
+#define ODR210_BW25	0x50  /* ODR = 210Hz; BW = 25Hz   */
+#define ODR210_BW50	0x60  /* ODR = 210Hz; BW = 50Hz   */
+#define ODR210_BW70	0x70  /* ODR = 210Hz; BW = 70Hz   */
+#define ODR420_BW20	0x80  /* ODR = 420Hz; BW = 20Hz   */
+#define ODR420_BW25	0x90  /* ODR = 420Hz; BW = 25Hz   */
+#define ODR420_BW50	0xA0  /* ODR = 420Hz; BW = 50Hz   */
+#define ODR420_BW110	0xB0  /* ODR = 420Hz; BW = 110Hz  */
+#define ODR840_BW30	0xC0  /* ODR = 840Hz; BW = 30Hz   */
+#define ODR840_BW35	0xD0  /* ODR = 840Hz; BW = 35Hz   */
+#define ODR840_BW50	0xE0  /* ODR = 840Hz; BW = 50Hz   */
+#define ODR840_BW110	0xF0  /* ODR = 840Hz; BW = 110Hz  */
+
+#define MIN_ST		175
+#define MAX_ST		875
+#define AC		(1 << 7) /* register auto-increment bit */
+#define MAX_ENTRY	1
+#define MAX_DELAY	(MAX_ENTRY * 9523809LL)
+
+/* default register setting for device init */
+static const char default_ctrl_regs[] = {
+	0x3F,	/* 105HZ, PM-normal, xyz enable */
+	0x00,	/* normal mode */
+	0x04,	/* fifo wtm interrupt on */
+	0xA0,	/* block data update, 2000d/s */
+	0x40,	/* fifo enable */
+};
+
+static const struct odr_delay {
+	u8 odr; /* odr reg setting */
+	u32 delay_ns; /* odr in ns */
+} odr_delay_table[] = {
+	{  ODR840_BW110, 1190476LL }, /* 840Hz */
+	{  ODR420_BW110, 2380952LL }, /* 420Hz */
+	{   ODR210_BW70, 4761904LL }, /* 210Hz */
+	{   ODR105_BW25, 9523809LL }, /* 105Hz */
+};
+
+/*
+ * K3G gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * signed short
+ */
+struct k3g_t {
+	s16 x;
+	s16 y;
+	s16 z;
+};
+
+struct k3g_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct mutex lock;
+	struct workqueue_struct *k3g_wq;
+	struct work_struct work;
+	struct hrtimer timer;
+	bool enable;
+	bool drop_next_event;
+	bool interruptible;	/* interrupt or polling? */
+	int entries;		/* number of fifo entries */
+	u8 ctrl_regs[5];	/* saving register settings */
+	u32 time_to_read;	/* time needed to read one entry */
+	ktime_t polling_delay;	/* polling time for timer */
+};
+
+static int k3g_read_fifo_status(struct k3g_data *k3g_data)
+{
+	int fifo_status;
+
+	fifo_status = i2c_smbus_read_byte_data(k3g_data->client, FIFO_SRC_REG);
+	if (fifo_status < 0) {
+		pr_err("%s: failed to read fifo source register\n",
+							__func__);
+		return fifo_status;
+	}
+	return (fifo_status & FSS_MASK) + !(fifo_status & FIFO_EMPTY);
+}
+
+static int k3g_restart_fifo(struct k3g_data *k3g_data)
+{
+	int res = 0;
+
+	res = i2c_smbus_write_byte_data(k3g_data->client,
+			FIFO_CTRL_REG, BYPASS_MODE);
+	if (res < 0) {
+		pr_err("%s : failed to set bypass_mode\n", __func__);
+		return res;
+	}
+
+	res = i2c_smbus_write_byte_data(k3g_data->client,
+			FIFO_CTRL_REG, FIFO_MODE | (k3g_data->entries - 1));
+
+	if (res < 0)
+		pr_err("%s : failed to set fifo_mode\n", __func__);
+
+	return res;
+}
+
+static void set_polling_delay(struct k3g_data *k3g_data, int res)
+{
+	s64 delay_ns;
+
+	delay_ns = k3g_data->entries + 1 - res;
+	if (delay_ns < 0)
+		delay_ns = 0;
+
+	delay_ns = delay_ns * k3g_data->time_to_read;
+	k3g_data->polling_delay = ns_to_ktime(delay_ns);
+}
+
+/* gyroscope data readout */
+static int k3g_read_gyro_values(struct i2c_client *client,
+				struct k3g_t *data, int total_read)
+{
+	int err;
+	struct i2c_msg msg[2];
+	u8 reg_buf;
+	u8 gyro_data[sizeof(*data) * (total_read ? (total_read - 1) : 1)];
+
+	msg[0].addr = client->addr;
+	msg[0].buf = &reg_buf;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = gyro_data;
+
+	if (total_read > 1) {
+		reg_buf = AXISDATA_REG | AC;
+		msg[1].len = sizeof(gyro_data);
+
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			return (err < 0) ? err : -EIO;
+	}
+
+	reg_buf = AXISDATA_REG;
+	msg[1].len = 1;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2)
+		return (err < 0) ? err : -EIO;
+
+	reg_buf = OUT_Y_L | AC;
+	msg[1].len = sizeof(*data);
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2)
+		return (err < 0) ? err : -EIO;
+
+	data->y = (gyro_data[1] << 8) | gyro_data[0];
+	data->z = (gyro_data[3] << 8) | gyro_data[2];
+	data->x = (gyro_data[5] << 8) | gyro_data[4];
+
+	return 0;
+}
+
+static int k3g_report_gyro_values(struct k3g_data *k3g_data)
+{
+	int res;
+	struct k3g_t data;
+
+	res = k3g_read_gyro_values(k3g_data->client, &data,
+				k3g_data->entries + k3g_data->drop_next_event);
+	if (res < 0)
+		return res;
+
+	res = k3g_read_fifo_status(k3g_data);
+
+	k3g_data->drop_next_event = !res;
+
+	if (res >= 31 - k3g_data->entries) {
+		/* reset fifo to start again - data isn't trustworthy,
+		 * our locked read might not have worked and we
+		 * could have done i2c read in mid register update
+		 */
+		return k3g_restart_fifo(k3g_data);
+	}
+
+	input_report_rel(k3g_data->input_dev, REL_RX, data.x);
+	input_report_rel(k3g_data->input_dev, REL_RY, data.y);
+	input_report_rel(k3g_data->input_dev, REL_RZ, data.z);
+	input_sync(k3g_data->input_dev);
+
+	return res;
+}
+
+static enum hrtimer_restart k3g_timer_func(struct hrtimer *timer)
+{
+	struct k3g_data *k3g_data = container_of(timer, struct k3g_data, timer);
+	queue_work(k3g_data->k3g_wq, &k3g_data->work);
+	return HRTIMER_NORESTART;
+}
+
+static void k3g_work_func(struct work_struct *work)
+{
+	int res;
+	struct k3g_data *k3g_data = container_of(work, struct k3g_data, work);
+
+	do {
+		res = k3g_read_fifo_status(k3g_data);
+		if (res < 0)
+			return;
+
+		if (res < k3g_data->entries) {
+			pr_warn("%s: fifo entries are less than we want\n",
+								__func__);
+			goto timer_set;
+		}
+
+		res = k3g_report_gyro_values(k3g_data);
+		if (res < 0)
+			return;
+timer_set:
+		set_polling_delay(k3g_data, res);
+
+	} while (!ktime_to_ns(k3g_data->polling_delay));
+
+	hrtimer_start(&k3g_data->timer,
+		k3g_data->polling_delay, HRTIMER_MODE_REL);
+}
+
+static irqreturn_t k3g_interrupt_thread(int irq, void *k3g_data_p)
+{
+	int res;
+	struct k3g_data *k3g_data = k3g_data_p;
+	res = k3g_report_gyro_values(k3g_data);
+	if (res < 0)
+		pr_err("%s: failed to report gyro values\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t k3g_show_enable(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct k3g_data *k3g_data  = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", k3g_data->enable);
+}
+
+static ssize_t k3g_set_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0;
+	struct k3g_data *k3g_data  = dev_get_drvdata(dev);
+	bool new_enable;
+
+	if (sysfs_streq(buf, "1"))
+		new_enable = true;
+	else if (sysfs_streq(buf, "0"))
+		new_enable = false;
+	else {
+		pr_debug("%s: invalid value %d\n", __func__, *buf);
+		return -EINVAL;
+	}
+
+	if (new_enable == k3g_data->enable)
+		return size;
+
+	mutex_lock(&k3g_data->lock);
+	if (new_enable) {
+		/* turning on */
+		err = i2c_smbus_write_i2c_block_data(k3g_data->client,
+			CTRL_REG1 | AC, sizeof(k3g_data->ctrl_regs),
+						k3g_data->ctrl_regs);
+		if (err < 0) {
+			err = -EIO;
+			goto unlock;
+		}
+
+		/* reset fifo entries */
+		err = k3g_restart_fifo(k3g_data);
+		if (err < 0) {
+			err = -EIO;
+			goto turn_off;
+		}
+
+		if (k3g_data->interruptible)
+			enable_irq(k3g_data->client->irq);
+		else {
+			set_polling_delay(k3g_data, 0);
+			hrtimer_start(&k3g_data->timer,
+				k3g_data->polling_delay, HRTIMER_MODE_REL);
+		}
+	} else {
+		if (k3g_data->interruptible)
+			disable_irq(k3g_data->client->irq);
+		else {
+			hrtimer_cancel(&k3g_data->timer);
+			cancel_work_sync(&k3g_data->work);
+		}
+		/* turning off */
+		err = i2c_smbus_write_byte_data(k3g_data->client,
+						CTRL_REG1, 0x00);
+		if (err < 0)
+			goto unlock;
+	}
+	k3g_data->enable = new_enable;
+
+turn_off:
+	if (err < 0)
+		i2c_smbus_write_byte_data(k3g_data->client,
+						CTRL_REG1, 0x00);
+unlock:
+	mutex_unlock(&k3g_data->lock);
+
+	return err ? err : size;
+}
+
+static ssize_t k3g_show_delay(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct k3g_data *k3g_data  = dev_get_drvdata(dev);
+	u64 delay;
+
+	delay = k3g_data->time_to_read * k3g_data->entries;
+	delay = ktime_to_ns(ns_to_ktime(delay));
+
+	return sprintf(buf, "%lld\n", delay);
+}
+
+static ssize_t k3g_set_delay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct k3g_data *k3g_data  = dev_get_drvdata(dev);
+	int odr_value = ODR105_BW25;
+	int res = 0;
+	int i;
+	u64 delay_ns;
+	u8 ctrl;
+
+	res = strict_strtoll(buf, 10, &delay_ns);
+	if (res < 0)
+		return res;
+
+	mutex_lock(&k3g_data->lock);
+	if (!k3g_data->interruptible)
+		hrtimer_cancel(&k3g_data->timer);
+	else
+		disable_irq(k3g_data->client->irq);
+
+	/* round to the nearest supported ODR that is less than
+	 * the requested value
+	 */
+	for (i = 0; i < ARRAY_SIZE(odr_delay_table); i++)
+		if (delay_ns <= odr_delay_table[i].delay_ns) {
+			odr_value = odr_delay_table[i].odr;
+			delay_ns = odr_delay_table[i].delay_ns;
+			k3g_data->time_to_read = delay_ns;
+			k3g_data->entries = 1;
+			break;
+		}
+
+	if (delay_ns >= odr_delay_table[3].delay_ns) {
+		if (delay_ns >= MAX_DELAY) {
+			k3g_data->entries = MAX_ENTRY;
+			delay_ns = MAX_DELAY;
+		} else {
+			do_div(delay_ns, odr_delay_table[3].delay_ns);
+			k3g_data->entries = delay_ns;
+		}
+		k3g_data->time_to_read = odr_delay_table[3].delay_ns;
+	}
+
+	if (odr_value != (k3g_data->ctrl_regs[0] & ODR_MASK)) {
+		ctrl = (k3g_data->ctrl_regs[0] & ~ODR_MASK);
+		ctrl |= odr_value;
+		k3g_data->ctrl_regs[0] = ctrl;
+		res = i2c_smbus_write_byte_data(k3g_data->client,
+						CTRL_REG1, ctrl);
+	}
+
+	/* we see a noise in the first sample or two after we
+	 * change rates.  this delay helps eliminate that noise.
+	 */
+	msleep((u32)delay_ns * 2 / NSEC_PER_MSEC);
+
+	/* (re)start fifo */
+	k3g_restart_fifo(k3g_data);
+
+	if (!k3g_data->interruptible) {
+		delay_ns = k3g_data->entries * k3g_data->time_to_read;
+		k3g_data->polling_delay = ns_to_ktime(delay_ns);
+		if (k3g_data->enable)
+			hrtimer_start(&k3g_data->timer,
+				k3g_data->polling_delay, HRTIMER_MODE_REL);
+	} else
+		enable_irq(k3g_data->client->irq);
+
+	mutex_unlock(&k3g_data->lock);
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
+			k3g_show_enable, k3g_set_enable);
+static DEVICE_ATTR(poll_delay, S_IRUGO | S_IWUSR | S_IWGRP,
+			k3g_show_delay, k3g_set_delay);
+
+static int k3g_probe(struct i2c_client *client,
+			       const struct i2c_device_id *devid)
+{
+	int ret;
+	int err = 0;
+	struct k3g_data *data;
+	struct input_dev *input_dev;
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit;
+	}
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	data->client = client;
+
+	/* read chip id */
+	ret = i2c_smbus_read_byte_data(client, WHO_AM_I);
+	if (ret != DEVICE_ID) {
+		if (ret < 0) {
+			pr_err("%s: i2c for reading chip id failed\n",
+								__func__);
+			err = ret;
+		} else {
+			pr_err("%s : Device identification failed\n",
+								__func__);
+			err = -ENODEV;
+		}
+		goto err_read_reg;
+	}
+
+	mutex_init(&data->lock);
+
+	/* allocate gyro input_device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("%s: could not allocate input device\n", __func__);
+		err = -ENOMEM;
+		goto err_input_allocate_device;
+	}
+
+	data->input_dev = input_dev;
+	input_set_drvdata(input_dev, data);
+	input_dev->name = "gyro";
+	/* X */
+	input_set_capability(input_dev, EV_REL, REL_RX);
+	input_set_abs_params(input_dev, REL_RX, -2048, 2047, 0, 0);
+	/* Y */
+	input_set_capability(input_dev, EV_REL, REL_RY);
+	input_set_abs_params(input_dev, REL_RY, -2048, 2047, 0, 0);
+	/* Z */
+	input_set_capability(input_dev, EV_REL, REL_RZ);
+	input_set_abs_params(input_dev, REL_RZ, -2048, 2047, 0, 0);
+
+	err = input_register_device(input_dev);
+	if (err < 0) {
+		pr_err("%s: could not register input device\n", __func__);
+		input_free_device(data->input_dev);
+		goto err_input_register_device;
+	}
+
+	memcpy(&data->ctrl_regs, &default_ctrl_regs, sizeof(default_ctrl_regs));
+
+	if (data->client->irq >= 0) { /* interrupt */
+		data->interruptible = true;
+		err = request_threaded_irq(data->client->irq, NULL,
+			k3g_interrupt_thread, IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+				"k3g", data);
+		if (err < 0) {
+			pr_err("%s: can't allocate irq.\n", __func__);
+			goto err_request_irq;
+		}
+		disable_irq(data->client->irq);
+
+	} else { /* polling */
+		u64 delay_ns;
+		data->ctrl_regs[2] = 0x00; /* disable interrupt */
+		/* hrtimer settings.  we poll for gyro values using a timer. */
+		hrtimer_init(&data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		data->polling_delay = ns_to_ktime(200 * NSEC_PER_MSEC);
+		data->time_to_read = 10000000LL;
+		delay_ns = ktime_to_ns(data->polling_delay);
+		do_div(delay_ns, data->time_to_read);
+		data->entries = delay_ns;
+		data->timer.function = k3g_timer_func;
+
+		/* the timer just fires off a work queue request.
+		   We need a thread to read i2c (can be slow and blocking). */
+		data->k3g_wq = create_singlethread_workqueue("k3g_wq");
+		if (!data->k3g_wq) {
+			err = -ENOMEM;
+			pr_err("%s: could not create workqueue\n", __func__);
+			goto err_create_workqueue;
+		}
+		/* this is the thread function we run on the work queue */
+		INIT_WORK(&data->work, k3g_work_func);
+	}
+
+	if (device_create_file(&input_dev->dev,
+				&dev_attr_enable) < 0) {
+		pr_err("Failed to create device file(%s)!\n",
+				dev_attr_enable.attr.name);
+		goto err_device_create_file;
+	}
+
+	if (device_create_file(&input_dev->dev,
+				&dev_attr_poll_delay) < 0) {
+		pr_err("Failed to create device file(%s)!\n",
+				dev_attr_poll_delay.attr.name);
+		goto err_device_create_file2;
+	}
+
+	i2c_set_clientdata(client, data);
+	dev_set_drvdata(&input_dev->dev, data);
+
+	return 0;
+
+err_device_create_file2:
+	device_remove_file(&input_dev->dev, &dev_attr_enable);
+err_device_create_file:
+	if (data->interruptible) {
+		enable_irq(data->client->irq);
+		free_irq(data->client->irq, data);
+	} else
+		destroy_workqueue(data->k3g_wq);
+	input_unregister_device(data->input_dev);
+err_create_workqueue:
+err_request_irq:
+err_input_register_device:
+err_input_allocate_device:
+	mutex_destroy(&data->lock);
+err_read_reg:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int k3g_remove(struct i2c_client *client)
+{
+	int err = 0;
+	struct k3g_data *k3g_data = i2c_get_clientdata(client);
+
+	device_remove_file(&k3g_data->input_dev->dev, &dev_attr_enable);
+	device_remove_file(&k3g_data->input_dev->dev, &dev_attr_poll_delay);
+
+	if (k3g_data->enable)
+		err = i2c_smbus_write_byte_data(k3g_data->client,
+					CTRL_REG1, 0x00);
+	if (k3g_data->interruptible) {
+		if (!k3g_data->enable) /* no disable_irq before free_irq */
+			enable_irq(k3g_data->client->irq);
+		free_irq(k3g_data->client->irq, k3g_data);
+
+	} else {
+		hrtimer_cancel(&k3g_data->timer);
+		cancel_work_sync(&k3g_data->work);
+		destroy_workqueue(k3g_data->k3g_wq);
+	}
+
+	input_unregister_device(k3g_data->input_dev);
+	mutex_destroy(&k3g_data->lock);
+	kfree(k3g_data);
+
+	return err;
+}
+
+static int k3g_suspend(struct device *dev)
+{
+	int err = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct k3g_data *k3g_data = i2c_get_clientdata(client);
+
+	if (k3g_data->enable) {
+		mutex_lock(&k3g_data->lock);
+		if (!k3g_data->interruptible) {
+			hrtimer_cancel(&k3g_data->timer);
+			cancel_work_sync(&k3g_data->work);
+		}
+		err = i2c_smbus_write_byte_data(k3g_data->client,
+						CTRL_REG1, 0x00);
+		mutex_unlock(&k3g_data->lock);
+	}
+
+	return err;
+}
+
+static int k3g_resume(struct device *dev)
+{
+	int err = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct k3g_data *k3g_data = i2c_get_clientdata(client);
+
+	if (k3g_data->enable) {
+		mutex_lock(&k3g_data->lock);
+		if (!k3g_data->interruptible)
+			hrtimer_start(&k3g_data->timer,
+				k3g_data->polling_delay, HRTIMER_MODE_REL);
+		err = i2c_smbus_write_i2c_block_data(client,
+				CTRL_REG1 | AC, sizeof(k3g_data->ctrl_regs),
+							k3g_data->ctrl_regs);
+		mutex_unlock(&k3g_data->lock);
+	}
+
+	return err;
+}
+
+static const struct dev_pm_ops k3g_pm_ops = {
+	.suspend = k3g_suspend,
+	.resume = k3g_resume
+};
+
+static const struct i2c_device_id k3g_id[] = {
+	{ "k3g", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, k3g_id);
+
+static struct i2c_driver k3g_driver = {
+	.probe = k3g_probe,
+	.remove = __devexit_p(k3g_remove),
+	.id_table = k3g_id,
+	.driver = {
+		.pm = &k3g_pm_ops,
+		.owner = THIS_MODULE,
+		.name = "k3g"
+	},
+};
+
+static int __init k3g_init(void)
+{
+	return i2c_add_driver(&k3g_driver);
+}
+
+static void __exit k3g_exit(void)
+{
+	i2c_del_driver(&k3g_driver);
+}
+
+module_init(k3g_init);
+module_exit(k3g_exit);
+
+MODULE_DESCRIPTION("k3g digital gyroscope driver");
+MODULE_AUTHOR("Tim SK Lee Samsung Electronics <tim.sk.lee@samsung.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/input/misc/Kconfig tiny210/drivers/input/misc/Kconfig
--- linux-2.6.35.7/drivers/input/misc/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/misc/Kconfig	2011-08-08 12:52:34.000000000 +0800
@@ -12,6 +12,12 @@
 
 if INPUT_MISC
 
+config GYRO_K3G
+	tristate "K3G driver for s5pc11x"
+	default n
+	help
+	  This option enables gyro sensors using K3G driver
+
 config INPUT_88PM860X_ONKEY
 	tristate "88PM860x ONKEY support"
 	depends on MFD_88PM860X
@@ -183,6 +189,17 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -302,6 +319,11 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called winbond_cir.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
@@ -406,4 +428,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called gpio-buttons.
 
+config OPTICAL_GP2A
+	depends on I2C && GENERIC_GPIO
+	tristate "GP2A ambient light and proximity input device"
+	default n
+	help
+	  This option enables proximity & light sensors using gp2a driver.
+
 endif
diff -Nur linux-2.6.35.7/drivers/input/misc/keychord.c tiny210/drivers/input/misc/keychord.c
--- linux-2.6.35.7/drivers/input/misc/keychord.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/misc/keychord.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,387 @@
+/*
+ *  drivers/input/misc/keychord.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/keychord.h>
+#include <linux/sched.h>
+
+#define KEYCHORD_NAME		"keychord"
+#define BUFFER_SIZE			16
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Key chord input driver");
+MODULE_SUPPORTED_DEVICE("keychord");
+MODULE_LICENSE("GPL");
+
+#define NEXT_KEYCHORD(kc) ((struct input_keychord *) \
+		((char *)kc + sizeof(struct input_keychord) + \
+		kc->count * sizeof(kc->keycodes[0])))
+
+struct keychord_device {
+	struct input_handler	input_handler;
+	int			registered;
+
+	/* list of keychords to monitor */
+	struct input_keychord	*keychords;
+	int			keychord_count;
+
+	/* bitmask of keys contained in our keychords */
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	/* current state of the keys */
+	unsigned long keystate[BITS_TO_LONGS(KEY_CNT)];
+	/* number of keys that are currently pressed */
+	int key_down;
+
+	/* second input_device_id is needed for null termination */
+	struct input_device_id  device_ids[2];
+
+	spinlock_t		lock;
+	wait_queue_head_t	waitq;
+	unsigned char		head;
+	unsigned char		tail;
+	__u16			buff[BUFFER_SIZE];
+};
+
+static int check_keychord(struct keychord_device *kdev,
+		struct input_keychord *keychord)
+{
+	int i;
+
+	if (keychord->count != kdev->key_down)
+		return 0;
+
+	for (i = 0; i < keychord->count; i++) {
+		if (!test_bit(keychord->keycodes[i], kdev->keystate))
+			return 0;
+	}
+
+	/* we have a match */
+	return 1;
+}
+
+static void keychord_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	struct keychord_device *kdev = handle->private;
+	struct input_keychord *keychord;
+	unsigned long flags;
+	int i, got_chord = 0;
+
+	if (type != EV_KEY || code >= KEY_MAX)
+		return;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* do nothing if key state did not change */
+	if (!test_bit(code, kdev->keystate) == !value)
+		goto done;
+	__change_bit(code, kdev->keystate);
+	if (value)
+		kdev->key_down++;
+	else
+		kdev->key_down--;
+
+	/* don't notify on key up */
+	if (!value)
+		goto done;
+	/* ignore this event if it is not one of the keys we are monitoring */
+	if (!test_bit(code, kdev->keybit))
+		goto done;
+
+	keychord = kdev->keychords;
+	if (!keychord)
+		goto done;
+
+	/* check to see if the keyboard state matches any keychords */
+	for (i = 0; i < kdev->keychord_count; i++) {
+		if (check_keychord(kdev, keychord)) {
+			kdev->buff[kdev->head] = keychord->id;
+			kdev->head = (kdev->head + 1) % BUFFER_SIZE;
+			got_chord = 1;
+			break;
+		}
+		/* skip to next keychord */
+		keychord = NEXT_KEYCHORD(keychord);
+	}
+
+done:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (got_chord)
+		wake_up_interruptible(&kdev->waitq);
+}
+
+static int keychord_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i, ret;
+	struct input_handle *handle;
+	struct keychord_device *kdev =
+		container_of(handler, struct keychord_device, input_handler);
+
+	/*
+	 * ignore this input device if it does not contain any keycodes
+	 * that we are monitoring
+	 */
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, kdev->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = KEYCHORD_NAME;
+	handle->private = kdev;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("keychord: using input dev %s for fevent\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keychord_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+/*
+ * keychord_read is used to read keychord events from the driver
+ */
+static ssize_t keychord_read(struct file *file, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	__u16   id;
+	int retval;
+	unsigned long flags;
+
+	if (count < sizeof(id))
+		return -EINVAL;
+	count = sizeof(id);
+
+	if (kdev->head == kdev->tail && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+
+	retval = wait_event_interruptible(kdev->waitq,
+			kdev->head != kdev->tail);
+	if (retval)
+		return retval;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* pop a keychord ID off the queue */
+	id = kdev->buff[kdev->tail];
+	kdev->tail = (kdev->tail + 1) % BUFFER_SIZE;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (copy_to_user(buffer, &id, count))
+		return -EFAULT;
+
+	return count;
+}
+
+/*
+ * keychord_write is used to configure the driver
+ */
+static ssize_t keychord_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	struct input_keychord *keychords = 0;
+	struct input_keychord *keychord, *next, *end;
+	int ret, i, key;
+	unsigned long flags;
+
+	if (count < sizeof(struct input_keychord))
+		return -EINVAL;
+	keychords = kzalloc(count, GFP_KERNEL);
+	if (!keychords)
+		return -ENOMEM;
+
+	/* read list of keychords from userspace */
+	if (copy_from_user(keychords, buffer, count)) {
+		kfree(keychords);
+		return -EFAULT;
+	}
+
+	/* unregister handler before changing configuration */
+	if (kdev->registered) {
+		input_unregister_handler(&kdev->input_handler);
+		kdev->registered = 0;
+	}
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* clear any existing configuration */
+	kfree(kdev->keychords);
+	kdev->keychords = 0;
+	kdev->keychord_count = 0;
+	kdev->key_down = 0;
+	memset(kdev->keybit, 0, sizeof(kdev->keybit));
+	memset(kdev->keystate, 0, sizeof(kdev->keystate));
+	kdev->head = kdev->tail = 0;
+
+	keychord = keychords;
+	end = (struct input_keychord *)((char *)keychord + count);
+
+	while (keychord < end) {
+		next = NEXT_KEYCHORD(keychord);
+		if (keychord->count <= 0 || next > end) {
+			pr_err("keychord: invalid keycode count %d\n",
+				keychord->count);
+			goto err_unlock_return;
+		}
+		if (keychord->version != KEYCHORD_VERSION) {
+			pr_err("keychord: unsupported version %d\n",
+				keychord->version);
+			goto err_unlock_return;
+		}
+
+		/* keep track of the keys we are monitoring in keybit */
+		for (i = 0; i < keychord->count; i++) {
+			key = keychord->keycodes[i];
+			if (key < 0 || key >= KEY_CNT) {
+				pr_err("keychord: keycode %d out of range\n",
+					key);
+				goto err_unlock_return;
+			}
+			__set_bit(key, kdev->keybit);
+		}
+
+		kdev->keychord_count++;
+		keychord = next;
+	}
+
+	kdev->keychords = keychords;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	ret = input_register_handler(&kdev->input_handler);
+	if (ret) {
+		kfree(keychords);
+		kdev->keychords = 0;
+		return ret;
+	}
+	kdev->registered = 1;
+
+	return count;
+
+err_unlock_return:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+	kfree(keychords);
+	return -EINVAL;
+}
+
+static unsigned int keychord_poll(struct file *file, poll_table *wait)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	poll_wait(file, &kdev->waitq, wait);
+
+	if (kdev->head != kdev->tail)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int keychord_open(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev;
+
+	kdev = kzalloc(sizeof(struct keychord_device), GFP_KERNEL);
+	if (!kdev)
+		return -ENOMEM;
+
+	spin_lock_init(&kdev->lock);
+	init_waitqueue_head(&kdev->waitq);
+
+	kdev->input_handler.event = keychord_event;
+	kdev->input_handler.connect = keychord_connect;
+	kdev->input_handler.disconnect = keychord_disconnect;
+	kdev->input_handler.name = KEYCHORD_NAME;
+	kdev->input_handler.id_table = kdev->device_ids;
+
+	kdev->device_ids[0].flags = INPUT_DEVICE_ID_MATCH_EVBIT;
+	__set_bit(EV_KEY, kdev->device_ids[0].evbit);
+
+	file->private_data = kdev;
+
+	return 0;
+}
+
+static int keychord_release(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	if (kdev->registered)
+		input_unregister_handler(&kdev->input_handler);
+	kfree(kdev);
+
+	return 0;
+}
+
+static const struct file_operations keychord_fops = {
+	.owner		= THIS_MODULE,
+	.open		= keychord_open,
+	.release	= keychord_release,
+	.read		= keychord_read,
+	.write		= keychord_write,
+	.poll		= keychord_poll,
+};
+
+static struct miscdevice keychord_misc = {
+	.fops		= &keychord_fops,
+	.name		= KEYCHORD_NAME,
+	.minor		= MISC_DYNAMIC_MINOR,
+};
+
+static int __init keychord_init(void)
+{
+	return misc_register(&keychord_misc);
+}
+
+static void __exit keychord_exit(void)
+{
+	misc_deregister(&keychord_misc);
+}
+
+module_init(keychord_init);
+module_exit(keychord_exit);
diff -Nur linux-2.6.35.7/drivers/input/misc/Makefile tiny210/drivers/input/misc/Makefile
--- linux-2.6.35.7/drivers/input/misc/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/misc/Makefile	2011-08-08 12:52:34.000000000 +0800
@@ -4,6 +4,7 @@
 
 # Each configuration option enables a list of files.
 
+obj-$(CONFIG_GYRO_K3G)			+= k3g.o
 obj-$(CONFIG_INPUT_88PM860X_ONKEY)	+= 88pm860x_onkey.o
 obj-$(CONFIG_INPUT_AD714X)		+= ad714x.o
 obj-$(CONFIG_INPUT_AD714X_I2C)		+= ad714x-i2c.o
@@ -16,8 +17,10 @@
 obj-$(CONFIG_INPUT_CM109)		+= cm109.o
 obj-$(CONFIG_INPUT_COBALT_BTNS)		+= cobalt_btns.o
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
 obj-$(CONFIG_INPUT_MAX8925_ONKEY)	+= max8925_onkey.o
@@ -38,4 +41,4 @@ obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_GPIO_BUTTONS)	+= gpio_buttons.o
-
+obj-$(CONFIG_OPTICAL_GP2A)		+= gp2a.o
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/Kconfig tiny210/drivers/input/touchscreen/Kconfig
--- linux-2.6.35.7/drivers/input/touchscreen/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/touchscreen/Kconfig	2012-02-23 17:00:24.000000000 +0800
@@ -99,6 +99,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called h3600_ts_input.
 
+config TOUCHSCREEN_S3C
+	tristate "S3C touchscreen driver"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX || ARCH_S5PV2XX || ARCH_S5P64XX || CPU_S5PV210 || CPU_S5PC110
+	default y
+	help
+	  Say Y here to enable the driver for the touchscreen on the S3C SMDK board.
+	  If unsure, say N. To compile this driver as a module, choose M here: the module will be called s3c_ts.
+
 config TOUCHSCREEN_DA9034
 	tristate "Touchscreen support for Dialog Semiconductor DA9034"
 	depends on PMIC_DA903X
@@ -165,6 +173,34 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called s3c2410_ts.
 
+config TOUCHSCREEN_1WIRE
+	tristate "Mini210 1-Wire host and Touch Screen Driver"
+	depends on MACH_MINI210
+	help
+	  Say Y here to enable the 1-Wire host and Touch Screen driver for
+	  FriendlyARM Mini210 development board.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mini210_1wire_host.
+
+config TOUCHSCREEN_IF
+	bool
+	default y if TOUCHSCREEN_1WIRE
+
+config TOUCHSCREEN_GOODIX
+	tristate "Goodix GT80X multi-touch driver"
+	depends on MACH_MINI210
+	help
+	  Say Y here to support Goodix touchscreen whose name is guitar on
+	  FriendlyARM Mini210 development board.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called goodix_touch.ko.
+
 config TOUCHSCREEN_GUNZE
 	tristate "Gunze AHL-51S touchscreen"
 	select SERIO
@@ -248,6 +284,18 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called mk712.
 
+config TOUCHSCREEN_MXT224
+	tristate "Atmel MaxTouch 224"
+	depends on I2C
+	help
+	  Say Y here to enable support for the Atmel MaxTouch 224 touch
+	  controller.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mxt224.
+
 config TOUCHSCREEN_HP600
 	tristate "HP Jornada 6xx touchscreen"
 	depends on SH_HP6XX && SH_ADC
@@ -303,6 +351,12 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called migor_ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/Makefile tiny210/drivers/input/touchscreen/Makefile
--- linux-2.6.35.7/drivers/input/touchscreen/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/input/touchscreen/Makefile	2012-02-23 17:00:24.000000000 +0800
@@ -24,6 +24,7 @@
 obj-$(CONFIG_TOUCHSCREEN_MIGOR)		+= migor_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
+obj-$(CONFIG_TOUCHSCREEN_MXT224)	+= mxt224.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_HTCPEN)	+= htcpen.o
@@ -31,6 +32,7 @@
 obj-$(CONFIG_TOUCHSCREEN_PCAP)		+= pcap_ts.o
 obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
 obj-$(CONFIG_TOUCHSCREEN_S3C2410)	+= s3c2410_ts.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
@@ -47,3 +49,15 @@
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_S3C)           += ts-s3c.o
+obj-$(CONFIG_TOUCHSCREEN_1WIRE)		+= mini210_1wire_host.o
+obj-$(CONFIG_TOUCHSCREEN_IF)		+= ts-if.o
+
+ifneq ($(wildcard drivers/input/touchscreen/goodix_touch.c),)
+ifeq ($(FA),1)
+obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix_touch.o
+else
+obj-m += goodix_touch.o
+endif  #FA
+endif
+
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/mini210_1wire_host.c tiny210/drivers/input/touchscreen/mini210_1wire_host.c
--- linux-2.6.35.7/drivers/input/touchscreen/mini210_1wire_host.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/touchscreen/mini210_1wire_host.c	2011-08-17 19:16:23.000000000 +0800
@@ -0,0 +1,765 @@
+/*
+ * mini6410_1wire_host.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * LCD-CPU one wire communication for Mini6410 from
+ *         FriendlyARM Guangzhou CO., LTD.
+ *
+ * Copyright (c) 2010 FriendlyARM Guangzhou CO., LTD.  <http://www.arm9.net>
+ *
+ * ChangeLog
+ *
+ *
+ * 2010-10-14: Russell Guo <russell.grey@gmail.com>
+ *      - Initial version
+ *      -- request touch-screen data
+ *      -- request LCD type, Firmware version
+ *      -  Backlight control
+ *
+ * the CRC-8 functions is based on web page from http://lfh1986.blogspot.com
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/param.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <plat/regs-timer.h>
+	 
+#include <plat/gpio-cfg.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <linux/cdev.h>
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/irq.h>
+#include <mach/map.h>
+#include <mach/regs-irq.h>
+#include <asm/mach/time.h>
+
+#include <plat/clock.h>
+#include <plat/cpu.h>
+
+#undef DEBUG
+#define DEBUG
+#ifdef DEBUG
+#define DPRINTK(x...) {printk("%s(%d): ",__FUNCTION__ ,__LINE__);printk(x);}
+#else
+#define DPRINTK(x...) (void)(0)
+#endif
+
+#if	1
+#if	0
+/* Micro210 1101 */
+#warning "Micro210 1101"
+#define GPIO_1WIRE		S5PV210_GPH1(1)
+#endif
+#warning "mini210 1119"
+#define GPIO_1WIRE      S5PV210_GPH1(2)
+#else
+/* miniv210 (eval) */
+#define GPIO_1WIRE		S5PV210_GPD0(0)
+#endif
+
+#define TOUCH_DEVICE_NAME	"touchscreen-1wire"
+#define BACKLIGHT_DEVICE_NAME	"backlight-1wire"
+#define SAMPLE_BPS 9600
+
+#define SLOW_LOOP_FEQ 25
+#define FAST_LOOP_FEQ 60
+
+#define REQ_TS   0x40U
+#define REQ_INFO 0x60U
+
+// Touch Screen driver interface
+//
+static DECLARE_WAIT_QUEUE_HEAD(ts_waitq);
+static int ts_ready;
+static unsigned ts_status;
+static int resumed = 0;
+
+
+static inline void notify_ts_data(unsigned x, unsigned y, unsigned down)
+{
+	if (!down && !(ts_status &(1U << 31))) {
+		// up repeat, give it up
+		return;
+	}
+
+	ts_status = ((x << 16) | (y)) | (down << 31);
+	ts_ready = 1;
+	wake_up_interruptible(&ts_waitq);
+}
+
+static ssize_t ts_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	unsigned long err;
+
+	if (!ts_ready) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		else
+			wait_event_interruptible(ts_waitq, ts_ready);
+	}
+
+	ts_ready = 0;
+
+	if (count < sizeof ts_status) {
+		return -EINVAL;
+	} else {
+		count = sizeof ts_status;
+	}
+
+	err = copy_to_user((void *)buffer, (const void *)(&ts_status), sizeof ts_status);
+	return err ? -EFAULT : sizeof ts_status;
+}
+
+static unsigned int ts_poll( struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+
+	poll_wait(file, &ts_waitq, wait);
+
+	if (ts_ready)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static struct file_operations ts_fops = {
+	owner:		THIS_MODULE,
+	read:		ts_read,	
+	poll:   	ts_poll,
+};
+
+static struct miscdevice ts_misc = {
+	.minor		= 181,
+	.name		= TOUCH_DEVICE_NAME,
+	.fops		= &ts_fops,
+};
+
+
+static DECLARE_WAIT_QUEUE_HEAD(bl_waitq);
+static int bl_ready;
+static unsigned char backlight_req = 0;
+static unsigned char backlight_init_success;
+
+static inline void notify_bl_data(unsigned char a, unsigned char b, unsigned char c)
+{
+	bl_ready = 1;
+	backlight_init_success = 1;
+	wake_up_interruptible(&bl_waitq);
+}
+
+static ssize_t bl_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	int ret;
+	char buf[4] = {0, 0, 0, 0};
+	unsigned v;
+	unsigned len;
+
+	if (count == 0) {
+		return -EINVAL;
+	}
+
+	if (count > sizeof buf - 1) {
+		len = sizeof buf - 1;
+	} else {
+		len = count;
+	}
+
+	ret = copy_from_user(buf, buffer, len);
+	if (ret) {
+		return -EFAULT;
+	}
+
+	if (sscanf(buf, "%u", &v) != 1) {
+		return -EINVAL;
+	}
+
+	if (v > 127) {
+		v = 127;
+	}
+
+	bl_ready = 0;
+	backlight_req = v + 0x80U;
+
+	ret = wait_event_interruptible_timeout(bl_waitq, bl_ready, HZ / 10);
+	if (ret < 0) {
+		return ret;
+	}
+	if (ret == 0) {
+		return -ETIMEDOUT;
+	}
+
+	return count;
+}
+
+static struct file_operations bl_fops = {
+	owner:		THIS_MODULE,
+	write:		bl_write,
+};
+
+static struct miscdevice bl_misc = {
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= BACKLIGHT_DEVICE_NAME,
+	.fops		= &bl_fops,
+};
+
+// for query base info
+//
+static unsigned lcd_type, firmware_ver;
+
+static inline void notify_info_data(unsigned char _lcd_type,
+		unsigned char ver_year, unsigned char week)
+{
+	if (_lcd_type != 0xFF) {
+		lcd_type = _lcd_type;
+		firmware_ver = ver_year * 100 + week;
+	}
+}
+
+// Pin access
+//
+static inline void set_pin_up(void)
+{
+	/* TODO: */
+#if	0
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFPUD);
+	tmp &= ~(3U <<30);
+	tmp |= (2U << 30);
+	writel(tmp, S3C64XX_GPFPUD);
+#endif
+}
+
+static inline void set_pin_as_input(void)
+{
+	gpio_direction_input(GPIO_1WIRE);
+}
+
+static inline void set_pin_as_output(void)
+{
+	gpio_direction_output(GPIO_1WIRE, 1);
+}
+
+static inline void set_pin_value(int v)
+{
+	if (v) {
+		gpio_set_value(GPIO_1WIRE, 1);
+	} else {
+		gpio_set_value(GPIO_1WIRE, 0);
+	}
+}
+
+static inline int get_pin_value(void)
+{
+	return gpio_get_value(GPIO_1WIRE);
+}
+
+// CRC
+//
+static const unsigned char crc8_tab[] = {
+0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
+0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
+0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
+0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
+0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
+0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
+0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
+0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
+0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
+0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
+0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
+0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
+0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
+0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
+0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
+0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
+0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
+0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
+0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
+0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
+0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
+0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
+0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
+0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
+0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
+0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
+0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
+0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
+0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
+0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
+0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
+0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3,
+};
+
+#define crc8_init(crc) ((crc) = 0XACU)
+#define crc8(crc, v) ( (crc) = crc8_tab[(crc) ^(v)])
+
+// once a session complete
+static unsigned total_received, total_error;
+static unsigned last_req, last_res;
+
+static void one_wire_session_complete(unsigned char req, unsigned int res)
+{
+	unsigned char crc;
+	const unsigned char *p = (const unsigned char*)&res;
+	total_received ++;
+	static int cnt = 0;
+
+	last_res = res;
+
+	crc8_init(crc);
+	crc8(crc, p[3]);
+	crc8(crc, p[2]);
+	crc8(crc, p[1]);
+
+	if (crc != p[0]) {
+		// CRC dismatch
+		if (total_received > 100) {
+			total_error++;
+		}
+		return;
+	}
+
+	switch(req) {
+		case REQ_TS:
+			{
+				unsigned short x,y;
+				unsigned pressed;
+				x =  ((p[3] >>   4U) << 8U) + p[2];
+				y =  ((p[3] &  0xFU) << 8U) + p[1];
+				pressed = (x != 0xFFFU) && (y != 0xFFFU); 
+				notify_ts_data(x, y, pressed);
+			}
+			break;
+
+		case REQ_INFO:
+			notify_info_data(p[3], p[2], p[1]);
+			break;
+		default:
+			notify_bl_data(p[3], p[2], p[1]);
+			break;
+	}
+}
+
+// one-wire protocol core
+static unsigned long TCNT_FOR_SAMPLE_BIT;
+static unsigned long TCNT_FOR_FAST_LOOP;
+static unsigned long TCNT_FOR_SLOW_LOOP;
+
+static int init_timer_for_1wire(void)
+{
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+
+	unsigned prescale1_value;
+
+	unsigned long pclk;
+	struct clk *clk;
+
+	// get pclk
+	clk = clk_get(NULL, "timers");
+	if (IS_ERR(clk)) {
+		DPRINTK("ERROR to get PCLK\n");
+		return -EIO;
+	}
+	clk_enable(clk);
+
+	pclk = clk_get_rate(clk);
+	printk("PWM clock = %d\n", pclk);
+
+	// get prescaler
+	tcfg0 = __raw_readl(S3C2410_TCFG0);
+	// we use system prescaler value because timer 4 uses same one
+	prescale1_value = (tcfg0 >> 8) & 0xFF;
+
+	// calc the TCNT_FOR_SAMPLE_BIT, that is one of the goal
+	TCNT_FOR_SAMPLE_BIT = pclk / (prescale1_value + 1) / SAMPLE_BPS - 1;
+	TCNT_FOR_FAST_LOOP  = pclk / (prescale1_value + 1) / FAST_LOOP_FEQ - 1;
+	TCNT_FOR_SLOW_LOOP  = pclk / (prescale1_value + 1) / SLOW_LOOP_FEQ - 1;
+
+	// select timer 3, the 2rd goal
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg1 &= ~S3C2410_TCFG1_MUX3_MASK;
+	writel(tcfg1, S3C2410_TCFG1);
+
+	printk("TCNT_FOR_SAMPLE_BIT = %d\n", TCNT_FOR_SAMPLE_BIT);
+	printk("TCFG1 = %08x - %08x\n", tcfg1, __raw_readl(S3C2410_TCFG1));
+	return 0;
+}
+
+static inline void stop_timer_for_1wire(void)
+{
+	unsigned long tcon;
+        tcon = __raw_readl(S3C2410_TCON);
+	tcon &= ~S3C2410_TCON_T3START;
+	writel(tcon, S3C2410_TCON);
+}
+
+enum {
+	IDLE,
+	START,
+	REQUEST,
+	WAITING,
+	RESPONSE,
+	STOPING,
+} one_wire_status = IDLE;
+
+static volatile unsigned int io_bit_count;
+static volatile unsigned int io_data;
+static volatile unsigned char one_wire_request;
+static irqreturn_t timer_for_1wire_interrupt(int irq, void *dev_id)
+{
+    unsigned int tint;
+    tint = __raw_readl(S3C64XX_TINT_CSTAT);
+    tint |= 0x100;
+    __raw_writel(tint, S3C64XX_TINT_CSTAT);
+  
+	io_bit_count--;
+	switch(one_wire_status) {
+	case START:
+		if (io_bit_count == 0) {
+			io_bit_count = 16;
+			one_wire_status = REQUEST;
+		}
+		break;
+
+	case REQUEST:
+		// Send a bit
+		set_pin_value(io_data & (1U << 31));
+		io_data <<= 1;
+		if (io_bit_count == 0) {
+			io_bit_count = 2;
+			one_wire_status = WAITING;
+		}
+		break;
+		
+	case WAITING:
+		if (io_bit_count == 0) {
+			io_bit_count = 32;
+			one_wire_status = RESPONSE;
+		}
+		if (io_bit_count == 1) {
+			set_pin_as_input();
+			set_pin_value(1);
+		}
+		break;
+		
+	case RESPONSE:
+		// Get a bit
+		io_data = (io_data << 1) | get_pin_value();
+		if (io_bit_count == 0) {
+			io_bit_count = 2;
+			one_wire_status = STOPING;
+			set_pin_value(1);
+			set_pin_as_output();
+			one_wire_session_complete(one_wire_request, io_data);
+		}
+		break;
+
+	case STOPING:
+		if (io_bit_count == 0) {
+			one_wire_status = IDLE;
+			stop_timer_for_1wire();
+		}
+		break;
+		
+	default:
+		stop_timer_for_1wire();
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction timer_for_1wire_irq = {
+	.name    = "1-wire Timer Tick",
+	.flags   = IRQF_DISABLED | IRQF_IRQPOLL,
+	.handler = timer_for_1wire_interrupt,
+	.dev_id  = &timer_for_1wire_irq,
+};
+
+
+static int err_i = 0;
+
+static void start_one_wire_session(unsigned char req)
+{
+	unsigned long tcon;
+	unsigned long flags;
+
+	if (one_wire_status != IDLE) {
+		//printk("one_wire_status: %d\n", one_wire_status);
+
+		if (++err_i < 3) {
+		    printk("%d - TCNTB = %08x, TCNTO = %08x\n", one_wire_status,
+			    __raw_readl(S3C2410_TCNTB(3)), __raw_readl(S3C2410_TCNTO(3)));
+		    printk("TINT_CSTAT = %08x\n", __raw_readl(S3C64XX_TINT_CSTAT));
+		}
+		return;
+	}
+
+	one_wire_status = START;
+
+	set_pin_value(1);
+	set_pin_as_output();
+	// IDLE to START
+	{
+		unsigned char crc;
+		crc8_init(crc);
+		crc8(crc, req);
+		io_data = (req << 8) + crc;
+		io_data <<= 16;
+	}
+	last_req = (io_data >> 16);
+	one_wire_request = req;
+	io_bit_count = 1;
+	set_pin_as_output();
+
+	writel(TCNT_FOR_SAMPLE_BIT, S3C2410_TCNTB(3));
+	// init tranfer and start timer
+        tcon = __raw_readl(S3C2410_TCON);
+	tcon &= ~(0xF << 16);
+	tcon |= S3C2410_TCON_T3MANUALUPD;
+	writel(tcon, S3C2410_TCON);
+
+
+	tcon |= S3C2410_TCON_T3START;
+	tcon |= S3C2410_TCON_T3RELOAD;
+	tcon &= ~S3C2410_TCON_T3MANUALUPD;
+
+	local_irq_save(flags);
+	writel(tcon, S3C2410_TCON);
+	set_pin_value(0);
+	local_irq_restore(flags);
+
+#if	0
+	printk("TCNTB = %08x, TCNTO = %08x\n",
+		__raw_readl(S3C2410_TCNTB(3)), __raw_readl(S3C2410_TCNTO(3)));
+	printk("TCON = %08x - %08x\n", tcon, __raw_readl(S3C2410_TCON));
+#endif
+}
+
+// poll the device
+// following is Linux timer not HW timer
+static int exitting;
+static struct timer_list one_wire_timer;
+
+void one_wire_timer_proc(unsigned long v)
+{
+	unsigned char req;
+
+	if (exitting) {
+		return;
+	}
+
+	one_wire_timer.expires = jiffies + HZ / 50;
+	add_timer(&one_wire_timer);
+
+	if (lcd_type == 0) {
+		req = REQ_INFO;
+	} else if (!backlight_init_success) {
+		req = 127;
+	} else if (backlight_req) {
+		req = backlight_req;
+		backlight_req = 0;
+	} else {
+		req = REQ_TS;
+	}
+
+	start_one_wire_session(req);
+}
+
+static struct timer_list one_wire_timer = {
+	.function = one_wire_timer_proc,
+};
+
+static int read_proc(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(buf, "%u %u %u %u %04X %08X\n",
+			lcd_type, firmware_ver, total_received, total_error, last_req, last_res);
+	*eof = 1;
+	return len;
+}
+
+static int ts_1wire_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = gpio_request(GPIO_1WIRE, "GPH1_1");
+	if (ret) {
+		printk(KERN_ERR "failed to request GPH0 for lcd reset control\n");
+		return ret;
+	}
+
+	gpio_direction_output(GPIO_1WIRE, 1);
+	gpio_set_value(GPIO_1WIRE, 1);
+	set_pin_up();
+
+	if (ret == 0) {
+		ret = setup_irq(IRQ_TIMER3, &timer_for_1wire_irq);
+		printk("setup_irq: ret = %d\n", ret);
+		ret = init_timer_for_1wire();
+		init_timer(&one_wire_timer);
+		one_wire_timer_proc(0);
+	}
+
+	/* enable TINT */
+	{
+		unsigned int tint;
+		tint = __raw_readl(S3C64XX_TINT_CSTAT);
+		tint |= 0x108;
+		__raw_writel(tint, S3C64XX_TINT_CSTAT);
+	}
+
+	return ret;
+}
+
+static int ts_1wire_remove(struct platform_device *pdev)
+{
+	del_timer_sync(&one_wire_timer);
+	free_irq(IRQ_TIMER3, &timer_for_1wire_irq);
+    gpio_free(GPIO_1WIRE);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ts_1wire_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	printk("ts_1wire_suspend: before \n");
+
+	del_timer_sync(&one_wire_timer);
+	disable_irq(IRQ_TIMER3);
+    gpio_free(GPIO_1WIRE);
+
+	printk("ts_1wire_suspend: ok \n");
+
+	return 0;
+}
+
+static int ts_1wire_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+
+	printk("ts_1wire_resume: \n");
+
+	err_i = 0;
+
+	ret = gpio_request(GPIO_1WIRE, "GPH1_1");
+	if (ret) {
+		printk(KERN_ERR "failed to request GPH0 for lcd reset control\n");
+	}
+
+	gpio_direction_output(GPIO_1WIRE, 1);
+	gpio_set_value(GPIO_1WIRE, 1);
+	set_pin_up();
+
+	lcd_type = 0;
+	backlight_req = 0;
+	backlight_init_success = 0;
+	one_wire_status = IDLE;
+	io_bit_count = 0;
+	io_data = 0;
+	one_wire_request = 0;
+	resumed = 1;
+
+	ret = init_timer_for_1wire();
+	init_timer(&one_wire_timer);
+	one_wire_timer_proc(0);
+
+	enable_irq(IRQ_TIMER3);
+
+	/* enable TINT */
+	{
+		unsigned int tint;
+		tint = __raw_readl(S3C64XX_TINT_CSTAT);
+		tint |= 0x108;
+		__raw_writel(tint, S3C64XX_TINT_CSTAT);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops ts_1wire_pm_ops = {
+	.suspend	= ts_1wire_suspend,
+	.resume		= ts_1wire_resume,
+};
+#endif
+
+static struct platform_driver ts_1wire_device_driver = {
+	.probe		= ts_1wire_probe,
+	.remove		= __devexit_p(ts_1wire_remove),
+	.driver		= {
+		.name	= "mini210_1wire",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm		= &ts_1wire_pm_ops,
+#endif
+	}
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	ret = misc_register(&ts_misc) | misc_register(&bl_misc) ;
+	if (ret == 0) {
+		create_proc_read_entry("driver/one-wire-info", 0, NULL, read_proc, NULL);
+		printk (TOUCH_DEVICE_NAME"\tinitialized\n");
+		printk (BACKLIGHT_DEVICE_NAME"\tinitialized\n");
+	}
+
+	return platform_driver_register(&ts_1wire_device_driver);
+}
+
+static void __exit dev_exit(void)
+{
+	exitting = 1;
+	platform_driver_unregister(&ts_1wire_device_driver);
+
+	remove_proc_entry("driver/one-wire-info", NULL);
+
+	misc_deregister(&ts_misc);
+	misc_deregister(&bl_misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("Mini6410 one-wire host and Touch Screen Driver");
+
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/mxt224.c tiny210/drivers/input/touchscreen/mxt224.c
--- linux-2.6.35.7/drivers/input/touchscreen/mxt224.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/touchscreen/mxt224.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,648 @@
+/*
+ *  Copyright (C) 2010, Samsung Electronics Co. Ltd. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/input/mxt224.h>
+#include <asm/unaligned.h>
+
+#define OBJECT_TABLE_START_ADDRESS	7
+#define OBJECT_TABLE_ELEMENT_SIZE	6
+
+#define CMD_RESET_OFFSET		0
+#define CMD_BACKUP_OFFSET		1
+
+#define DETECT_MSG_MASK			0x80
+#define PRESS_MSG_MASK			0x40
+#define RELEASE_MSG_MASK		0x20
+#define MOVE_MSG_MASK			0x10
+#define SUPPRESS_MSG_MASK		0x02
+
+#define ID_BLOCK_SIZE			7
+
+struct object_t {
+	u8 object_type;
+	u16 i2c_address;
+	u8 size;
+	u8 instances;
+	u8 num_report_ids;
+} __packed;
+
+struct finger_info {
+	s16 x;
+	s16 y;
+	s16 z;
+	u16 w;
+};
+
+struct mxt224_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct early_suspend early_suspend;
+	u32 finger_mask;
+	int gpio_read_done;
+	struct object_t *objects;
+	u8 objects_len;
+	u8 tsp_version;
+	const u8 *power_cfg;
+	u8 finger_type;
+	u16 msg_proc;
+	u16 cmd_proc;
+	u16 msg_object_size;
+	u32 x_dropbits:2;
+	u32 y_dropbits:2;
+	void (*power_on)(void);
+	void (*power_off)(void);
+	int num_fingers;
+	struct finger_info fingers[];
+};
+
+static int read_mem(struct mxt224_data *data, u16 reg, u8 len, u8 *buf)
+{
+	int ret;
+	u16 le_reg = cpu_to_le16(reg);
+	struct i2c_msg msg[2] = {
+		{
+			.addr = data->client->addr,
+			.flags = 0,
+			.len = 2,
+			.buf = (u8 *)&le_reg,
+		},
+		{
+			.addr = data->client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buf,
+		},
+	};
+
+	ret = i2c_transfer(data->client->adapter, msg, 2);
+	if (ret < 0)
+		return ret;
+
+	return ret == 2 ? 0 : -EIO;
+}
+
+static int write_mem(struct mxt224_data *data, u16 reg, u8 len, const u8 *buf)
+{
+	int ret;
+	u8 tmp[len + 2];
+
+	put_unaligned_le16(cpu_to_le16(reg), tmp);
+	memcpy(tmp + 2, buf, len);
+
+	ret = i2c_master_send(data->client, tmp, sizeof(tmp));
+	if (ret < 0)
+		return ret;
+
+	return ret == sizeof(tmp) ? 0 : -EIO;
+}
+
+static int __devinit mxt224_reset(struct mxt224_data *data)
+{
+	u8 buf = 1u;
+	return write_mem(data, data->cmd_proc + CMD_RESET_OFFSET, 1, &buf);
+}
+
+static int __devinit mxt224_backup(struct mxt224_data *data)
+{
+	u8 buf = 0x55u;
+	return write_mem(data, data->cmd_proc + CMD_BACKUP_OFFSET, 1, &buf);
+}
+
+static int get_object_info(struct mxt224_data *data, u8 object_type, u16 *size,
+				u16 *address)
+{
+	int i;
+
+	for (i = 0; i < data->objects_len; i++) {
+		if (data->objects[i].object_type == object_type) {
+			*size = data->objects[i].size + 1;
+			*address = data->objects[i].i2c_address;
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int write_config(struct mxt224_data *data, u8 type, const u8 *cfg)
+{
+	int ret;
+	u16 address;
+	u16 size;
+
+	ret = get_object_info(data, type, &size, &address);
+
+	if (ret)
+		return ret;
+
+	return write_mem(data, address, size, cfg);
+}
+
+
+static u32 __devinit crc24(u32 crc, u8 byte1, u8 byte2)
+{
+	static const u32 crcpoly = 0x80001B;
+	u32 res;
+	u16 data_word;
+
+	data_word = (((u16)byte2) << 8) | byte1;
+	res = (crc << 1) ^ (u32)data_word;
+
+	if (res & 0x1000000)
+		res ^= crcpoly;
+
+	return res;
+}
+
+static int __devinit calculate_infoblock_crc(struct mxt224_data *data,
+							u32 *crc_pointer)
+{
+	u32 crc = 0;
+	u8 mem[7 + data->objects_len * 6];
+	int status;
+	int i;
+
+	status = read_mem(data, 0, sizeof(mem), mem);
+
+	if (status)
+		return status;
+
+	for (i = 0; i < sizeof(mem) - 1; i += 2)
+		crc = crc24(crc, mem[i], mem[i + 1]);
+
+	*crc_pointer = crc24(crc, mem[i], 0) & 0x00FFFFFF;
+
+	return 0;
+}
+
+static int __devinit mxt224_init_touch_driver(struct mxt224_data *data)
+{
+	struct object_t *object_table;
+	u32 read_crc = 0;
+	u32 calc_crc;
+	u16 crc_address;
+	u16 dummy;
+	int i;
+	u8 id[ID_BLOCK_SIZE];
+	int ret;
+	u8 type_count = 0;
+	u8 tmp;
+
+	ret = read_mem(data, 0, sizeof(id), id);
+	if (ret)
+		return ret;
+
+	dev_info(&data->client->dev, "family = %#02x, variant = %#02x, version "
+			"= %#02x, build = %d\n", id[0], id[1], id[2], id[3]);
+	dev_dbg(&data->client->dev, "matrix X size = %d\n", id[4]);
+	dev_dbg(&data->client->dev, "matrix Y size = %d\n", id[5]);
+
+	data->tsp_version = id[2];
+	data->objects_len = id[6];
+
+	object_table = kmalloc(data->objects_len * sizeof(*object_table),
+				GFP_KERNEL);
+	if (!object_table)
+		return -ENOMEM;
+
+	ret = read_mem(data, OBJECT_TABLE_START_ADDRESS,
+			data->objects_len * sizeof(*object_table),
+			(u8 *)object_table);
+	if (ret)
+		goto err;
+
+	for (i = 0; i < data->objects_len; i++) {
+		object_table[i].i2c_address =
+				le16_to_cpu(object_table[i].i2c_address);
+		tmp = 0;
+		if (object_table[i].num_report_ids) {
+			tmp = type_count + 1;
+			type_count += object_table[i].num_report_ids *
+						(object_table[i].instances + 1);
+		}
+		switch (object_table[i].object_type) {
+		case TOUCH_MULTITOUCHSCREEN_T9:
+			data->finger_type = tmp;
+			dev_dbg(&data->client->dev, "Finger type = %d\n",
+						data->finger_type);
+			break;
+		case GEN_MESSAGEPROCESSOR_T5:
+			data->msg_object_size = object_table[i].size + 1;
+			dev_dbg(&data->client->dev, "Message object size = "
+						"%d\n", data->msg_object_size);
+			break;
+		}
+	}
+
+	data->objects = object_table;
+
+	/* Verify CRC */
+	crc_address = OBJECT_TABLE_START_ADDRESS +
+			data->objects_len * OBJECT_TABLE_ELEMENT_SIZE;
+
+#ifdef __BIG_ENDIAN
+#error The following code will likely break on a big endian machine
+#endif
+	ret = read_mem(data, crc_address, 3, (u8 *)&read_crc);
+	if (ret)
+		goto err;
+
+	read_crc = le32_to_cpu(read_crc);
+
+	ret = calculate_infoblock_crc(data, &calc_crc);
+	if (ret)
+		goto err;
+
+	if (read_crc != calc_crc) {
+		dev_err(&data->client->dev, "CRC error\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = get_object_info(data, GEN_MESSAGEPROCESSOR_T5, &dummy,
+					&data->msg_proc);
+	if (ret)
+		goto err;
+
+	ret = get_object_info(data, GEN_COMMANDPROCESSOR_T6, &dummy,
+					&data->cmd_proc);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(object_table);
+	return ret;
+}
+
+static void report_input_data(struct mxt224_data *data)
+{
+	int i;
+
+	for (i = 0; i < data->num_fingers; i++) {
+		if (data->fingers[i].z == -1)
+			continue;
+
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X,
+					data->fingers[i].x);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y,
+					data->fingers[i].y);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR,
+					data->fingers[i].z);
+		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR,
+					data->fingers[i].w);
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, i);
+		input_mt_sync(data->input_dev);
+
+		if (data->fingers[i].z == 0)
+			data->fingers[i].z = -1;
+	}
+	data->finger_mask = 0;
+
+	input_sync(data->input_dev);
+}
+
+static irqreturn_t mxt224_irq_thread(int irq, void *ptr)
+{
+	struct mxt224_data *data = ptr;
+	int id;
+	u8 msg[data->msg_object_size];
+
+	do {
+		if (read_mem(data, data->msg_proc, sizeof(msg), msg))
+			return IRQ_HANDLED;
+
+		id = msg[0] - data->finger_type;
+
+		/* If not a touch event, then keep going */
+		if (id < 0 || id >= data->num_fingers)
+			continue;
+
+		if (data->finger_mask & (1U << id))
+			report_input_data(data);
+
+		if (msg[1] & RELEASE_MSG_MASK) {
+			data->fingers[id].z = 0;
+			data->fingers[id].w = msg[5];
+			data->finger_mask |= 1U << id;
+		} else if ((msg[1] & DETECT_MSG_MASK) && (msg[1] &
+				(PRESS_MSG_MASK | MOVE_MSG_MASK))) {
+			data->fingers[id].z = msg[6];
+			data->fingers[id].w = msg[5];
+			data->fingers[id].x = ((msg[2] << 4) | (msg[4] >> 4)) >>
+							data->x_dropbits;
+			data->fingers[id].y = ((msg[3] << 4) |
+					(msg[4] & 0xF)) >> data->y_dropbits;
+			data->finger_mask |= 1U << id;
+		} else if ((msg[1] & SUPPRESS_MSG_MASK) &&
+			   (data->fingers[id].z != -1)) {
+			data->fingers[id].z = 0;
+			data->fingers[id].w = msg[5];
+			data->finger_mask |= 1U << id;
+		} else {
+			dev_dbg(&data->client->dev, "Unknown state %#02x %#02x"
+						"\n", msg[0], msg[1]);
+			continue;
+		}
+	} while (!gpio_get_value(data->gpio_read_done));
+
+	if (data->finger_mask)
+		report_input_data(data);
+
+	return IRQ_HANDLED;
+}
+
+static int mxt224_internal_suspend(struct mxt224_data *data)
+{
+	static const u8 sleep_power_cfg[3];
+	int ret;
+	int i;
+
+	ret = write_config(data, GEN_POWERCONFIG_T7, sleep_power_cfg);
+	if (ret)
+		return ret;
+
+
+	for (i = 0; i < data->num_fingers; i++) {
+		if (data->fingers[i].z == -1)
+			continue;
+		data->fingers[i].z = 0;
+	}
+	report_input_data(data);
+
+	data->power_off();
+
+	return 0;
+}
+
+static int mxt224_internal_resume(struct mxt224_data *data)
+{
+	int ret;
+	int i;
+
+	data->power_on();
+
+	i = 0;
+	do {
+		ret = write_config(data, GEN_POWERCONFIG_T7, data->power_cfg);
+		msleep(20);
+		i++;
+	} while (ret && i < 10);
+
+	return ret;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#define mxt224_suspend	NULL
+#define mxt224_resume	NULL
+
+static void mxt224_early_suspend(struct early_suspend *h)
+{
+	struct mxt224_data *data = container_of(h, struct mxt224_data,
+								early_suspend);
+	disable_irq(data->client->irq);
+	mxt224_internal_suspend(data);
+}
+
+static void mxt224_late_resume(struct early_suspend *h)
+{
+	struct mxt224_data *data = container_of(h, struct mxt224_data,
+								early_suspend);
+	mxt224_internal_resume(data);
+	enable_irq(data->client->irq);
+}
+#else
+static int mxt224_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxt224_data *data = i2c_get_clientdata(client);
+
+	return mxt224_internal_suspend(data);
+}
+
+static int mxt224_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxt224_data *data = i2c_get_clientdata(client);
+
+	return mxt224_internal_resume(data);
+}
+#endif
+
+static int __devinit mxt224_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	struct mxt224_platform_data *pdata = client->dev.platform_data;
+	struct mxt224_data *data;
+	struct input_dev *input_dev;
+	int ret;
+	int i;
+
+	if (!pdata) {
+		dev_err(&client->dev, "missing platform data\n");
+		return -ENODEV;
+	}
+
+	if (pdata->max_finger_touches <= 0)
+		return -EINVAL;
+
+	data = kzalloc(sizeof(*data) + pdata->max_finger_touches *
+					sizeof(*data->fingers), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->num_fingers = pdata->max_finger_touches;
+	data->power_on = pdata->power_on;
+	data->power_off = pdata->power_off;
+
+	data->client = client;
+	i2c_set_clientdata(client, data);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "input device allocation failed\n");
+		goto err_alloc_dev;
+	}
+	data->input_dev = input_dev;
+	input_set_drvdata(input_dev, data);
+	input_dev->name = "mxt224_ts_input";
+
+	set_bit(EV_ABS, input_dev->evbit);
+
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, pdata->min_x,
+			pdata->max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, pdata->min_y,
+			pdata->max_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, pdata->min_z,
+			pdata->max_z, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, pdata->min_w,
+			pdata->max_w, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0,
+			data->num_fingers - 1, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		input_free_device(input_dev);
+		goto err_reg_dev;
+	}
+
+	data->gpio_read_done = pdata->gpio_read_done;
+	ret = gpio_request(data->gpio_read_done, "touch read done");
+	if (ret)
+		goto err_gpio_req;
+
+	data->power_on();
+
+	ret = mxt224_init_touch_driver(data);
+	if (ret) {
+		dev_err(&client->dev, "chip initialization failed\n");
+		goto err_init_drv;
+	}
+
+	for (i = 0; pdata->config[i][0] != RESERVED_T255; i++) {
+		ret = write_config(data, pdata->config[i][0],
+							pdata->config[i] + 1);
+		if (ret)
+			goto err_config;
+
+		if (pdata->config[i][0] == GEN_POWERCONFIG_T7)
+			data->power_cfg = pdata->config[i] + 1;
+
+		if (pdata->config[i][0] == TOUCH_MULTITOUCHSCREEN_T9) {
+			/* Are x and y inverted? */
+			if (pdata->config[i][10] & 0x1) {
+				data->x_dropbits =
+					(!(pdata->config[i][22] & 0xC)) << 1;
+				data->y_dropbits =
+					(!(pdata->config[i][20] & 0xC)) << 1;
+			} else {
+				data->x_dropbits =
+					(!(pdata->config[i][20] & 0xC)) << 1;
+				data->y_dropbits =
+					(!(pdata->config[i][22] & 0xC)) << 1;
+			}
+		}
+	}
+
+	ret = mxt224_backup(data);
+	if (ret)
+		goto err_backup;
+
+	/* reset the touch IC. */
+	ret = mxt224_reset(data);
+	if (ret)
+		goto err_reset;
+
+	msleep(60);
+
+	for (i = 0; i < data->num_fingers; i++)
+		data->fingers[i].z = -1;
+
+	ret = request_threaded_irq(client->irq, NULL, mxt224_irq_thread,
+		IRQF_TRIGGER_LOW | IRQF_ONESHOT, "mxt224_ts", data);
+	if (ret < 0)
+		goto err_irq;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	data->early_suspend.suspend = mxt224_early_suspend;
+	data->early_suspend.resume = mxt224_late_resume;
+	register_early_suspend(&data->early_suspend);
+#endif
+
+	return 0;
+
+err_irq:
+err_reset:
+err_backup:
+err_config:
+	kfree(data->objects);
+err_init_drv:
+	gpio_free(data->gpio_read_done);
+err_gpio_req:
+	data->power_off();
+	input_unregister_device(input_dev);
+err_reg_dev:
+err_alloc_dev:
+	kfree(data);
+	return ret;
+}
+
+static int __devexit mxt224_remove(struct i2c_client *client)
+{
+	struct mxt224_data *data = i2c_get_clientdata(client);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&data->early_suspend);
+#endif
+	free_irq(client->irq, data);
+	kfree(data->objects);
+	gpio_free(data->gpio_read_done);
+	data->power_off();
+	input_unregister_device(data->input_dev);
+	kfree(data);
+
+	return 0;
+}
+
+static struct i2c_device_id mxt224_idtable[] = {
+	{MXT224_DEV_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mxt224_idtable);
+
+static const struct dev_pm_ops mxt224_pm_ops = {
+	.suspend = mxt224_suspend,
+	.resume = mxt224_resume,
+};
+
+static struct i2c_driver mxt224_i2c_driver = {
+	.id_table = mxt224_idtable,
+	.probe = mxt224_probe,
+	.remove = __devexit_p(mxt224_remove),
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= MXT224_DEV_NAME,
+		.pm	= &mxt224_pm_ops,
+	},
+};
+
+static int __init mxt224_init(void)
+{
+	return i2c_add_driver(&mxt224_i2c_driver);
+}
+
+static void __exit mxt224_exit(void)
+{
+	i2c_del_driver(&mxt224_i2c_driver);
+}
+module_init(mxt224_init);
+module_exit(mxt224_exit);
+
+MODULE_DESCRIPTION("Atmel MaXTouch 224 driver");
+MODULE_AUTHOR("Rom Lemarchand <rlemarchand@sta.samsung.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/synaptics_i2c_rmi.c tiny210/drivers/input/touchscreen/synaptics_i2c_rmi.c
--- linux-2.6.35.7/drivers/input/touchscreen/synaptics_i2c_rmi.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/touchscreen/synaptics_i2c_rmi.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,675 @@
+/* drivers/input/keyboard/synaptics_i2c_rmi.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/synaptics_i2c_rmi.h>
+
+static struct workqueue_struct *synaptics_wq;
+
+struct synaptics_ts_data {
+	uint16_t addr;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_irq;
+	bool has_relative_report;
+	struct hrtimer timer;
+	struct work_struct  work;
+	uint16_t max[2];
+	int snap_state[2][2];
+	int snap_down_on[2];
+	int snap_down_off[2];
+	int snap_up_on[2];
+	int snap_up_off[2];
+	int snap_down[2];
+	int snap_up[2];
+	uint32_t flags;
+	int reported_finger_count;
+	int8_t sensitivity_adjust;
+	int (*power)(int on);
+	struct early_suspend early_suspend;
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h);
+static void synaptics_ts_late_resume(struct early_suspend *h);
+#endif
+
+static int synaptics_init_panel(struct synaptics_ts_data *ts)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_page_select_failed;
+	}
+	ret = i2c_smbus_write_byte_data(ts->client, 0x41, 0x04); /* Set "No Clip Z" */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for No Clip Z\n");
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0x44,
+					ts->sensitivity_adjust);
+	if (ret < 0)
+		pr_err("synaptics_ts: failed to set Sensitivity Adjust\n");
+
+err_page_select_failed:
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); /* page select = 0x04 */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf0, 0x81); /* normal operation, 80 reports per second */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_resume: i2c_smbus_write_byte_data failed\n");
+	return ret;
+}
+
+static void synaptics_ts_work_func(struct work_struct *work)
+{
+	int i;
+	int ret;
+	int bad_data = 0;
+	struct i2c_msg msg[2];
+	uint8_t start_reg;
+	uint8_t buf[15];
+	struct synaptics_ts_data *ts = container_of(work, struct synaptics_ts_data, work);
+	int buf_len = ts->has_relative_report ? 15 : 13;
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &start_reg;
+	start_reg = 0x00;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = buf_len;
+	msg[1].buf = buf;
+
+	/* printk("synaptics_ts_work_func\n"); */
+	for (i = 0; i < ((ts->use_irq && !bad_data) ? 1 : 10); i++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 2);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_work_func: i2c_transfer failed\n");
+			bad_data = 1;
+		} else {
+			/* printk("synaptics_ts_work_func: %x %x %x %x %x %x" */
+			/*        " %x %x %x %x %x %x %x %x %x, ret %d\n", */
+			/*        buf[0], buf[1], buf[2], buf[3], */
+			/*        buf[4], buf[5], buf[6], buf[7], */
+			/*        buf[8], buf[9], buf[10], buf[11], */
+			/*        buf[12], buf[13], buf[14], ret); */
+			if ((buf[buf_len - 1] & 0xc0) != 0x40) {
+				printk(KERN_WARNING "synaptics_ts_work_func:"
+				       " bad read %x %x %x %x %x %x %x %x %x"
+				       " %x %x %x %x %x %x, ret %d\n",
+				       buf[0], buf[1], buf[2], buf[3],
+				       buf[4], buf[5], buf[6], buf[7],
+				       buf[8], buf[9], buf[10], buf[11],
+				       buf[12], buf[13], buf[14], ret);
+				if (bad_data)
+					synaptics_init_panel(ts);
+				bad_data = 1;
+				continue;
+			}
+			bad_data = 0;
+			if ((buf[buf_len - 1] & 1) == 0) {
+				/* printk("read %d coordinates\n", i); */
+				break;
+			} else {
+				int pos[2][2];
+				int f, a;
+				int base;
+				/* int x = buf[3] | (uint16_t)(buf[2] & 0x1f) << 8; */
+				/* int y = buf[5] | (uint16_t)(buf[4] & 0x1f) << 8; */
+				int z = buf[1];
+				int w = buf[0] >> 4;
+				int finger = buf[0] & 7;
+
+				/* int x2 = buf[3+6] | (uint16_t)(buf[2+6] & 0x1f) << 8; */
+				/* int y2 = buf[5+6] | (uint16_t)(buf[4+6] & 0x1f) << 8; */
+				/* int z2 = buf[1+6]; */
+				/* int w2 = buf[0+6] >> 4; */
+				/* int finger2 = buf[0+6] & 7; */
+
+				/* int dx = (int8_t)buf[12]; */
+				/* int dy = (int8_t)buf[13]; */
+				int finger2_pressed;
+
+				/* printk("x %4d, y %4d, z %3d, w %2d, F %d, 2nd: x %4d, y %4d, z %3d, w %2d, F %d, dx %4d, dy %4d\n", */
+				/*	x, y, z, w, finger, */
+				/*	x2, y2, z2, w2, finger2, */
+				/*	dx, dy); */
+
+				base = 2;
+				for (f = 0; f < 2; f++) {
+					uint32_t flip_flag = SYNAPTICS_FLIP_X;
+					for (a = 0; a < 2; a++) {
+						int p = buf[base + 1];
+						p |= (uint16_t)(buf[base] & 0x1f) << 8;
+						if (ts->flags & flip_flag)
+							p = ts->max[a] - p;
+						if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
+							if (ts->snap_state[f][a]) {
+								if (p <= ts->snap_down_off[a])
+									p = ts->snap_down[a];
+								else if (p >= ts->snap_up_off[a])
+									p = ts->snap_up[a];
+								else
+									ts->snap_state[f][a] = 0;
+							} else {
+								if (p <= ts->snap_down_on[a]) {
+									p = ts->snap_down[a];
+									ts->snap_state[f][a] = 1;
+								} else if (p >= ts->snap_up_on[a]) {
+									p = ts->snap_up[a];
+									ts->snap_state[f][a] = 1;
+								}
+							}
+						}
+						pos[f][a] = p;
+						base += 2;
+						flip_flag <<= 1;
+					}
+					base += 2;
+					if (ts->flags & SYNAPTICS_SWAP_XY)
+						swap(pos[f][0], pos[f][1]);
+				}
+				if (z) {
+					input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
+					input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
+				}
+				input_report_abs(ts->input_dev, ABS_PRESSURE, z);
+				input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
+				input_report_key(ts->input_dev, BTN_TOUCH, finger);
+				finger2_pressed = finger > 1 && finger != 7;
+				input_report_key(ts->input_dev, BTN_2, finger2_pressed);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
+				}
+
+				if (!finger)
+					z = 0;
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[0][0]);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[0][1]);
+				input_mt_sync(ts->input_dev);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[1][1]);
+					input_mt_sync(ts->input_dev);
+				} else if (ts->reported_finger_count > 1) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+					input_mt_sync(ts->input_dev);
+				}
+				ts->reported_finger_count = finger;
+				input_sync(ts->input_dev);
+			}
+		}
+	}
+	if (ts->use_irq)
+		enable_irq(ts->client->irq);
+}
+
+static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
+{
+	struct synaptics_ts_data *ts = container_of(timer, struct synaptics_ts_data, timer);
+	/* printk("synaptics_ts_timer_func\n"); */
+
+	queue_work(synaptics_wq, &ts->work);
+
+	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t synaptics_ts_irq_handler(int irq, void *dev_id)
+{
+	struct synaptics_ts_data *ts = dev_id;
+
+	/* printk("synaptics_ts_irq_handler\n"); */
+	disable_irq_nosync(ts->client->irq);
+	queue_work(synaptics_wq, &ts->work);
+	return IRQ_HANDLED;
+}
+
+static int synaptics_ts_probe(
+	struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct synaptics_ts_data *ts;
+	uint8_t buf0[4];
+	uint8_t buf1[8];
+	struct i2c_msg msg[2];
+	int ret = 0;
+	uint16_t max_x, max_y;
+	int fuzz_x, fuzz_y, fuzz_p, fuzz_w;
+	struct synaptics_i2c_rmi_platform_data *pdata;
+	unsigned long irqflags;
+	int inactive_area_left;
+	int inactive_area_right;
+	int inactive_area_top;
+	int inactive_area_bottom;
+	int snap_left_on;
+	int snap_left_off;
+	int snap_right_on;
+	int snap_right_off;
+	int snap_top_on;
+	int snap_top_off;
+	int snap_bottom_on;
+	int snap_bottom_off;
+	uint32_t panel_version;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "synaptics_ts_probe: need I2C_FUNC_I2C\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+	INIT_WORK(&ts->work, synaptics_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+	if (pdata)
+		ts->power = pdata->power;
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_probe power on failed\n");
+			goto err_power_failed;
+		}
+	}
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf4, 0x01); /* device command = reset */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		/* fail? */
+	}
+	{
+		int retry = 10;
+		while (retry-- > 0) {
+			ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
+			if (ret >= 0)
+				break;
+			msleep(100);
+		}
+	}
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Major Version %x\n", ret);
+	panel_version = ret << 8;
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe5);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Minor Version %x\n", ret);
+	panel_version |= ret;
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe3);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: product property %x\n", ret);
+
+	if (pdata) {
+		while (pdata->version > panel_version)
+			pdata++;
+		ts->flags = pdata->flags;
+		ts->sensitivity_adjust = pdata->sensitivity_adjust;
+		irqflags = pdata->irqflags;
+		inactive_area_left = pdata->inactive_left;
+		inactive_area_right = pdata->inactive_right;
+		inactive_area_top = pdata->inactive_top;
+		inactive_area_bottom = pdata->inactive_bottom;
+		snap_left_on = pdata->snap_left_on;
+		snap_left_off = pdata->snap_left_off;
+		snap_right_on = pdata->snap_right_on;
+		snap_right_off = pdata->snap_right_off;
+		snap_top_on = pdata->snap_top_on;
+		snap_top_off = pdata->snap_top_off;
+		snap_bottom_on = pdata->snap_bottom_on;
+		snap_bottom_off = pdata->snap_bottom_off;
+		fuzz_x = pdata->fuzz_x;
+		fuzz_y = pdata->fuzz_y;
+		fuzz_p = pdata->fuzz_p;
+		fuzz_w = pdata->fuzz_w;
+	} else {
+		irqflags = 0;
+		inactive_area_left = 0;
+		inactive_area_right = 0;
+		inactive_area_top = 0;
+		inactive_area_bottom = 0;
+		snap_left_on = 0;
+		snap_left_off = 0;
+		snap_right_on = 0;
+		snap_right_off = 0;
+		snap_top_on = 0;
+		snap_top_off = 0;
+		snap_bottom_on = 0;
+		snap_bottom_off = 0;
+		fuzz_x = 0;
+		fuzz_y = 0;
+		fuzz_p = 0;
+		fuzz_w = 0;
+	}
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf0);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: device control %x\n", ret);
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf1);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: interrupt enable %x\n", ret);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		goto err_detect_failed;
+	}
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf0;
+	buf0[0] = 0xe0;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 8;
+	msg[1].buf = buf1;
+	ret = i2c_transfer(ts->client->adapter, msg, 2);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_transfer failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: 0xe0: %x %x %x %x %x %x %x %x\n",
+	       buf1[0], buf1[1], buf1[2], buf1[3],
+	       buf1[4], buf1[5], buf1[6], buf1[7]);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_detect_failed;
+	}
+	ret = i2c_smbus_read_word_data(ts->client, 0x02);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->has_relative_report = !(ret & 0x100);
+	printk(KERN_INFO "synaptics_ts_probe: Sensor properties %x\n", ret);
+	ret = i2c_smbus_read_word_data(ts->client, 0x04);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[0] = max_x = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	ret = i2c_smbus_read_word_data(ts->client, 0x06);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[1] = max_y = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	if (ts->flags & SYNAPTICS_SWAP_XY)
+		swap(max_x, max_y);
+
+	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+	if (ret < 0) {
+		printk(KERN_ERR "synaptics_init_panel failed\n");
+		goto err_detect_failed;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	ts->input_dev->name = "synaptics-rmi-touchscreen";
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_2, ts->input_dev->keybit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	inactive_area_left = inactive_area_left * max_x / 0x10000;
+	inactive_area_right = inactive_area_right * max_x / 0x10000;
+	inactive_area_top = inactive_area_top * max_y / 0x10000;
+	inactive_area_bottom = inactive_area_bottom * max_y / 0x10000;
+	snap_left_on = snap_left_on * max_x / 0x10000;
+	snap_left_off = snap_left_off * max_x / 0x10000;
+	snap_right_on = snap_right_on * max_x / 0x10000;
+	snap_right_off = snap_right_off * max_x / 0x10000;
+	snap_top_on = snap_top_on * max_y / 0x10000;
+	snap_top_off = snap_top_off * max_y / 0x10000;
+	snap_bottom_on = snap_bottom_on * max_y / 0x10000;
+	snap_bottom_off = snap_bottom_off * max_y / 0x10000;
+	fuzz_x = fuzz_x * max_x / 0x10000;
+	fuzz_y = fuzz_y * max_y / 0x10000;
+	ts->snap_down[!!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_left;
+	ts->snap_up[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x + inactive_area_right;
+	ts->snap_down[!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_top;
+	ts->snap_up[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y + inactive_area_bottom;
+	ts->snap_down_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_on;
+	ts->snap_down_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_off;
+	ts->snap_up_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_on;
+	ts->snap_up_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_off;
+	ts->snap_down_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_on;
+	ts->snap_down_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_off;
+	ts->snap_up_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_on;
+	ts->snap_up_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_off;
+	printk(KERN_INFO "synaptics_ts_probe: max_x %d, max_y %d\n", max_x, max_y);
+	printk(KERN_INFO "synaptics_ts_probe: inactive_x %d %d, inactive_y %d %d\n",
+	       inactive_area_left, inactive_area_right,
+	       inactive_area_top, inactive_area_bottom);
+	printk(KERN_INFO "synaptics_ts_probe: snap_x %d-%d %d-%d, snap_y %d-%d %d-%d\n",
+	       snap_left_on, snap_left_off, snap_right_on, snap_right_off,
+	       snap_top_on, snap_top_off, snap_bottom_on, snap_bottom_off);
+	input_set_abs_params(ts->input_dev, ABS_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 15, fuzz_w, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, fuzz_w, 0);
+	/* ts->input_dev->name = ts->keypad_info->name; */
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		printk(KERN_ERR "synaptics_ts_probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	if (client->irq) {
+		ret = request_irq(client->irq, synaptics_ts_irq_handler, irqflags, client->name, ts);
+		if (ret == 0) {
+			ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+			if (ret)
+				free_irq(client->irq, ts);
+		}
+		if (ret == 0)
+			ts->use_irq = 1;
+		else
+			dev_err(&client->dev, "request_irq failed\n");
+	}
+	if (!ts->use_irq) {
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = synaptics_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = synaptics_ts_early_suspend;
+	ts->early_suspend.resume = synaptics_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	printk(KERN_INFO "synaptics_ts_probe: Start touchscreen %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+err_detect_failed:
+err_power_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int synaptics_ts_remove(struct i2c_client *client)
+{
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+	unregister_early_suspend(&ts->early_suspend);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->use_irq)
+		disable_irq(client->irq);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = cancel_work_sync(&ts->work);
+	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
+		enable_irq(client->irq);
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+
+	ret = i2c_smbus_write_byte_data(client, 0xf0, 0x86); /* deep sleep */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+	if (ts->power) {
+		ret = ts->power(0);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power off failed\n");
+	}
+	return 0;
+}
+
+static int synaptics_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power on failed\n");
+	}
+
+	synaptics_init_panel(ts);
+
+	if (ts->use_irq)
+		enable_irq(client->irq);
+
+	if (!ts->use_irq)
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	else
+		i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void synaptics_ts_late_resume(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_resume(ts->client);
+}
+#endif
+
+static const struct i2c_device_id synaptics_ts_id[] = {
+	{ SYNAPTICS_I2C_RMI_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver synaptics_ts_driver = {
+	.probe		= synaptics_ts_probe,
+	.remove		= synaptics_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= synaptics_ts_suspend,
+	.resume		= synaptics_ts_resume,
+#endif
+	.id_table	= synaptics_ts_id,
+	.driver = {
+		.name	= SYNAPTICS_I2C_RMI_NAME,
+	},
+};
+
+static int __devinit synaptics_ts_init(void)
+{
+	synaptics_wq = create_singlethread_workqueue("synaptics_wq");
+	if (!synaptics_wq)
+		return -ENOMEM;
+	return i2c_add_driver(&synaptics_ts_driver);
+}
+
+static void __exit synaptics_ts_exit(void)
+{
+	i2c_del_driver(&synaptics_ts_driver);
+	if (synaptics_wq)
+		destroy_workqueue(synaptics_wq);
+}
+
+module_init(synaptics_ts_init);
+module_exit(synaptics_ts_exit);
+
+MODULE_DESCRIPTION("Synaptics Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/ts-if.c tiny210/drivers/input/touchscreen/ts-if.c
--- linux-2.6.35.7/drivers/input/touchscreen/ts-if.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/touchscreen/ts-if.c	2012-02-21 17:46:09.000000000 +0800
@@ -0,0 +1,131 @@
+/*
+ * linux/drivers/input/touchscreen/ts-if.c
+ *
+ * Copyright (c) 2011 FriendlyARM (www.arm9.net)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+extern void mini210_get_lcd_res(int *w, int *h);
+
+#define S3C_TSVERSION	0x0101
+#define DEBUG_LVL		KERN_DEBUG
+
+static struct input_dev *input_dev;
+static char phys[] = "input(ts)";
+
+#define DEVICE_NAME		"ts-if"
+
+static long _ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned is_down;
+
+	is_down = (((unsigned)(arg)) >> 31);
+	if (is_down) {
+		unsigned x, y;
+
+		x = (arg >> 16) & 0x7FFF;
+		y = arg & 0x7FFF;
+		input_report_abs(input_dev, ABS_X, x);
+		input_report_abs(input_dev, ABS_Y, y);
+
+		input_report_key(input_dev, BTN_TOUCH, 1);
+		input_report_abs(input_dev, ABS_PRESSURE, 1);
+		input_sync(input_dev);
+	} else {
+		input_report_key(input_dev, BTN_TOUCH, 0);
+		input_report_abs(input_dev, ABS_PRESSURE, 0);
+		input_sync(input_dev);
+	}
+
+	return 0;
+}
+
+static struct file_operations dev_fops = {
+	.owner	= THIS_MODULE,
+	.unlocked_ioctl	= _ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor	= 185,
+	.name	= DEVICE_NAME,
+	.fops	= &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int width = 0, height = 0;
+	int ret;
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	mini210_get_lcd_res(&width, &height);
+	if (!width)
+		width = S3CFB_HRES;
+	if (!height)
+		height = S3CFB_VRES;
+	
+	input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input_dev, ABS_X, 0, width, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, height, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	input_dev->name = "fa_ts_input";
+	input_dev->phys = phys;
+	input_dev->id.bustype = BUS_RS232;
+	input_dev->id.vendor = 0xDEAD;
+	input_dev->id.product = 0xBEEF;
+	input_dev->id.version = S3C_TSVERSION;
+
+	/* All went ok, so register to the input system */
+	ret = input_register_device(input_dev);
+	if (ret) {
+		printk("ts-if: Could not register input device(touchscreen)!\n");
+		input_free_device(input_dev);
+		return ret;
+	}
+
+	ret = misc_register(&misc);
+	if (ret) {
+		input_unregister_device(input_dev);
+		input_free_device(input_dev);
+		return ret;
+	}
+
+	printk (DEVICE_NAME"\tinitialized\n");
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	input_unregister_device(input_dev);
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("MINI210 Touch Screen Interface Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.35.7/drivers/input/touchscreen/ts-s3c.c tiny210/drivers/input/touchscreen/ts-s3c.c
--- linux-2.6.35.7/drivers/input/touchscreen/ts-s3c.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/input/touchscreen/ts-s3c.c	2011-08-08 12:52:34.000000000 +0800
@@ -0,0 +1,543 @@
+/* linux/drivers/input/touchscreen/s3c-ts.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
+ * iPAQ H1940 touchscreen support
+ *
+ * ChangeLog
+ *
+ * 2004-09-05: Herbert Potzl <herbert@13thfloor.at>
+ *	- added clock (de-)allocation code
+ *
+ * 2005-03-06: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - h1940_ -> s3c24xx (this driver is now also used on the n30
+ *        machines :P)
+ *      - Debug messages are now enabled with the config option
+ *        TOUCHSCREEN_S3C_DEBUG
+ *      - Changed the way the value are read
+ *      - Input subsystem should now work
+ *      - Use ioremap and readl/writel
+ *
+ * 2005-03-23: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - Make use of some undocumented features of the touchscreen
+ *        controller
+ *
+ * 2006-09-05: Ryu Euiyoul <ryu.real@gmail.com>
+ *      - added power management suspend and resume code
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+
+#include <mach/regs-adc.h>
+#include <mach/ts-s3c.h>
+#include <mach/irqs.h>
+
+#define CONFIG_CPU_S5PV210_EVT1
+
+#ifdef CONFIG_CPU_S5PV210_EVT1
+#define X_COOR_MIN	100
+#define X_COOR_MAX	3980
+#define X_COOR_FUZZ	32
+#define Y_COOR_MIN	200
+#define Y_COOR_MAX	3760
+#define Y_COOR_FUZZ	32
+#endif
+
+/* For ts->dev.id.version */
+#define S3C_TSVERSION	0x0101
+
+#define WAIT4INT(x)	(((x)<<8) | \
+			S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | \
+			S3C_ADCTSC_XP_SEN | S3C_ADCTSC_XY_PST(3))
+
+#define AUTOPST	(S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | \
+		 S3C_ADCTSC_XP_SEN | S3C_ADCTSC_AUTO_PST | \
+		 S3C_ADCTSC_XY_PST(0))
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ts_early_suspend(struct early_suspend *h);
+static void ts_late_resume(struct early_suspend *h);
+#endif
+
+/* Touchscreen default configuration */
+struct s3c_ts_mach_info s3c_ts_default_cfg __initdata = {
+	.delay			= 10000,
+	.presc			= 49,
+	.oversampling_shift	= 2,
+	.resol_bit		= 10
+};
+
+/*
+ * Definitions & global arrays.
+ */
+static char *s3c_ts_name = "S5P TouchScreen";
+static void __iomem		*ts_base;
+static struct resource		*ts_mem;
+static struct resource		*ts_irq;
+static struct clk		*ts_clock;
+static struct s3c_ts_info	*ts;
+
+static void touch_timer_fire(unsigned long data)
+{
+	unsigned long data0;
+	unsigned long data1;
+	int updown;
+	int x, y;
+
+	data0 = readl(ts_base+S3C_ADCDAT0);
+	data1 = readl(ts_base+S3C_ADCDAT1);
+
+	updown = (!(data0 & S3C_ADCDAT0_UPDOWN)) &&
+		 (!(data1 & S3C_ADCDAT1_UPDOWN));
+
+	if (updown) {
+		if (ts->count) {
+			x = (int)ts->xp/ts->count;
+			y = (int)ts->yp/ts->count;
+#ifdef CONFIG_FB_S3C_LTE480WV
+			y = 4000 - y;
+#endif
+			input_report_abs(ts->dev, ABS_X, x);
+			input_report_abs(ts->dev, ABS_Y, y);
+			input_report_abs(ts->dev, ABS_Z, 0);
+			input_report_key(ts->dev, BTN_TOUCH, 1);
+			input_sync(ts->dev);
+		}
+
+		ts->xp = 0;
+		ts->yp = 0;
+		ts->count = 0;
+
+		writel(S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST,
+				ts_base + S3C_ADCTSC);
+		writel(readl(ts_base+S3C_ADCCON) | S3C_ADCCON_ENABLE_START,
+				ts_base + S3C_ADCCON);
+	} else {
+		ts->count = 0;
+		input_report_abs(ts->dev, ABS_X, ts->xp);
+		input_report_abs(ts->dev, ABS_Y, ts->yp);
+		input_report_abs(ts->dev, ABS_Z, 0);
+		input_report_key(ts->dev, BTN_TOUCH, 0);
+		input_sync(ts->dev);
+
+		writel(WAIT4INT(0), ts_base+S3C_ADCTSC);
+	}
+}
+
+static struct timer_list touch_timer =
+		TIMER_INITIALIZER(touch_timer_fire, 0, 0);
+
+static irqreturn_t stylus_updown(int irqno, void *param)
+{
+	unsigned long data0;
+	unsigned long data1;
+	int updown;
+
+	data0 = readl(ts_base + S3C_ADCDAT0);
+	data1 = readl(ts_base + S3C_ADCDAT1);
+
+	updown = (!(data0 & S3C_ADCDAT0_UPDOWN)) &&
+		 (!(data1 & S3C_ADCDAT1_UPDOWN));
+
+	/* TODO we should never get an interrupt with updown set while
+	 * the timer is running, but maybe we ought to verify that the
+	 * timer isn't running anyways. */
+
+	if (updown)
+		touch_timer_fire(0);
+
+	if (ts->s3c_adc_con == ADC_TYPE_2) {
+		__raw_writel(0x0, ts_base + S3C_ADCCLRWK);
+		__raw_writel(0x0, ts_base + S3C_ADCCLRINT);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stylus_action(int irqno, void *param)
+{
+	unsigned long data0;
+	unsigned long data1;
+
+	data0 = readl(ts_base + S3C_ADCDAT0);
+	data1 = readl(ts_base + S3C_ADCDAT1);
+
+	if (ts->resol_bit == 12) {
+#if defined(CONFIG_TOUCHSCREEN_NEW)
+		ts->yp += S3C_ADCDAT0_XPDATA_MASK_12BIT -
+			(data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT);
+		ts->xp += S3C_ADCDAT1_YPDATA_MASK_12BIT -
+			(data1 & S3C_ADCDAT1_YPDATA_MASK_12BIT);
+#else
+		ts->xp += S3C_ADCDAT0_XPDATA_MASK_12BIT -
+			(data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT);
+		ts->yp += data1 & S3C_ADCDAT1_YPDATA_MASK_12BIT;
+#endif
+	} else {
+#if defined(CONFIG_TOUCHSCREEN_NEW)
+		ts->yp += S3C_ADCDAT0_XPDATA_MASK -
+			(data0 & S3C_ADCDAT0_XPDATA_MASK);
+		ts->xp += S3C_ADCDAT1_YPDATA_MASK -
+			(data1 & S3C_ADCDAT1_YPDATA_MASK);
+#else
+		ts->xp += data0 & S3C_ADCDAT0_XPDATA_MASK;
+		ts->yp += data1 & S3C_ADCDAT1_YPDATA_MASK;
+#endif
+	}
+
+	ts->count++;
+
+	if (ts->count < (1<<ts->shift)) {
+		writel(S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST,
+				ts_base + S3C_ADCTSC);
+		writel(readl(ts_base + S3C_ADCCON) | S3C_ADCCON_ENABLE_START,
+				ts_base + S3C_ADCCON);
+	} else {
+		mod_timer(&touch_timer, jiffies + 1);
+		writel(WAIT4INT(1), ts_base + S3C_ADCTSC);
+	}
+
+	if (ts->s3c_adc_con == ADC_TYPE_2) {
+		__raw_writel(0x0, ts_base+S3C_ADCCLRWK);
+		__raw_writel(0x0, ts_base+S3C_ADCCLRINT);
+	}
+	return IRQ_HANDLED;
+}
+
+static struct s3c_ts_mach_info *s3c_ts_get_platdata(struct device *dev)
+{
+	if (dev->platform_data != NULL)
+		return (struct s3c_ts_mach_info *)dev->platform_data;
+
+	return &s3c_ts_default_cfg;
+}
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+static int __init s3c_ts_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev;
+	struct input_dev *input_dev;
+	struct s3c_ts_mach_info *s3c_ts_cfg;
+	int ret, size;
+	int irq_flags = 0;
+
+	dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(dev, "no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+	ts_mem = request_mem_region(res->start, size, pdev->name);
+	if (ts_mem == NULL) {
+		dev_err(dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+
+	ts_base = ioremap(res->start, size);
+	if (ts_base == NULL) {
+		dev_err(dev, "failed to ioremap() region\n");
+		ret = -EINVAL;
+		goto err_map;
+	}
+
+	ts_clock = clk_get(&pdev->dev, "adc");
+	if (IS_ERR(ts_clock)) {
+		dev_err(dev, "failed to find watchdog clock source\n");
+		ret = PTR_ERR(ts_clock);
+		goto err_clk;
+	}
+
+	clk_enable(ts_clock);
+
+	s3c_ts_cfg = s3c_ts_get_platdata(&pdev->dev);
+	if ((s3c_ts_cfg->presc & 0xff) > 0)
+		writel(S3C_ADCCON_PRSCEN |
+				S3C_ADCCON_PRSCVL(s3c_ts_cfg->presc & 0xFF),
+				ts_base+S3C_ADCCON);
+	else
+		writel(0, ts_base + S3C_ADCCON);
+
+	/* Initialise registers */
+	if ((s3c_ts_cfg->delay & 0xffff) > 0)
+		writel(s3c_ts_cfg->delay & 0xffff, ts_base + S3C_ADCDLY);
+
+	if (s3c_ts_cfg->resol_bit == 12) {
+		switch (s3c_ts_cfg->s3c_adc_con) {
+		case ADC_TYPE_2:
+			writel(readl(ts_base + S3C_ADCCON) |
+					S3C_ADCCON_RESSEL_12BIT,
+					ts_base + S3C_ADCCON);
+			break;
+
+		case ADC_TYPE_1:
+			writel(readl(ts_base + S3C_ADCCON) |
+					S3C_ADCCON_RESSEL_12BIT_1,
+					ts_base + S3C_ADCCON);
+			break;
+
+		default:
+			dev_err(dev, "this type of AP isn't supported !\n");
+			break;
+		}
+	}
+
+	writel(WAIT4INT(0), ts_base + S3C_ADCTSC);
+
+	ts = kzalloc(sizeof(struct s3c_ts_info), GFP_KERNEL);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+
+	ts->dev = input_dev;
+
+	ts->dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	ts->dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	if (s3c_ts_cfg->resol_bit == 12) {
+		input_set_abs_params(ts->dev,
+				ABS_X, X_COOR_MIN, X_COOR_MAX, X_COOR_FUZZ, 0);
+		input_set_abs_params(ts->dev,
+				ABS_Y, Y_COOR_MIN, Y_COOR_MAX, Y_COOR_FUZZ, 0);
+	} else {
+		input_set_abs_params(ts->dev, ABS_X, 0, 0x3FF, 0, 0);
+		input_set_abs_params(ts->dev, ABS_Y, 0, 0x3FF, 0, 0);
+	}
+
+	input_set_abs_params(ts->dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	sprintf(ts->phys, "input(ts)");
+
+	ts->dev->name = s3c_ts_name;
+	ts->dev->phys = ts->phys;
+	ts->dev->id.bustype = BUS_RS232;
+	ts->dev->id.vendor = 0xDEAD;
+	ts->dev->id.product = 0xBEEF;
+	ts->dev->id.version = S3C_TSVERSION;
+
+	ts->shift = s3c_ts_cfg->oversampling_shift;
+	ts->resol_bit = s3c_ts_cfg->resol_bit;
+	ts->s3c_adc_con = s3c_ts_cfg->s3c_adc_con;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = ts_early_suspend;
+	ts->early_suspend.resume = ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	/* For IRQ_PENDUP */
+	ts_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (ts_irq == NULL) {
+		dev_err(dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+
+	ret = request_irq(ts_irq->start, stylus_updown, irq_flags,
+			"s3c_updown", ts);
+	if (ret != 0) {
+		dev_err(dev, "s3c_ts.c: Could not allocate ts IRQ_PENDN !\n");
+		ret = -EIO;
+		goto err_irq;
+	}
+
+	/* For IRQ_ADC */
+	ts_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (ts_irq == NULL) {
+		dev_err(dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+
+	ret = request_irq(ts_irq->start, stylus_action, irq_flags,
+			"s3c_action", ts);
+	if (ret != 0) {
+		dev_err(dev, "s3c_ts.c: Could not allocate ts IRQ_ADC !\n");
+		ret =  -EIO;
+		goto err_irq;
+	}
+
+	printk(KERN_INFO "%s got loaded successfully : %d bits\n",
+			s3c_ts_name, s3c_ts_cfg->resol_bit);
+
+	/* All went ok, so register to the input system */
+	ret = input_register_device(ts->dev);
+	if (ret) {
+		dev_err(dev, "Could not register input device(touchscreen)!\n");
+		ret = -EIO;
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	free_irq(ts_irq->start, ts->dev);
+	free_irq(ts_irq->end, ts->dev);
+
+err_irq:
+	input_free_device(input_dev);
+	kfree(ts);
+
+err_alloc:
+	clk_disable(ts_clock);
+	clk_put(ts_clock);
+
+err_clk:
+	iounmap(ts_base);
+
+err_map:
+	release_resource(ts_mem);
+	kfree(ts_mem);
+
+err_req:
+	return ret;
+}
+
+static int s3c_ts_remove(struct platform_device *dev)
+{
+	printk(KERN_INFO "s3c_ts_remove() of TS called !\n");
+
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_PENDN);
+
+	free_irq(IRQ_PENDN, ts->dev);
+	free_irq(IRQ_ADC, ts->dev);
+
+	if (ts_clock) {
+		clk_disable(ts_clock);
+		clk_put(ts_clock);
+		ts_clock = NULL;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+     unregister_early_suspend(&ts->early_suspend);
+#endif
+
+	input_unregister_device(ts->dev);
+	iounmap(ts_base);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static unsigned int adccon, adctsc, adcdly;
+
+static int s3c_ts_suspend(struct platform_device *dev, pm_message_t state)
+{
+	adccon = readl(ts_base+S3C_ADCCON);
+	adctsc = readl(ts_base+S3C_ADCTSC);
+	adcdly = readl(ts_base+S3C_ADCDLY);
+
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_PENDN);
+
+	clk_disable(ts_clock);
+
+	return 0;
+}
+
+static int s3c_ts_resume(struct platform_device *pdev)
+{
+	clk_enable(ts_clock);
+
+	writel(adccon, ts_base+S3C_ADCCON);
+	writel(adctsc, ts_base+S3C_ADCTSC);
+	writel(adcdly, ts_base+S3C_ADCDLY);
+	writel(WAIT4INT(0), ts_base+S3C_ADCTSC);
+
+	enable_irq(IRQ_ADC);
+	enable_irq(IRQ_PENDN);
+
+	return 0;
+}
+#else
+#define s3c_ts_suspend NULL
+#define s3c_ts_resume  NULL
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ts_early_suspend(struct early_suspend *h)
+{
+	struct s3c_ts_info *ts;
+	ts = container_of(h, struct s3c_ts_info, early_suspend);
+	s3c_ts_suspend(NULL, PMSG_SUSPEND);
+}
+
+static void ts_late_resume(struct early_suspend *h)
+{
+	struct s3c_ts_info *ts;
+	ts = container_of(h, struct s3c_ts_info, early_suspend);
+	s3c_ts_resume(NULL);
+}
+#endif
+
+static struct platform_driver s3c_ts_driver = {
+       .probe          = s3c_ts_probe,
+       .remove         = s3c_ts_remove,
+       .suspend        = s3c_ts_suspend,
+       .resume         = s3c_ts_resume,
+       .driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-ts",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO \
+		"S5P Touchscreen driver, (c) 2008 Samsung Electronics\n";
+
+static int __init s3c_ts_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_ts_driver);
+}
+
+static void __exit s3c_ts_exit(void)
+{
+	platform_driver_unregister(&s3c_ts_driver);
+}
+
+module_init(s3c_ts_init);
+module_exit(s3c_ts_exit);
+
+MODULE_AUTHOR("Samsung AP");
+MODULE_DESCRIPTION("S5P touchscreen driver");
+MODULE_LICENSE("GPL");
