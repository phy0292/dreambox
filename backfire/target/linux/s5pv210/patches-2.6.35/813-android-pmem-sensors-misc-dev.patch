diff -Nur linux-2.6.35.7/drivers/misc/ak8973.c tiny210/drivers/misc/ak8973.c
--- linux-2.6.35.7/drivers/misc/ak8973.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/ak8973.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,408 @@
+/*
+ * ak8973.c - ak8973 compass driver
+ *
+ * Copyright (C) 2008-2009 HTC Corporation.
+ * Author: viral wang <viralwang@gmail.com>
+ *
+ * Copyright (C) 2010 Samsung Electronics. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c/ak8973.h>
+#include <linux/completion.h>
+#include "ak8973-reg.h"
+
+#define AK8973DRV_DATA_DBG 0
+
+struct akm8973_data {
+	struct i2c_client *this_client;
+	struct akm8973_platform_data *pdata;
+	struct mutex lock;
+	struct miscdevice akmd_device;
+	int irq;
+	struct completion data_ready;
+	wait_queue_head_t state_wq;
+};
+
+static s32 akm8973_ecs_set_mode_power_down(struct akm8973_data *akm)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(akm->this_client,
+			AK8973_REG_MS1, AK8973_MODE_POWERDOWN);
+	if (ret < 0)
+		return ret;
+
+	return i2c_smbus_read_byte_data(akm->this_client, AK8973_REG_TMPS);
+}
+
+static int akm8973_ecs_set_mode(struct akm8973_data *akm, char mode)
+{
+	s32 ret;
+
+	switch (mode) {
+	case AK8973_MODE_MEASURE:
+		ret = i2c_smbus_write_byte_data(akm->this_client,
+				AK8973_REG_MS1, AK8973_MODE_MEASURE);
+		break;
+	case AK8973_MODE_E2P_READ:
+		ret = i2c_smbus_write_byte_data(akm->this_client,
+				AK8973_REG_MS1, AK8973_MODE_E2P_READ);
+		break;
+	case AK8973_MODE_POWERDOWN:
+		ret = akm8973_ecs_set_mode_power_down(akm);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0)
+		return ret;
+
+	/* Wait at least 300us after changing mode. */
+	udelay(300);
+
+	return 0;
+}
+
+static void akm8973_reset(struct akm8973_data *akm)
+{
+	gpio_set_value(akm->pdata->reset_line, akm->pdata->reset_asserted);
+	msleep(2);
+	gpio_set_value(akm->pdata->reset_line, !akm->pdata->reset_asserted);
+}
+
+static int akmd_copy_in(unsigned int cmd, void __user *argp,
+			void *buf, size_t buf_size)
+{
+	if (!(cmd & IOC_IN))
+		return 0;
+	if (_IOC_SIZE(cmd) > buf_size)
+		return -EINVAL;
+	if (copy_from_user(buf, argp, _IOC_SIZE(cmd)))
+		return -EFAULT;
+	return 0;
+}
+
+static int akmd_copy_out(unsigned int cmd, void __user *argp,
+			 void *buf, size_t buf_size)
+{
+	if (!(cmd & IOC_OUT))
+		return 0;
+	if (_IOC_SIZE(cmd) > buf_size)
+		return -EINVAL;
+	if (copy_to_user(argp, buf, _IOC_SIZE(cmd)))
+		return -EFAULT;
+	return 0;
+}
+
+static void akm8973_disable_irq(struct akm8973_data *akm)
+{
+	disable_irq(akm->irq);
+	if (try_wait_for_completion(&akm->data_ready)) {
+		/* we actually got the interrupt before we could disable it
+		 * so we need to enable again to undo our disable since the
+		 * irq_handler already disabled it
+		 */
+		enable_irq(akm->irq);
+	}
+}
+
+static irqreturn_t akm8973_irq_handler(int irq, void *data)
+{
+	struct akm8973_data *akm = data;
+	disable_irq_nosync(irq);
+	complete(&akm->data_ready);
+	return IRQ_HANDLED;
+}
+
+static int akm8973_wait_for_data_ready(struct akm8973_data *akm)
+{
+	int data_ready = gpio_get_value(akm->pdata->gpio_data_ready_int);
+	int err;
+
+	if (data_ready)
+		return 0;
+
+	enable_irq(akm->irq);
+
+	err = wait_for_completion_timeout(&akm->data_ready, 5*HZ);
+	if (err > 0)
+		return 0;
+
+	akm8973_disable_irq(akm);
+
+	if (err == 0) {
+		pr_err("akm: wait timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	pr_err("akm: wait restart\n");
+	return err;
+}
+
+static int akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct akm8973_data *akm = container_of(file->private_data,
+			struct akm8973_data, akmd_device);
+	int ret;
+	union {
+		char raw[RWBUF_SIZE];
+		int status;
+		char mode;
+		u8 data[5];
+	} rwbuf;
+
+	ret = akmd_copy_in(cmd, argp, rwbuf.raw, sizeof(rwbuf));
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case ECS_IOCTL_WRITE:
+		if ((rwbuf.raw[0] < 2) || (rwbuf.raw[0] > (RWBUF_SIZE - 1)))
+			return -EINVAL;
+		if (copy_from_user(&rwbuf.raw[2], argp+2, rwbuf.raw[0]-1))
+			return -EFAULT;
+
+		ret = i2c_smbus_write_i2c_block_data(akm->this_client,
+						     rwbuf.raw[1],
+						     rwbuf.raw[0] - 1,
+						     &rwbuf.raw[2]);
+		break;
+	case ECS_IOCTL_READ:
+		if ((rwbuf.raw[0] < 1) || (rwbuf.raw[0] > (RWBUF_SIZE - 1)))
+			return -EINVAL;
+
+		ret = i2c_smbus_read_i2c_block_data(akm->this_client,
+						    rwbuf.raw[1],
+						    rwbuf.raw[0],
+						    &rwbuf.raw[1]);
+		if (ret < 0)
+			return ret;
+		if (copy_to_user(argp, rwbuf.raw+1, rwbuf.raw[0]))
+			return -EFAULT;
+		return 0;
+	case ECS_IOCTL_RESET:
+		akm8973_reset(akm);
+		break;
+	case ECS_IOCTL_SET_MODE:
+		ret = akm8973_ecs_set_mode(akm, rwbuf.mode);
+		break;
+	case ECS_IOCTL_GETDATA:
+		ret = akm8973_wait_for_data_ready(akm);
+		if (ret)
+			return ret;
+		ret = i2c_smbus_read_i2c_block_data(akm->this_client,
+						    AK8973_REG_ST,
+						    sizeof(rwbuf.data),
+						    rwbuf.data);
+		if (ret != sizeof(rwbuf.data)) {
+			pr_err("%s : failed to read %d bytes of mag data\n",
+			       __func__, sizeof(rwbuf.data));
+			return -EIO;
+		}
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return akmd_copy_out(cmd, argp, rwbuf.raw, sizeof(rwbuf));
+}
+
+static const struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = nonseekable_open,
+	.ioctl = akmd_ioctl,
+};
+
+static int akm8973_setup_irq(struct akm8973_data *akm)
+{
+	int rc = -EIO;
+	struct akm8973_platform_data *pdata = akm->pdata;
+	int irq;
+
+	rc = gpio_request(pdata->gpio_data_ready_int, "gpio_akm_int");
+	if (rc < 0) {
+		pr_err("%s: gpio %d request failed (%d)\n",
+			__func__, pdata->gpio_data_ready_int, rc);
+		return rc;
+	}
+
+	rc = gpio_direction_input(pdata->gpio_data_ready_int);
+	if (rc < 0) {
+		pr_err("%s: failed to set gpio %d as input (%d)\n",
+			__func__, pdata->gpio_data_ready_int, rc);
+		goto err_gpio_direction_input;
+	}
+
+	irq = gpio_to_irq(pdata->gpio_data_ready_int);
+
+	/* trigger high so we don't miss initial interrupt if it
+	 * is already pending
+	 */
+	rc = request_irq(irq, akm8973_irq_handler, IRQF_TRIGGER_HIGH,
+			 "akm_int", akm);
+	if (rc < 0) {
+		pr_err("%s: request_irq(%d) failed for gpio %d (%d)\n",
+			__func__, irq,
+			pdata->gpio_data_ready_int, rc);
+		goto err_request_irq;
+	}
+
+	/* start with interrupt disabled until the driver is enabled */
+	akm->irq = irq;
+	akm8973_disable_irq(akm);
+
+	goto done;
+
+err_request_irq:
+err_gpio_direction_input:
+	gpio_free(pdata->gpio_data_ready_int);
+done:
+	return rc;
+}
+
+int akm8973_probe(struct i2c_client *client,
+		const struct i2c_device_id *devid)
+{
+	struct akm8973_data *akm;
+	int err;
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit_platform_data_null;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "I2C check failed, exiting.\n");
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	akm = kzalloc(sizeof(struct akm8973_data), GFP_KERNEL);
+	if (!akm) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	akm->pdata = client->dev.platform_data;
+	mutex_init(&akm->lock);
+	init_completion(&akm->data_ready);
+
+	i2c_set_clientdata(client, akm);
+	akm->this_client = client;
+
+	err = gpio_request(akm->pdata->reset_line, "AK8973 Reset Line");
+	if (err < 0)
+		goto exit_reset_gpio_request_failed;
+	gpio_direction_output(akm->pdata->reset_line,
+			!akm->pdata->reset_asserted);
+	akm8973_reset(akm);
+
+	err = akm8973_ecs_set_mode_power_down(akm);
+	if (err < 0)
+		goto exit_set_mode_power_down_failed;
+
+	err = akm8973_setup_irq(akm);
+	if (err) {
+		pr_err("%s: could not setup irq\n", __func__);
+		goto exit_setup_irq;
+	}
+
+	akm->akmd_device.minor = MISC_DYNAMIC_MINOR;
+	akm->akmd_device.name = "akm8973";
+	akm->akmd_device.fops = &akmd_fops;
+
+	err = misc_register(&akm->akmd_device);
+	if (err)
+		goto exit_akmd_device_register_failed;
+
+	init_waitqueue_head(&akm->state_wq);
+
+	return 0;
+
+exit_akmd_device_register_failed:
+	free_irq(akm->irq, akm);
+	gpio_free(akm->pdata->gpio_data_ready_int);
+exit_setup_irq:
+exit_set_mode_power_down_failed:
+	gpio_direction_input(akm->pdata->reset_line);
+	gpio_free(akm->pdata->reset_line);
+exit_reset_gpio_request_failed:
+	mutex_destroy(&akm->lock);
+	kfree(akm);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+exit_platform_data_null:
+	return err;
+}
+
+static int __devexit akm8973_remove(struct i2c_client *client)
+{
+	struct akm8973_data *akm = i2c_get_clientdata(client);
+
+	misc_deregister(&akm->akmd_device);
+	gpio_direction_input(akm->pdata->reset_line);
+	gpio_free(akm->pdata->reset_line);
+	free_irq(akm->irq, akm);
+	gpio_free(akm->pdata->gpio_data_ready_int);
+	mutex_destroy(&akm->lock);
+	kfree(akm);
+	return 0;
+}
+
+static const struct i2c_device_id akm8973_id[] = {
+	{AKM8973_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver akm8973_driver = {
+	.probe		= akm8973_probe,
+	.remove		= akm8973_remove,
+	.id_table	= akm8973_id,
+	.driver = {
+		.name = AKM8973_I2C_NAME,
+	},
+};
+
+static int __init akm8973_init(void)
+{
+	return i2c_add_driver(&akm8973_driver);
+}
+
+static void __exit akm8973_exit(void)
+{
+	i2c_del_driver(&akm8973_driver);
+}
+
+module_init(akm8973_init);
+module_exit(akm8973_exit);
+
+MODULE_DESCRIPTION("AKM8973 compass driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/ak8973-reg.h tiny210/drivers/misc/ak8973-reg.h
--- linux-2.6.35.7/drivers/misc/ak8973-reg.h	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/ak8973-reg.h	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,47 @@
+/* linux/drivers/misc/ak8973-reg.h
+ *
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#ifndef __AK8973_REG__
+#define __AK8983_REG__
+
+/* Compass device dependent definition */
+#define AK8973_MODE_MEASURE		0x00	/* Starts measurement. */
+#define AK8973_MODE_E2P_READ		0x02	/* E2P access mode (read). */
+#define AK8973_MODE_POWERDOWN		0x03	/* Power down mode */
+
+/* Rx buffer size. i.e ST,TMPS,H1X,H1Y,H1Z*/
+#define SENSOR_DATA_SIZE		5
+
+/* Read/Write buffer size.*/
+#define RWBUF_SIZE			16
+
+/* AK8973 register address */
+#define AK8973_REG_ST			0xC0
+#define AK8973_REG_TMPS			0xC1
+#define AK8973_REG_H1X			0xC2
+#define AK8973_REG_H1Y			0xC3
+#define AK8973_REG_H1Z			0xC4
+
+#define AK8973_REG_MS1			0xE0
+#define AK8973_REG_HXDA			0xE1
+#define AK8973_REG_HYDA			0xE2
+#define AK8973_REG_HZDA			0xE3
+#define AK8973_REG_HXGA			0xE4
+#define AK8973_REG_HYGA			0xE5
+#define AK8973_REG_HZGA			0xE6
+
+#define AK8973_EEP_ETS			0x62
+#define AK8973_EEP_EVIR			0x63
+#define AK8973_EEP_EIHE			0x64
+#define AK8973_EEP_ETST			0x65
+#define AK8973_EEP_EHXGA		0x66
+#define AK8973_EEP_EHYGA		0x67
+#define AK8973_EEP_EHZGA		0x68
+
+#endif /* __AK8983_REG__ */
diff -Nur linux-2.6.35.7/drivers/misc/akm8975.c tiny210/drivers/misc/akm8975.c
--- linux-2.6.35.7/drivers/misc/akm8975.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/akm8975.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,732 @@
+/* drivers/misc/akm8975.c - akm8975 compass driver
+ *
+ * Copyright (C) 2007-2008 HTC Corporation.
+ * Author: Hou-Kun Chen <houkun.chen@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*
+ * Revised by AKM 2009/04/02
+ * Revised by Motorola 2010/05/27
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <linux/akm8975.h>
+#include <linux/earlysuspend.h>
+
+#define AK8975DRV_CALL_DBG 0
+#if AK8975DRV_CALL_DBG
+#define FUNCDBG(msg)	pr_err("%s:%s\n", __func__, msg);
+#else
+#define FUNCDBG(msg)
+#endif
+
+#define AK8975DRV_DATA_DBG 0
+#define MAX_FAILURE_COUNT 10
+
+struct akm8975_data {
+	struct i2c_client *this_client;
+	struct akm8975_platform_data *pdata;
+	struct input_dev *input_dev;
+	struct work_struct work;
+	struct mutex flags_lock;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+/*
+* Because misc devices can not carry a pointer from driver register to
+* open, we keep this global. This limits the driver to a single instance.
+*/
+struct akm8975_data *akmd_data;
+
+static DECLARE_WAIT_QUEUE_HEAD(open_wq);
+
+static atomic_t open_flag;
+
+static short m_flag;
+static short a_flag;
+static short t_flag;
+static short mv_flag;
+
+static short akmd_delay;
+
+static ssize_t akm8975_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	return sprintf(buf, "%u\n", i2c_smbus_read_byte_data(client,
+							     AK8975_REG_CNTL));
+}
+static ssize_t akm8975_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val;
+	strict_strtoul(buf, 10, &val);
+	if (val > 0xff)
+		return -EINVAL;
+	i2c_smbus_write_byte_data(client, AK8975_REG_CNTL, val);
+	return count;
+}
+static DEVICE_ATTR(akm_ms1, S_IWUSR | S_IRUGO, akm8975_show, akm8975_store);
+
+static int akm8975_i2c_rxdata(struct akm8975_data *akm, char *buf, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+			.addr = akm->this_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = buf,
+		},
+		{
+			.addr = akm->this_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = buf,
+		},
+	};
+
+	FUNCDBG("called");
+
+	if (i2c_transfer(akm->this_client->adapter, msgs, 2) < 0) {
+		pr_err("akm8975_i2c_rxdata: transfer error\n");
+		return EIO;
+	} else
+		return 0;
+}
+
+static int akm8975_i2c_txdata(struct akm8975_data *akm, char *buf, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+			.addr = akm->this_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = buf,
+		},
+	};
+
+	FUNCDBG("called");
+
+	if (i2c_transfer(akm->this_client->adapter, msgs, 1) < 0) {
+		pr_err("akm8975_i2c_txdata: transfer error\n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static void akm8975_ecs_report_value(struct akm8975_data *akm, short *rbuf)
+{
+	struct akm8975_data *data = i2c_get_clientdata(akm->this_client);
+
+	FUNCDBG("called");
+
+#if AK8975DRV_DATA_DBG
+	pr_info("akm8975_ecs_report_value: yaw = %d, pitch = %d, roll = %d\n",
+				 rbuf[0], rbuf[1], rbuf[2]);
+	pr_info("tmp = %d, m_stat= %d, g_stat=%d\n", rbuf[3], rbuf[4], rbuf[5]);
+	pr_info("Acceleration:	 x = %d LSB, y = %d LSB, z = %d LSB\n",
+				 rbuf[6], rbuf[7], rbuf[8]);
+	pr_info("Magnetic:	 x = %d LSB, y = %d LSB, z = %d LSB\n\n",
+				 rbuf[9], rbuf[10], rbuf[11]);
+#endif
+	mutex_lock(&akm->flags_lock);
+	/* Report magnetic sensor information */
+	if (m_flag) {
+		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
+		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
+		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
+		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
+	}
+
+	/* Report acceleration sensor information */
+	if (a_flag) {
+		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
+		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
+		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
+		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
+	}
+
+	/* Report temperature information */
+	if (t_flag)
+		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
+
+	if (mv_flag) {
+		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
+	}
+	mutex_unlock(&akm->flags_lock);
+
+	input_sync(data->input_dev);
+}
+
+static void akm8975_ecs_close_done(struct akm8975_data *akm)
+{
+	FUNCDBG("called");
+	mutex_lock(&akm->flags_lock);
+	m_flag = 1;
+	a_flag = 1;
+	t_flag = 1;
+	mv_flag = 1;
+	mutex_unlock(&akm->flags_lock);
+}
+
+static int akm_aot_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+
+	FUNCDBG("called");
+	if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+		wake_up(&open_wq);
+		ret = 0;
+	}
+
+	ret = nonseekable_open(inode, file);
+	if (ret)
+		return ret;
+
+	file->private_data = akmd_data;
+
+	return ret;
+}
+
+static int akm_aot_release(struct inode *inode, struct file *file)
+{
+	FUNCDBG("called");
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	return 0;
+}
+
+static int akm_aot_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *) arg;
+	short flag;
+	struct akm8975_data *akm = file->private_data;
+
+	FUNCDBG("called");
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+	case ECS_IOCTL_APP_SET_AFLAG:
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	mutex_lock(&akm->flags_lock);
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+	  m_flag = flag;
+		break;
+	case ECS_IOCTL_APP_GET_MFLAG:
+		flag = m_flag;
+		break;
+	case ECS_IOCTL_APP_SET_AFLAG:
+		a_flag = flag;
+		break;
+	case ECS_IOCTL_APP_GET_AFLAG:
+		flag = a_flag;
+		break;
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		mv_flag = flag;
+		break;
+	case ECS_IOCTL_APP_GET_MVFLAG:
+		flag = mv_flag;
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		akmd_delay = flag;
+		break;
+	case ECS_IOCTL_APP_GET_DELAY:
+		flag = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+	mutex_unlock(&akm->flags_lock);
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_GET_MFLAG:
+	case ECS_IOCTL_APP_GET_AFLAG:
+	case ECS_IOCTL_APP_GET_MVFLAG:
+	case ECS_IOCTL_APP_GET_DELAY:
+		if (copy_to_user(argp, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int akmd_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+
+	FUNCDBG("called");
+	err = nonseekable_open(inode, file);
+	if (err)
+		return err;
+
+	file->private_data = akmd_data;
+	return 0;
+}
+
+static int akmd_release(struct inode *inode, struct file *file)
+{
+	struct akm8975_data *akm = file->private_data;
+
+	FUNCDBG("called");
+	akm8975_ecs_close_done(akm);
+	return 0;
+}
+
+static int akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		      unsigned long arg)
+{
+	void __user *argp = (void __user *) arg;
+
+	char rwbuf[16];
+	int ret = -1;
+	int status;
+	short value[12];
+	short delay;
+	struct akm8975_data *akm = file->private_data;
+
+	FUNCDBG("called");
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+	case ECS_IOCTL_WRITE:
+		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+
+	case ECS_IOCTL_SET_YPR:
+		if (copy_from_user(&value, argp, sizeof(value)))
+			return -EFAULT;
+		break;
+
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		if (rwbuf[0] < 1)
+			return -EINVAL;
+
+		ret = akm8975_i2c_rxdata(akm, &rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+
+	case ECS_IOCTL_WRITE:
+		if (rwbuf[0] < 2)
+			return -EINVAL;
+
+		ret = akm8975_i2c_txdata(akm, &rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		akm8975_ecs_report_value(akm, value);
+		break;
+
+	case ECS_IOCTL_GET_OPEN_STATUS:
+		wait_event_interruptible(open_wq,
+					 (atomic_read(&open_flag) != 0));
+		status = atomic_read(&open_flag);
+		break;
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		wait_event_interruptible(open_wq,
+					 (atomic_read(&open_flag) == 0));
+		status = atomic_read(&open_flag);
+		break;
+
+	case ECS_IOCTL_GET_DELAY:
+		delay = akmd_delay;
+		break;
+
+	default:
+		FUNCDBG("Unknown cmd\n");
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		if (copy_to_user(argp, &status, sizeof(status)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		if (copy_to_user(argp, &delay, sizeof(delay)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/* needed to clear the int. pin */
+static void akm_work_func(struct work_struct *work)
+{
+	struct akm8975_data *akm =
+	    container_of(work, struct akm8975_data, work);
+
+	FUNCDBG("called");
+	enable_irq(akm->this_client->irq);
+}
+
+static irqreturn_t akm8975_interrupt(int irq, void *dev_id)
+{
+	struct akm8975_data *akm = dev_id;
+	FUNCDBG("called");
+
+	disable_irq_nosync(akm->this_client->irq);
+	schedule_work(&akm->work);
+	return IRQ_HANDLED;
+}
+
+static int akm8975_power_off(struct akm8975_data *akm)
+{
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	if (akm->pdata->power_off)
+		akm->pdata->power_off();
+
+	return 0;
+}
+
+static int akm8975_power_on(struct akm8975_data *akm)
+{
+	int err;
+
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	if (akm->pdata->power_on) {
+		err = akm->pdata->power_on();
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int akm8975_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct akm8975_data *akm = i2c_get_clientdata(client);
+
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	/* TO DO: might need more work after power mgmt
+	   is enabled */
+	return akm8975_power_off(akm);
+}
+
+static int akm8975_resume(struct i2c_client *client)
+{
+	struct akm8975_data *akm = i2c_get_clientdata(client);
+
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	/* TO DO: might need more work after power mgmt
+	   is enabled */
+	return akm8975_power_on(akm);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void akm8975_early_suspend(struct early_suspend *handler)
+{
+	struct akm8975_data *akm;
+	akm = container_of(handler, struct akm8975_data, early_suspend);
+
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	akm8975_suspend(akm->this_client, PMSG_SUSPEND);
+}
+
+static void akm8975_early_resume(struct early_suspend *handler)
+{
+	struct akm8975_data *akm;
+	akm = container_of(handler, struct akm8975_data, early_suspend);
+
+#if AK8975DRV_CALL_DBG
+	pr_info("%s\n", __func__);
+#endif
+	akm8975_resume(akm->this_client);
+}
+#endif
+
+
+static int akm8975_init_client(struct i2c_client *client)
+{
+	struct akm8975_data *data;
+	int ret;
+
+	data = i2c_get_clientdata(client);
+
+	ret = request_irq(client->irq, akm8975_interrupt, IRQF_TRIGGER_RISING,
+				"akm8975", data);
+
+	if (ret < 0) {
+		pr_err("akm8975_init_client: request irq failed\n");
+		goto err;
+	}
+
+	init_waitqueue_head(&open_wq);
+
+	mutex_lock(&data->flags_lock);
+	m_flag = 1;
+	a_flag = 1;
+	t_flag = 1;
+	mv_flag = 1;
+	mutex_unlock(&data->flags_lock);
+
+	return 0;
+err:
+  return ret;
+}
+
+static const struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = akmd_open,
+	.release = akmd_release,
+	.ioctl = akmd_ioctl,
+};
+
+static const struct file_operations akm_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_aot_open,
+	.release = akm_aot_release,
+	.ioctl = akm_aot_ioctl,
+};
+
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8975_aot",
+	.fops = &akm_aot_fops,
+};
+
+static struct miscdevice akmd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8975_dev",
+	.fops = &akmd_fops,
+};
+
+int akm8975_probe(struct i2c_client *client,
+		  const struct i2c_device_id *devid)
+{
+	struct akm8975_data *akm;
+	int err;
+	FUNCDBG("called");
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit_platform_data_null;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	akm = kzalloc(sizeof(struct akm8975_data), GFP_KERNEL);
+	if (!akm) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	akm->pdata = client->dev.platform_data;
+
+	mutex_init(&akm->flags_lock);
+	INIT_WORK(&akm->work, akm_work_func);
+	i2c_set_clientdata(client, akm);
+
+	err = akm8975_power_on(akm);
+	if (err < 0)
+		goto exit_power_on_failed;
+
+	akm8975_init_client(client);
+	akm->this_client = client;
+	akmd_data = akm;
+
+	akm->input_dev = input_allocate_device();
+	if (!akm->input_dev) {
+		err = -ENOMEM;
+		dev_err(&akm->this_client->dev,
+			"input device allocate failed\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	set_bit(EV_ABS, akm->input_dev->evbit);
+
+	/* yaw */
+	input_set_abs_params(akm->input_dev, ABS_RX, 0, 23040, 0, 0);
+	/* pitch */
+	input_set_abs_params(akm->input_dev, ABS_RY, -11520, 11520, 0, 0);
+	/* roll */
+	input_set_abs_params(akm->input_dev, ABS_RZ, -5760, 5760, 0, 0);
+	/* x-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_X, -5760, 5760, 0, 0);
+	/* y-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Y, -5760, 5760, 0, 0);
+	/* z-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Z, -5760, 5760, 0, 0);
+	/* temparature */
+	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	/* status of magnetic sensor */
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, 0, 3, 0, 0);
+	/* status of acceleration sensor */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, 0, 3, 0, 0);
+	/* x-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0X, -20480, 20479, 0, 0);
+	/* y-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -20480, 20479, 0, 0);
+	/* z-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_BRAKE, -20480, 20479, 0, 0);
+
+	akm->input_dev->name = "compass";
+
+	err = input_register_device(akm->input_dev);
+	if (err) {
+		pr_err("akm8975_probe: Unable to register input device: %s\n",
+					 akm->input_dev->name);
+		goto exit_input_register_device_failed;
+	}
+
+	err = misc_register(&akmd_device);
+	if (err) {
+		pr_err("akm8975_probe: akmd_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = misc_register(&akm_aot_device);
+	if (err) {
+		pr_err("akm8975_probe: akm_aot_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_akm_ms1);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	akm->early_suspend.suspend = akm8975_early_suspend;
+	akm->early_suspend.resume = akm8975_early_resume;
+	register_early_suspend(&akm->early_suspend);
+#endif
+	return 0;
+
+exit_misc_device_register_failed:
+exit_input_register_device_failed:
+	input_free_device(akm->input_dev);
+exit_input_dev_alloc_failed:
+	akm8975_power_off(akm);
+exit_power_on_failed:
+	kfree(akm);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+exit_platform_data_null:
+	return err;
+}
+
+static int __devexit akm8975_remove(struct i2c_client *client)
+{
+	struct akm8975_data *akm = i2c_get_clientdata(client);
+	FUNCDBG("called");
+	free_irq(client->irq, NULL);
+	input_unregister_device(akm->input_dev);
+	misc_deregister(&akmd_device);
+	misc_deregister(&akm_aot_device);
+	akm8975_power_off(akm);
+	kfree(akm);
+	return 0;
+}
+
+static const struct i2c_device_id akm8975_id[] = {
+	{ "akm8975", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, akm8975_id);
+
+static struct i2c_driver akm8975_driver = {
+	.probe = akm8975_probe,
+	.remove = akm8975_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.resume = akm8975_resume,
+	.suspend = akm8975_suspend,
+#endif
+	.id_table = akm8975_id,
+	.driver = {
+		.name = "akm8975",
+	},
+};
+
+static int __init akm8975_init(void)
+{
+	pr_info("AK8975 compass driver: init\n");
+	FUNCDBG("AK8975 compass driver: init\n");
+	return i2c_add_driver(&akm8975_driver);
+}
+
+static void __exit akm8975_exit(void)
+{
+	FUNCDBG("AK8975 compass driver: exit\n");
+	i2c_del_driver(&akm8975_driver);
+}
+
+module_init(akm8975_init);
+module_exit(akm8975_exit);
+
+MODULE_AUTHOR("Hou-Kun Chen <hk_chen@htc.com>");
+MODULE_DESCRIPTION("AK8975 compass driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/apanic.c tiny210/drivers/misc/apanic.c
--- linux-2.6.35.7/drivers/misc/apanic.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/apanic.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,606 @@
+/* drivers/misc/apanic.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: San Mehat <san@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/wakelock.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+#include <linux/notifier.h>
+#include <linux/mtd/mtd.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/preempt.h>
+
+extern void ram_console_enable_console(int);
+
+struct panic_header {
+	u32 magic;
+#define PANIC_MAGIC 0xdeadf00d
+
+	u32 version;
+#define PHDR_VERSION   0x01
+
+	u32 console_offset;
+	u32 console_length;
+
+	u32 threads_offset;
+	u32 threads_length;
+};
+
+struct apanic_data {
+	struct mtd_info		*mtd;
+	struct panic_header	curr;
+	void			*bounce;
+	struct proc_dir_entry	*apanic_console;
+	struct proc_dir_entry	*apanic_threads;
+};
+
+static struct apanic_data drv_ctx;
+static struct work_struct proc_removal_work;
+static DEFINE_MUTEX(drv_mutex);
+
+static unsigned int *apanic_bbt;
+static unsigned int apanic_erase_blocks;
+static unsigned int apanic_good_blocks;
+
+static void set_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag = 1;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = flag << (block%32);
+	apanic_bbt[block/32] |= flag;
+	apanic_good_blocks--;
+}
+
+static unsigned int get_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = 1 << (block%32);
+	return apanic_bbt[block/32] & flag;
+}
+
+static void alloc_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int bbt_size;
+	apanic_erase_blocks = (mtd->size)>>(mtd->erasesize_shift);
+	bbt_size = (apanic_erase_blocks+32)/32;
+
+	apanic_bbt = kmalloc(bbt_size*4, GFP_KERNEL);
+	memset(apanic_bbt, 0, bbt_size*4);
+	apanic_good_blocks = apanic_erase_blocks;
+}
+static void scan_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int i;
+
+	for (i = 0; i < apanic_erase_blocks; i++) {
+		if (mtd->block_isbad(mtd, i*mtd->erasesize))
+			set_bb(i, apanic_bbt);
+	}
+}
+
+#define APANIC_INVALID_OFFSET 0xFFFFFFFF
+
+static unsigned int phy_offset(struct mtd_info *mtd, unsigned int offset)
+{
+	unsigned int logic_block = offset>>(mtd->erasesize_shift);
+	unsigned int phy_block;
+	unsigned good_block = 0;
+
+	for (phy_block = 0; phy_block < apanic_erase_blocks; phy_block++) {
+		if (!get_bb(phy_block, apanic_bbt))
+			good_block++;
+		if (good_block == (logic_block + 1))
+			break;
+	}
+
+	if (good_block != (logic_block + 1))
+		return APANIC_INVALID_OFFSET;
+
+	return offset + ((phy_block-logic_block)<<mtd->erasesize_shift);
+}
+
+static void apanic_erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *) done->priv;
+	wake_up(wait_q);
+}
+
+static int apanic_proc_read(char *buffer, char **start, off_t offset,
+			       int count, int *peof, void *dat)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	size_t file_length;
+	off_t file_offset;
+	unsigned int page_no;
+	off_t page_offset;
+	int rc;
+	size_t len;
+
+	if (!count)
+		return 0;
+
+	mutex_lock(&drv_mutex);
+
+	switch ((int) dat) {
+	case 1:	/* apanic_console */
+		file_length = ctx->curr.console_length;
+		file_offset = ctx->curr.console_offset;
+		break;
+	case 2:	/* apanic_threads */
+		file_length = ctx->curr.threads_length;
+		file_offset = ctx->curr.threads_offset;
+		break;
+	default:
+		pr_err("Bad dat (%d)\n", (int) dat);
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+
+	if ((offset + count) > file_length) {
+		mutex_unlock(&drv_mutex);
+		return 0;
+	}
+
+	/* We only support reading a maximum of a flash page */
+	if (count > ctx->mtd->writesize)
+		count = ctx->mtd->writesize;
+
+	page_no = (file_offset + offset) / ctx->mtd->writesize;
+	page_offset = (file_offset + offset) % ctx->mtd->writesize;
+
+
+	if (phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize))
+		== APANIC_INVALID_OFFSET) {
+		pr_err("apanic: reading an invalid address\n");
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+	rc = ctx->mtd->read(ctx->mtd,
+		phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize)),
+		ctx->mtd->writesize,
+		&len, ctx->bounce);
+
+	if (page_offset)
+		count -= page_offset;
+	memcpy(buffer, ctx->bounce + page_offset, count);
+
+	*start = count;
+
+	if ((offset + count) == file_length)
+		*peof = 1;
+
+	mutex_unlock(&drv_mutex);
+	return count;
+}
+
+static void mtd_panic_erase(void)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct erase_info erase;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	int rc, i;
+
+	init_waitqueue_head(&wait_q);
+	erase.mtd = ctx->mtd;
+	erase.callback = apanic_erase_callback;
+	erase.len = ctx->mtd->erasesize;
+	erase.priv = (u_long)&wait_q;
+	for (i = 0; i < ctx->mtd->size; i += ctx->mtd->erasesize) {
+		erase.addr = i;
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&wait_q, &wait);
+
+		if (get_bb(erase.addr>>ctx->mtd->erasesize_shift, apanic_bbt)) {
+			printk(KERN_WARNING
+			       "apanic: Skipping erase of bad "
+			       "block @%llx\n", erase.addr);
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			continue;
+		}
+
+		rc = ctx->mtd->erase(ctx->mtd, &erase);
+		if (rc) {
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			printk(KERN_ERR
+			       "apanic: Erase of 0x%llx, 0x%llx failed\n",
+			       (unsigned long long) erase.addr,
+			       (unsigned long long) erase.len);
+			if (rc == -EIO) {
+				if (ctx->mtd->block_markbad(ctx->mtd,
+							    erase.addr)) {
+					printk(KERN_ERR
+					       "apanic: Err marking blk bad\n");
+					goto out;
+				}
+				printk(KERN_INFO
+				       "apanic: Marked a bad block"
+				       " @%llx\n", erase.addr);
+				set_bb(erase.addr>>ctx->mtd->erasesize_shift,
+					apanic_bbt);
+				continue;
+			}
+			goto out;
+		}
+		schedule();
+		remove_wait_queue(&wait_q, &wait);
+	}
+	printk(KERN_DEBUG "apanic: %s partition erased\n",
+	       CONFIG_APANIC_PLABEL);
+out:
+	return;
+}
+
+static void apanic_remove_proc_work(struct work_struct *work)
+{
+	struct apanic_data *ctx = &drv_ctx;
+
+	mutex_lock(&drv_mutex);
+	mtd_panic_erase();
+	memset(&ctx->curr, 0, sizeof(struct panic_header));
+	if (ctx->apanic_console) {
+		remove_proc_entry("apanic_console", NULL);
+		ctx->apanic_console = NULL;
+	}
+	if (ctx->apanic_threads) {
+		remove_proc_entry("apanic_threads", NULL);
+		ctx->apanic_threads = NULL;
+	}
+	mutex_unlock(&drv_mutex);
+}
+
+static int apanic_proc_write(struct file *file, const char __user *buffer,
+				unsigned long count, void *data)
+{
+	schedule_work(&proc_removal_work);
+	return count;
+}
+
+static void mtd_panic_notify_add(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = ctx->bounce;
+	size_t len;
+	int rc;
+	int    proc_entry_created = 0;
+
+	if (strcmp(mtd->name, CONFIG_APANIC_PLABEL))
+		return;
+
+	ctx->mtd = mtd;
+
+	alloc_bbt(mtd, apanic_bbt);
+	scan_bbt(mtd, apanic_bbt);
+
+	if (apanic_good_blocks == 0) {
+		printk(KERN_ERR "apanic: no any good blocks?!\n");
+		goto out_err;
+	}
+
+	rc = mtd->read(mtd, phy_offset(mtd, 0), mtd->writesize,
+			&len, ctx->bounce);
+	if (rc && rc == -EBADMSG) {
+		printk(KERN_WARNING
+		       "apanic: Bad ECC on block 0 (ignored)\n");
+	} else if (rc && rc != -EUCLEAN) {
+		printk(KERN_ERR "apanic: Error reading block 0 (%d)\n", rc);
+		goto out_err;
+	}
+
+	if (len != mtd->writesize) {
+		printk(KERN_ERR "apanic: Bad read size (%d)\n", rc);
+		goto out_err;
+	}
+
+	printk(KERN_INFO "apanic: Bound to mtd partition '%s'\n", mtd->name);
+
+	if (hdr->magic != PANIC_MAGIC) {
+		printk(KERN_INFO "apanic: No panic data available\n");
+		mtd_panic_erase();
+		return;
+	}
+
+	if (hdr->version != PHDR_VERSION) {
+		printk(KERN_INFO "apanic: Version mismatch (%d != %d)\n",
+		       hdr->version, PHDR_VERSION);
+		mtd_panic_erase();
+		return;
+	}
+
+	memcpy(&ctx->curr, hdr, sizeof(struct panic_header));
+
+	printk(KERN_INFO "apanic: c(%u, %u) t(%u, %u)\n",
+	       hdr->console_offset, hdr->console_length,
+	       hdr->threads_offset, hdr->threads_length);
+
+	if (hdr->console_length) {
+		ctx->apanic_console = create_proc_entry("apanic_console",
+						      S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_console)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_console->read_proc = apanic_proc_read;
+			ctx->apanic_console->write_proc = apanic_proc_write;
+			ctx->apanic_console->size = hdr->console_length;
+			ctx->apanic_console->data = (void *) 1;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (hdr->threads_length) {
+		ctx->apanic_threads = create_proc_entry("apanic_threads",
+						       S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_threads)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_threads->read_proc = apanic_proc_read;
+			ctx->apanic_threads->write_proc = apanic_proc_write;
+			ctx->apanic_threads->size = hdr->threads_length;
+			ctx->apanic_threads->data = (void *) 2;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (!proc_entry_created)
+		mtd_panic_erase();
+
+	return;
+out_err:
+	ctx->mtd = NULL;
+}
+
+static void mtd_panic_notify_remove(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	if (mtd == ctx->mtd) {
+		ctx->mtd = NULL;
+		printk(KERN_INFO "apanic: Unbound from %s\n", mtd->name);
+	}
+}
+
+static struct mtd_notifier mtd_panic_notifier = {
+	.add	= mtd_panic_notify_add,
+	.remove	= mtd_panic_notify_remove,
+};
+
+static int in_panic = 0;
+
+static int apanic_writeflashpage(struct mtd_info *mtd, loff_t to,
+				 const u_char *buf)
+{
+	int rc;
+	size_t wlen;
+	int panic = in_interrupt() | in_atomic();
+
+	if (panic && !mtd->panic_write) {
+		printk(KERN_EMERG "%s: No panic_write available\n", __func__);
+		return 0;
+	} else if (!panic && !mtd->write) {
+		printk(KERN_EMERG "%s: No write available\n", __func__);
+		return 0;
+	}
+
+	to = phy_offset(mtd, to);
+	if (to == APANIC_INVALID_OFFSET) {
+		printk(KERN_EMERG "apanic: write to invalid address\n");
+		return 0;
+	}
+
+	if (panic)
+		rc = mtd->panic_write(mtd, to, mtd->writesize, &wlen, buf);
+	else
+		rc = mtd->write(mtd, to, mtd->writesize, &wlen, buf);
+
+	if (rc) {
+		printk(KERN_EMERG
+		       "%s: Error writing data to flash (%d)\n",
+		       __func__, rc);
+		return rc;
+	}
+
+	return wlen;
+}
+
+extern int log_buf_copy(char *dest, int idx, int len);
+extern void log_buf_clear(void);
+
+/*
+ * Writes the contents of the console to the specified offset in flash.
+ * Returns number of bytes written
+ */
+static int apanic_write_console(struct mtd_info *mtd, unsigned int off)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	int saved_oip;
+	int idx = 0;
+	int rc, rc2;
+	unsigned int last_chunk = 0;
+
+	while (!last_chunk) {
+		saved_oip = oops_in_progress;
+		oops_in_progress = 1;
+		rc = log_buf_copy(ctx->bounce, idx, mtd->writesize);
+		if (rc < 0)
+			break;
+
+		if (rc != mtd->writesize)
+			last_chunk = rc;
+
+		oops_in_progress = saved_oip;
+		if (rc <= 0)
+			break;
+		if (rc != mtd->writesize)
+			memset(ctx->bounce + rc, 0, mtd->writesize - rc);
+
+		rc2 = apanic_writeflashpage(mtd, off, ctx->bounce);
+		if (rc2 <= 0) {
+			printk(KERN_EMERG
+			       "apanic: Flash write failed (%d)\n", rc2);
+			return idx;
+		}
+		if (!last_chunk)
+			idx += rc2;
+		else
+			idx += last_chunk;
+		off += rc2;
+	}
+	return idx;
+}
+
+static int apanic(struct notifier_block *this, unsigned long event,
+			void *ptr)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = (struct panic_header *) ctx->bounce;
+	int console_offset = 0;
+	int console_len = 0;
+	int threads_offset = 0;
+	int threads_len = 0;
+	int rc;
+
+	if (in_panic)
+		return NOTIFY_DONE;
+	in_panic = 1;
+#ifdef CONFIG_PREEMPT
+	/* Ensure that cond_resched() won't try to preempt anybody */
+	add_preempt_count(PREEMPT_ACTIVE);
+#endif
+	touch_softlockup_watchdog();
+
+	if (!ctx->mtd)
+		goto out;
+
+	if (ctx->curr.magic) {
+		printk(KERN_EMERG "Crash partition in use!\n");
+		goto out;
+	}
+	console_offset = ctx->mtd->writesize;
+
+	/*
+	 * Write out the console
+	 */
+	console_len = apanic_write_console(ctx->mtd, console_offset);
+	if (console_len < 0) {
+		printk(KERN_EMERG "Error writing console to panic log! (%d)\n",
+		       console_len);
+		console_len = 0;
+	}
+
+	/*
+	 * Write out all threads
+	 */
+	threads_offset = ALIGN(console_offset + console_len,
+			       ctx->mtd->writesize);
+	if (!threads_offset)
+		threads_offset = ctx->mtd->writesize;
+
+	ram_console_enable_console(0);
+
+	log_buf_clear();
+	show_state_filter(0);
+	threads_len = apanic_write_console(ctx->mtd, threads_offset);
+	if (threads_len < 0) {
+		printk(KERN_EMERG "Error writing threads to panic log! (%d)\n",
+		       threads_len);
+		threads_len = 0;
+	}
+
+	/*
+	 * Finally write the panic header
+	 */
+	memset(ctx->bounce, 0, PAGE_SIZE);
+	hdr->magic = PANIC_MAGIC;
+	hdr->version = PHDR_VERSION;
+
+	hdr->console_offset = console_offset;
+	hdr->console_length = console_len;
+
+	hdr->threads_offset = threads_offset;
+	hdr->threads_length = threads_len;
+
+	rc = apanic_writeflashpage(ctx->mtd, 0, ctx->bounce);
+	if (rc <= 0) {
+		printk(KERN_EMERG "apanic: Header write failed (%d)\n",
+		       rc);
+		goto out;
+	}
+
+	printk(KERN_EMERG "apanic: Panic dump sucessfully written to flash\n");
+
+ out:
+#ifdef CONFIG_PREEMPT
+	sub_preempt_count(PREEMPT_ACTIVE);
+#endif
+	in_panic = 0;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_blk = {
+	.notifier_call	= apanic,
+};
+
+static int panic_dbg_get(void *data, u64 *val)
+{
+	apanic(NULL, 0, NULL);
+	return 0;
+}
+
+static int panic_dbg_set(void *data, u64 val)
+{
+	BUG();
+	return -1;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(panic_dbg_fops, panic_dbg_get, panic_dbg_set, "%llu\n");
+
+int __init apanic_init(void)
+{
+	register_mtd_user(&mtd_panic_notifier);
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+	debugfs_create_file("apanic", 0644, NULL, NULL, &panic_dbg_fops);
+	memset(&drv_ctx, 0, sizeof(drv_ctx));
+	drv_ctx.bounce = (void *) __get_free_page(GFP_KERNEL);
+	INIT_WORK(&proc_removal_work, apanic_remove_proc_work);
+	printk(KERN_INFO "Android kernel panic handler initialized (bind=%s)\n",
+	       CONFIG_APANIC_PLABEL);
+	return 0;
+}
+
+module_init(apanic_init);
diff -Nur linux-2.6.35.7/drivers/misc/fsa9480.c tiny210/drivers/misc/fsa9480.c
--- linux-2.6.35.7/drivers/misc/fsa9480.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/fsa9480.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,530 @@
+/*
+ * driver/misc/fsa9480.c - FSA9480 micro USB switch device driver
+ *
+ * Copyright (C) 2010 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Wonguk Jeong <wonguk.jeong@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/fsa9480.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+/* FSA9480 I2C registers */
+#define FSA9480_REG_DEVID		0x01
+#define FSA9480_REG_CTRL		0x02
+#define FSA9480_REG_INT1		0x03
+#define FSA9480_REG_INT2		0x04
+#define FSA9480_REG_INT1_MASK		0x05
+#define FSA9480_REG_INT2_MASK		0x06
+#define FSA9480_REG_ADC			0x07
+#define FSA9480_REG_TIMING1		0x08
+#define FSA9480_REG_TIMING2		0x09
+#define FSA9480_REG_DEV_T1		0x0a
+#define FSA9480_REG_DEV_T2		0x0b
+#define FSA9480_REG_BTN1		0x0c
+#define FSA9480_REG_BTN2		0x0d
+#define FSA9480_REG_CK			0x0e
+#define FSA9480_REG_CK_INT1		0x0f
+#define FSA9480_REG_CK_INT2		0x10
+#define FSA9480_REG_CK_INTMASK1		0x11
+#define FSA9480_REG_CK_INTMASK2		0x12
+#define FSA9480_REG_MANSW1		0x13
+#define FSA9480_REG_MANSW2		0x14
+
+/* Control */
+#define CON_SWITCH_OPEN		(1 << 4)
+#define CON_RAW_DATA		(1 << 3)
+#define CON_MANUAL_SW		(1 << 2)
+#define CON_WAIT		(1 << 1)
+#define CON_INT_MASK		(1 << 0)
+#define CON_MASK		(CON_SWITCH_OPEN | CON_RAW_DATA | \
+				CON_MANUAL_SW | CON_WAIT)
+
+/* Device Type 1 */
+#define DEV_USB_OTG		(1 << 7)
+#define DEV_DEDICATED_CHG	(1 << 6)
+#define DEV_USB_CHG		(1 << 5)
+#define DEV_CAR_KIT		(1 << 4)
+#define DEV_UART		(1 << 3)
+#define DEV_USB			(1 << 2)
+#define DEV_AUDIO_2		(1 << 1)
+#define DEV_AUDIO_1		(1 << 0)
+
+#define DEV_T1_USB_MASK		(DEV_USB_OTG | DEV_USB)
+#define DEV_T1_UART_MASK	(DEV_UART)
+#define DEV_T1_CHARGER_MASK	(DEV_DEDICATED_CHG | DEV_USB_CHG | DEV_CAR_KIT)
+
+/* Device Type 2 */
+#define DEV_AV			(1 << 6)
+#define DEV_TTY			(1 << 5)
+#define DEV_PPD			(1 << 4)
+#define DEV_JIG_UART_OFF	(1 << 3)
+#define DEV_JIG_UART_ON		(1 << 2)
+#define DEV_JIG_USB_OFF		(1 << 1)
+#define DEV_JIG_USB_ON		(1 << 0)
+
+#define DEV_T2_USB_MASK		(DEV_JIG_USB_OFF | DEV_JIG_USB_ON)
+#define DEV_T2_UART_MASK	DEV_JIG_UART_OFF
+#define DEV_T2_JIG_MASK		(DEV_JIG_USB_OFF | DEV_JIG_USB_ON | \
+				DEV_JIG_UART_OFF)
+
+/*
+ * Manual Switch
+ * D- [7:5] / D+ [4:2]
+ * 000: Open all / 001: USB / 010: AUDIO / 011: UART / 100: V_AUDIO
+ */
+#define SW_VAUDIO		((4 << 5) | (4 << 2))
+#define SW_UART			((3 << 5) | (3 << 2))
+#define SW_AUDIO		((2 << 5) | (2 << 2))
+#define SW_DHOST		((1 << 5) | (1 << 2))
+#define SW_AUTO			((0 << 5) | (0 << 2))
+
+/* Interrupt 1 */
+#define INT_DETACH		(1 << 1)
+#define INT_ATTACH		(1 << 0)
+
+struct fsa9480_usbsw {
+	struct i2c_client		*client;
+	struct fsa9480_platform_data	*pdata;
+	int				dev1;
+	int				dev2;
+	int				mansw;
+};
+
+static ssize_t fsa9480_show_control(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct fsa9480_usbsw *usbsw = dev_get_drvdata(dev);
+	struct i2c_client *client = usbsw->client;
+	int value;
+
+	value = i2c_smbus_read_byte_data(client, FSA9480_REG_CTRL);
+	if (value < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, value);
+
+	return sprintf(buf, "CONTROL: %02x\n", value);
+}
+
+static ssize_t fsa9480_show_device_type(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct fsa9480_usbsw *usbsw = dev_get_drvdata(dev);
+	struct i2c_client *client = usbsw->client;
+	int value;
+
+	value = i2c_smbus_read_byte_data(client, FSA9480_REG_DEV_T1);
+	if (value < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, value);
+
+	return sprintf(buf, "DEVICE_TYPE: %02x\n", value);
+}
+
+static ssize_t fsa9480_show_manualsw(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fsa9480_usbsw *usbsw = dev_get_drvdata(dev);
+	struct i2c_client *client = usbsw->client;
+	unsigned int value;
+
+	value = i2c_smbus_read_byte_data(client, FSA9480_REG_MANSW1);
+	if (value < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, value);
+
+	if (value == SW_VAUDIO)
+		return sprintf(buf, "VAUDIO\n");
+	else if (value == SW_UART)
+		return sprintf(buf, "UART\n");
+	else if (value == SW_AUDIO)
+		return sprintf(buf, "AUDIO\n");
+	else if (value == SW_DHOST)
+		return sprintf(buf, "DHOST\n");
+	else if (value == SW_AUTO)
+		return sprintf(buf, "AUTO\n");
+	else
+		return sprintf(buf, "%x", value);
+}
+
+static ssize_t fsa9480_set_manualsw(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct fsa9480_usbsw *usbsw = dev_get_drvdata(dev);
+	struct i2c_client *client = usbsw->client;
+	unsigned int value;
+	unsigned int path = 0;
+	int ret;
+
+	value = i2c_smbus_read_byte_data(client, FSA9480_REG_CTRL);
+	if (value < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, value);
+
+	if ((value & ~CON_MANUAL_SW) !=
+			(CON_SWITCH_OPEN | CON_RAW_DATA | CON_WAIT))
+		return 0;
+
+	if (!strncmp(buf, "VAUDIO", 6)) {
+		path = SW_VAUDIO;
+		value &= ~CON_MANUAL_SW;
+	} else if (!strncmp(buf, "UART", 4)) {
+		path = SW_UART;
+		value &= ~CON_MANUAL_SW;
+	} else if (!strncmp(buf, "AUDIO", 5)) {
+		path = SW_AUDIO;
+		value &= ~CON_MANUAL_SW;
+	} else if (!strncmp(buf, "DHOST", 5)) {
+		path = SW_DHOST;
+		value &= ~CON_MANUAL_SW;
+	} else if (!strncmp(buf, "AUTO", 4)) {
+		path = SW_AUTO;
+		value |= CON_MANUAL_SW;
+	} else {
+		dev_err(dev, "Wrong command\n");
+		return 0;
+	}
+
+	usbsw->mansw = path;
+
+	ret = i2c_smbus_write_byte_data(client, FSA9480_REG_MANSW1, path);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	ret = i2c_smbus_write_byte_data(client, FSA9480_REG_CTRL, value);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	return count;
+}
+
+static DEVICE_ATTR(control, S_IRUGO, fsa9480_show_control, NULL);
+static DEVICE_ATTR(device_type, S_IRUGO, fsa9480_show_device_type, NULL);
+static DEVICE_ATTR(switch, S_IRUGO | S_IWUSR,
+		fsa9480_show_manualsw, fsa9480_set_manualsw);
+
+static struct attribute *fsa9480_attributes[] = {
+	&dev_attr_control.attr,
+	&dev_attr_device_type.attr,
+	&dev_attr_switch.attr,
+	NULL
+};
+
+static const struct attribute_group fsa9480_group = {
+	.attrs = fsa9480_attributes,
+};
+
+
+static void fsa9480_detect_dev(struct fsa9480_usbsw *usbsw)
+{
+	int device_type, ret;
+	unsigned char val1, val2;
+	struct fsa9480_platform_data *pdata = usbsw->pdata;
+	struct i2c_client *client = usbsw->client;
+
+	device_type = i2c_smbus_read_word_data(client, FSA9480_REG_DEV_T1);
+	if (device_type < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, device_type);
+
+	val1 = device_type & 0xff;
+	val2 = device_type >> 8;
+
+	dev_info(&client->dev, "dev1: 0x%x, dev2: 0x%x\n", val1, val2);
+
+	/* Attached */
+	if (val1 || val2) {
+		/* USB */
+		if (val1 & DEV_T1_USB_MASK || val2 & DEV_T2_USB_MASK) {
+			if (pdata->usb_cb)
+				pdata->usb_cb(FSA9480_ATTACHED);
+			if (usbsw->mansw) {
+				ret = i2c_smbus_write_byte_data(client,
+					FSA9480_REG_MANSW1, usbsw->mansw);
+				if (ret < 0)
+					dev_err(&client->dev,
+						"%s: err %d\n", __func__, ret);
+			}
+		/* UART */
+		} else if (val1 & DEV_T1_UART_MASK || val2 & DEV_T2_UART_MASK) {
+			if (pdata->uart_cb)
+				pdata->uart_cb(FSA9480_ATTACHED);
+
+			if (usbsw->mansw) {
+				ret = i2c_smbus_write_byte_data(client,
+					FSA9480_REG_MANSW1, SW_UART);
+				if (ret < 0)
+					dev_err(&client->dev,
+						"%s: err %d\n", __func__, ret);
+			}
+		/* CHARGER */
+		} else if (val1 & DEV_T1_CHARGER_MASK) {
+			if (pdata->charger_cb)
+				pdata->charger_cb(FSA9480_ATTACHED);
+		/* JIG */
+		} else if (val2 & DEV_T2_JIG_MASK) {
+			if (pdata->jig_cb)
+				pdata->jig_cb(FSA9480_ATTACHED);
+		/* Desk Dock */
+		} else if (val2 & DEV_AV) {
+			if (pdata->deskdock_cb)
+				pdata->deskdock_cb(FSA9480_ATTACHED);
+		/* Car Dock */
+		} else if (val2 & DEV_JIG_UART_ON) {
+			if (pdata->cardock_cb)
+				pdata->cardock_cb(FSA9480_ATTACHED);
+		}
+	/* Detached */
+	} else {
+		/* USB */
+		if (usbsw->dev1 & DEV_T1_USB_MASK ||
+				usbsw->dev2 & DEV_T2_USB_MASK) {
+			if (pdata->usb_cb)
+				pdata->usb_cb(FSA9480_DETACHED);
+		/* UART */
+		} else if (usbsw->dev1 & DEV_T1_UART_MASK ||
+				usbsw->dev2 & DEV_T2_UART_MASK) {
+			if (pdata->uart_cb)
+				pdata->uart_cb(FSA9480_DETACHED);
+		/* CHARGER */
+		} else if (usbsw->dev1 & DEV_T1_CHARGER_MASK) {
+			if (pdata->charger_cb)
+				pdata->charger_cb(FSA9480_DETACHED);
+		/* JIG */
+		} else if (usbsw->dev2 & DEV_T2_JIG_MASK) {
+			if (pdata->jig_cb)
+				pdata->jig_cb(FSA9480_DETACHED);
+		/* Desk Dock */
+		} else if (usbsw->dev2 & DEV_AV) {
+			if (pdata->deskdock_cb)
+				pdata->deskdock_cb(FSA9480_DETACHED);
+		/* Car Dock */
+		} else if (usbsw->dev2 & DEV_JIG_UART_ON) {
+			if (pdata->cardock_cb)
+				pdata->cardock_cb(FSA9480_DETACHED);
+		}
+	}
+
+	usbsw->dev1 = val1;
+	usbsw->dev2 = val2;
+}
+
+static void fsa9480_reg_init(struct fsa9480_usbsw *usbsw)
+{
+	struct i2c_client *client = usbsw->client;
+	unsigned int ctrl = CON_MASK;
+	int ret;
+
+	/* mask interrupts (unmask attach/detach only) */
+	ret = i2c_smbus_write_word_data(client, FSA9480_REG_INT1_MASK, 0x1ffc);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	/* mask all car kit interrupts */
+	ret = i2c_smbus_write_word_data(client, FSA9480_REG_CK_INTMASK1, 0x07ff);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	/* ADC Detect Time: 500ms */
+	ret = i2c_smbus_write_byte_data(client, FSA9480_REG_TIMING1, 0x6);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	usbsw->mansw = i2c_smbus_read_byte_data(client, FSA9480_REG_MANSW1);
+	if (usbsw->mansw < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, usbsw->mansw);
+
+	if (usbsw->mansw)
+		ctrl &= ~CON_MANUAL_SW;	/* Manual Switching Mode */
+
+	ret = i2c_smbus_write_byte_data(client, FSA9480_REG_CTRL, ctrl);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+}
+
+static irqreturn_t fsa9480_irq_thread(int irq, void *data)
+{
+	struct fsa9480_usbsw *usbsw = data;
+	struct i2c_client *client = usbsw->client;
+	int intr;
+
+	/* read and clear interrupt status bits */
+	intr = i2c_smbus_read_word_data(client, FSA9480_REG_INT1);
+	if (intr < 0) {
+		dev_err(&client->dev, "%s: err %d\n", __func__, intr);
+	} else if (intr == 0) {
+		/* interrupt was fired, but no status bits were set,
+		so device was reset. In this case, the registers were
+		reset to defaults so they need to be reinitialised. */
+		fsa9480_reg_init(usbsw);
+	}
+
+	/* device detection */
+	fsa9480_detect_dev(usbsw);
+
+	return IRQ_HANDLED;
+}
+
+static int fsa9480_irq_init(struct fsa9480_usbsw *usbsw)
+{
+	struct i2c_client *client = usbsw->client;
+	int ret;
+
+	if (client->irq) {
+		ret = request_threaded_irq(client->irq, NULL,
+			fsa9480_irq_thread, IRQF_TRIGGER_FALLING,
+			"fsa9480 micro USB", usbsw);
+		if (ret) {
+			dev_err(&client->dev, "failed to reqeust IRQ\n");
+			return ret;
+		}
+
+		ret = enable_irq_wake(client->irq);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"failed to enable wakeup src %d\n", ret);
+	}
+
+	return 0;
+}
+
+static int __devinit fsa9480_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct fsa9480_usbsw *usbsw;
+	int ret = 0;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	usbsw = kzalloc(sizeof(struct fsa9480_usbsw), GFP_KERNEL);
+	if (!usbsw) {
+		dev_err(&client->dev, "failed to allocate driver data\n");
+		return -ENOMEM;
+	}
+
+	usbsw->client = client;
+	usbsw->pdata = client->dev.platform_data;
+	if (!usbsw->pdata)
+		goto fail1;
+
+	i2c_set_clientdata(client, usbsw);
+
+	if (usbsw->pdata->cfg_gpio)
+		usbsw->pdata->cfg_gpio();
+
+	fsa9480_reg_init(usbsw);
+
+	ret = fsa9480_irq_init(usbsw);
+	if (ret)
+		goto fail1;
+
+	ret = sysfs_create_group(&client->dev.kobj, &fsa9480_group);
+	if (ret) {
+		dev_err(&client->dev,
+				"failed to create fsa9480 attribute group\n");
+		goto fail2;
+	}
+
+	if (usbsw->pdata->reset_cb)
+		usbsw->pdata->reset_cb();
+
+	/* device detection */
+	fsa9480_detect_dev(usbsw);
+
+	return 0;
+
+fail2:
+	if (client->irq)
+		free_irq(client->irq, usbsw);
+fail1:
+	i2c_set_clientdata(client, NULL);
+	kfree(usbsw);
+	return ret;
+}
+
+static int __devexit fsa9480_remove(struct i2c_client *client)
+{
+	struct fsa9480_usbsw *usbsw = i2c_get_clientdata(client);
+
+	if (client->irq) {
+		disable_irq_wake(client->irq);
+		free_irq(client->irq, usbsw);
+	}
+	i2c_set_clientdata(client, NULL);
+
+	sysfs_remove_group(&client->dev.kobj, &fsa9480_group);
+	kfree(usbsw);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int fsa9480_resume(struct i2c_client *client)
+{
+	struct fsa9480_usbsw *usbsw = i2c_get_clientdata(client);
+
+	/* device detection */
+	fsa9480_detect_dev(usbsw);
+
+	return 0;
+}
+
+#else
+
+#define fsa9480_suspend NULL
+#define fsa9480_resume NULL
+
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id fsa9480_id[] = {
+	{"fsa9480", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, fsa9480_id);
+
+static struct i2c_driver fsa9480_i2c_driver = {
+	.driver = {
+		.name = "fsa9480",
+	},
+	.probe = fsa9480_probe,
+	.remove = __devexit_p(fsa9480_remove),
+	.resume = fsa9480_resume,
+	.id_table = fsa9480_id,
+};
+
+static int __init fsa9480_init(void)
+{
+	return i2c_add_driver(&fsa9480_i2c_driver);
+}
+module_init(fsa9480_init);
+
+static void __exit fsa9480_exit(void)
+{
+	i2c_del_driver(&fsa9480_i2c_driver);
+}
+module_exit(fsa9480_exit);
+
+MODULE_AUTHOR("Minkyu Kang <mk7.kang@samsung.com>");
+MODULE_DESCRIPTION("FSA9480 USB Switch driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/Kconfig tiny210/drivers/misc/Kconfig
--- linux-2.6.35.7/drivers/misc/Kconfig	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/misc/Kconfig	2011-08-08 12:52:33.000000000 +0800
@@ -53,6 +53,25 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad525x_dpot-spi.
 
+config ANDROID_PMEM
+	bool "Android pmem allocator"
+	default y
+
+if  ANDROID_PMEM
+   comment "Reserved memory configurations"
+config ANDROID_PMEM_MEMSIZE_PMEM
+        int "Memory size in kbytes for android surface using pmem"
+        default "8192"
+
+config ANDROID_PMEM_MEMSIZE_PMEM_GPU1
+        int "Memory size in kbytes for android surface using pmem_gpu1"
+        default "3072"
+
+config ANDROID_PMEM_MEMSIZE_PMEM_ADSP
+        int "Memory size in kbytes for android surface using pmem_adsp"
+        default "6144"
+endif
+
 config ATMEL_PWM
 	tristate "Atmel AT32/AT91 PWM support"
 	depends on AVR32 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || ARCH_AT91CAP9
@@ -199,6 +218,13 @@
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
+config KERNEL_DEBUGGER_CORE
+	bool "Kernel Debugger Core"
+	default n
+	---help---
+	  Generic kernel debugging command processor used by low level
+	  (interrupt context) platform-specific debuggers.
+
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
@@ -304,6 +330,29 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tsl2550.
 
+config SENSORS_AK8973
+	tristate "AK8973 magnetometer support"
+	default n
+	depends on I2C
+	help
+	  If you say yes here you get support for Asahi Kasei's
+	  orientation sensor AK8973.
+
+config SENSORS_AK8975
+	tristate "AK8975 compass support"
+	default n
+	depends on I2C
+	help
+	  If you say yes here you get support for Asahi Kasei's
+	  orientation sensor AK8975.
+
+config SENSORS_KR3DM
+	tristate "KR3DM acceleration sensor support"
+	depends on I2C
+	default n
+	help
+	  Driver for STMicro KR3DM accelerometer - digital motion sensor.
+
 config EP93XX_PWM
 	tristate "EP93xx PWM support"
 	depends on ARCH_EP93XX
@@ -337,6 +386,10 @@
 	  This driver can also be built as a module. If so, the module
 	  will be calles ti_dac7512.
 
+config UID_STAT
+	bool "UID based statistics tracking exported to /proc/uid_stat"
+	default n
+
 config VMWARE_BALLOON
 	tristate "VMware Balloon Driver"
 	depends on X86
@@ -353,9 +406,59 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called vmware_balloon.
 
+config WL127X_RFKILL
+	tristate "Bluetooth power control driver for TI wl127x"
+	depends on RFKILL
+	default n
+	---help---
+	 Creates an rfkill entry in sysfs for power control of Bluetooth
+	 TI wl127x chips.
+
+config APANIC
+	bool "Android kernel panic diagnostics driver"
+	default n
+	---help---
+	 Driver which handles kernel panics and attempts to write
+	 critical debugging data to flash.
+
+config APANIC_PLABEL
+	string "Android panic dump flash partition label"
+	depends on APANIC
+	default "kpanic"
+	---help---
+	 If your platform uses a different flash partition label for storing
+ 	 crashdumps, enter it here.
+
+config SAMSUNG_JACK
+	bool "3.5MM ear jack driver for Samsung devices"
+	depends on INPUT
+	default n
+	---help---
+	 This is 3.5MM ear jack driver for Samsung devices.
+
+	 If unsure, say N.
+
+config USB_SWITCH_FSA9480
+	tristate "FSA9480 USB Switch"
+	depends on I2C
+	help
+	  The FSA9480 is a USB port accessory detector and switch.
+	  The FSA9480 is fully controlled using I2C and enables USB data,
+	  stereo and mono audio, video, microphone and UART data to use
+	  a common connector port.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
 source "drivers/misc/iwmc3200top/Kconfig"
 
+config SAMSUNG_MODEMCTL
+	bool "Samsung Modem Control/IO Driver"
+
+config PN544
+	bool "NXP PN544 NFC Controller Driver"
+	default n
+	help
+	  NXP PN544 Near Field Communication controller support.
+
 endif # MISC_DEVICES
diff -Nur linux-2.6.35.7/drivers/misc/kernel_debugger.c tiny210/drivers/misc/kernel_debugger.c
--- linux-2.6.35.7/drivers/misc/kernel_debugger.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/kernel_debugger.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,79 @@
+/* drivers/android/kernel_debugger.c
+ *
+ * Guts of the kernel debugger.
+ * Needs something to actually push commands to it.
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/sysrq.h>
+#include <linux/kernel_debugger.h>
+
+#define dprintf(fmt...) (ctxt->printf(ctxt->cookie, fmt))
+
+static void do_ps(struct kdbg_ctxt *ctxt)
+{
+	struct task_struct *g, *p;
+	unsigned state;
+	static const char stat_nam[] = "RSDTtZX";
+
+	dprintf("pid   ppid  prio task            pc\n");
+	read_lock(&tasklist_lock);
+	do_each_thread(g, p) {
+		state = p->state ? __ffs(p->state) + 1 : 0;
+		dprintf("%5d %5d %4d ", p->pid, p->parent->pid, p->prio);
+		dprintf("%-13.13s %c", p->comm,
+			state >= sizeof(stat_nam) ? '?' : stat_nam[state]);
+		if (state == TASK_RUNNING)
+			dprintf(" running\n");
+		else
+			dprintf(" %08lx\n", thread_saved_pc(p));
+	} while_each_thread(g, p);
+	read_unlock(&tasklist_lock);
+}
+
+int log_buf_copy(char *dest, int idx, int len);
+extern int do_syslog(int type, char __user *bug, int count);
+static void do_sysrq(struct kdbg_ctxt *ctxt, char rq)
+{
+	char buf[128];
+	int ret;
+	int idx = 0;
+	do_syslog(5 /* clear */, NULL, 0);
+	handle_sysrq(rq, NULL);
+	while (1) {
+		ret = log_buf_copy(buf, idx, sizeof(buf) - 1);
+		if (ret <= 0)
+			break;
+		buf[ret] = 0;
+		dprintf("%s", buf);
+		idx += ret;
+	}
+}
+
+int kernel_debugger(struct kdbg_ctxt *ctxt, char *cmd)
+{
+	if (!strcmp(cmd, "ps"))
+		do_ps(ctxt);
+	if (!strcmp(cmd, "sysrq"))
+		do_sysrq(ctxt, 'h');
+	if (!strncmp(cmd, "sysrq ", 6))
+		do_sysrq(ctxt, cmd[6]);
+
+	return 0;
+}
+
diff -Nur linux-2.6.35.7/drivers/misc/kr3dm.c tiny210/drivers/misc/kr3dm.c
--- linux-2.6.35.7/drivers/misc/kr3dm.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/kr3dm.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,497 @@
+/*
+ *  STMicroelectronics kr3dm acceleration sensor driver
+ *
+ *  Copyright (C) 2010 Samsung Electronics Co.Ltd
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/kr3dm.h>
+#include <linux/delay.h>
+#include <linux/completion.h>
+#include "kr3dm_reg.h"
+
+#define kr3dm_dbgmsg(str, args...) pr_debug("%s: " str, __func__, ##args)
+
+/* The default settings when sensor is on is for all 3 axis to be enabled
+ * and output data rate set to 400Hz.  Output is via a ioctl read call.
+ * The ioctl blocks on data_ready completion.
+ * The sensor generates an interrupt when the output is ready and the
+ * irq handler atomically sets the completion and wakes any
+ * blocked reader.
+ */
+#define DEFAULT_POWER_ON_SETTING (ODR400 | ENABLE_ALL_AXES)
+#define READ_REPEAT_SHIFT	3
+#define READ_REPEAT		(1 << READ_REPEAT_SHIFT)
+
+static const struct odr_delay {
+	u8 odr; /* odr reg setting */
+	s64 delay_ns; /* odr in ns */
+} odr_delay_table[] = {
+	{  ODR400,    2500000LL << READ_REPEAT_SHIFT }, /* 400Hz */
+	{  ODR100,   10000000LL << READ_REPEAT_SHIFT }, /* 100Hz */
+	{   ODR50,   20000000LL << READ_REPEAT_SHIFT }, /*  50Hz */
+	{   ODR10,  100000000LL << READ_REPEAT_SHIFT }, /*  10Hz */
+	{    ODR5,  200000000LL << READ_REPEAT_SHIFT }, /*   5Hz */
+	{    ODR2,  500000000LL << READ_REPEAT_SHIFT }, /*   2Hz */
+	{    ODR1, 1000000000LL << READ_REPEAT_SHIFT }, /*   1Hz */
+	{ ODRHALF, 2000000000LL << READ_REPEAT_SHIFT }, /* 0.5Hz */
+};
+
+/* KR3DM acceleration data */
+struct kr3dm_acc {
+	s8 x;
+	s8 y;
+	s8 z;
+};
+
+struct kr3dm_data {
+	struct i2c_client *client;
+	struct miscdevice kr3dm_device;
+	struct kr3dm_platform_data *pdata;
+	int irq;
+	u8 ctrl_reg1_shadow;
+	struct completion data_ready;
+	atomic_t opened; /* opened implies enabled */
+	struct mutex read_lock;
+	struct mutex write_lock;
+};
+
+static void kr3dm_disable_irq(struct kr3dm_data *kr3dm)
+{
+	disable_irq(kr3dm->irq);
+	if (try_wait_for_completion(&kr3dm->data_ready)) {
+		/* we actually got the interrupt before we could disable it
+		 * so we need to enable again to undo our disable and the
+		 * one done in the irq_handler
+		 */
+		enable_irq(kr3dm->irq);
+	}
+}
+
+static irqreturn_t kr3dm_irq_handler(int irq, void *data)
+{
+	struct kr3dm_data *kr3dm = data;
+	disable_irq_nosync(irq);
+	complete(&kr3dm->data_ready);
+	return IRQ_HANDLED;
+}
+
+static int kr3dm_wait_for_data_ready(struct kr3dm_data *kr3dm)
+{
+	int err;
+
+	if (gpio_get_value(kr3dm->pdata->gpio_acc_int))
+		return 0;
+
+	enable_irq(kr3dm->irq);
+
+	err = wait_for_completion_timeout(&kr3dm->data_ready, 5*HZ);
+	if (err > 0)
+		return 0;
+
+	kr3dm_disable_irq(kr3dm);
+
+	if (err == 0) {
+		pr_err("kr3dm: wait timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	pr_err("kr3dm: wait restart\n");
+	return err;
+}
+
+/* Read X,Y and Z-axis acceleration data.  Blocks until there is
+ * something to read, based on interrupt from chip.
+ */
+static int kr3dm_read_accel_xyz(struct kr3dm_data *kr3dm,
+				struct kr3dm_acc *acc)
+{
+	int err;
+	s8 reg = OUT_X | AC; /* read from OUT_X to OUT_Z by auto-inc */
+	s8 acc_data[5];
+
+	err = kr3dm_wait_for_data_ready(kr3dm);
+	if (err)
+		return err;
+
+	/* OUT_X, OUT_Y, and OUT_Z are single byte registers at
+	 * address 0x29, 0x2B, and 0x2D respectively, with 1 dummy
+	 * register in between.  Rather than doing 3 separate i2c reads,
+	 * we do one multi-byte read and just use the bytes we want.
+	 */
+	err = i2c_smbus_read_i2c_block_data(kr3dm->client, reg,
+					    sizeof(acc_data), acc_data);
+	if (err != sizeof(acc_data)) {
+		pr_err("%s : failed to read 5 bytes for getting x/y/z\n",
+		       __func__);
+		return -EIO;
+	}
+
+	acc->x = acc_data[0];
+	acc->y = acc_data[2];
+	acc->z = acc_data[4];
+
+	return 0;
+}
+
+/*  open command for KR3DM device file  */
+static int kr3dm_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct kr3dm_data *kr3dm = container_of(file->private_data,
+						struct kr3dm_data,
+						kr3dm_device);
+
+	if (atomic_xchg(&kr3dm->opened, 1)) {
+		pr_err("kr3dm_open() called when already open\n");
+		return -EBUSY;
+	} else {
+		file->private_data = kr3dm;
+		kr3dm->ctrl_reg1_shadow = DEFAULT_POWER_ON_SETTING;
+		err = i2c_smbus_write_byte_data(kr3dm->client, CTRL_REG1,
+						DEFAULT_POWER_ON_SETTING);
+		if (err) {
+			pr_err("kr3dm_open() i2c write ctrl_reg1 failed\n");
+			atomic_set(&kr3dm->opened, 0);
+		}
+	}
+
+	return err;
+}
+
+/*  release command for KR3DM device file */
+static int kr3dm_close(struct inode *inode, struct file *file)
+{
+	int err;
+	struct kr3dm_data *kr3dm = file->private_data;
+
+	err = i2c_smbus_write_byte_data(kr3dm->client, CTRL_REG1, PM_OFF);
+	atomic_set(&kr3dm->opened, 0);
+	kr3dm->ctrl_reg1_shadow = PM_OFF;
+
+	return err;
+}
+
+static s64 kr3dm_get_delay(struct kr3dm_data *kr3dm)
+{
+	int i;
+	u8 odr;
+	s64 delay = -1;
+
+	odr = kr3dm->ctrl_reg1_shadow & ODR_MASK;
+	for (i = 0; i < ARRAY_SIZE(odr_delay_table); i++) {
+		if (odr == odr_delay_table[i].odr) {
+			delay = odr_delay_table[i].delay_ns;
+			break;
+		}
+	}
+	return delay;
+}
+
+static int kr3dm_set_delay(struct kr3dm_data *kr3dm, s64 delay_ns)
+{
+	int odr_value = ODRHALF;
+	int res = 0;
+	int i;
+	/* round to the nearest delay that is less than
+	 * the requested value (next highest freq)
+	 */
+	kr3dm_dbgmsg(" passed %lldns\n", delay_ns);
+	for (i = 0; i < ARRAY_SIZE(odr_delay_table); i++) {
+		if (delay_ns < odr_delay_table[i].delay_ns)
+			break;
+	}
+	if (i > 0)
+		i--;
+	kr3dm_dbgmsg("matched rate %lldns, odr = 0x%x\n",
+			odr_delay_table[i].delay_ns,
+			odr_delay_table[i].odr);
+	odr_value = odr_delay_table[i].odr;
+	delay_ns = odr_delay_table[i].delay_ns;
+	mutex_lock(&kr3dm->write_lock);
+	kr3dm_dbgmsg("old = %lldns, new = %lldns\n",
+		     kr3dm_get_delay(kr3dm), delay_ns);
+	if (odr_value != (kr3dm->ctrl_reg1_shadow & ODR_MASK)) {
+		u8 ctrl = (kr3dm->ctrl_reg1_shadow & ~ODR_MASK);
+		ctrl |= odr_value;
+		kr3dm->ctrl_reg1_shadow = ctrl;
+		res = i2c_smbus_write_byte_data(kr3dm->client, CTRL_REG1, ctrl);
+		kr3dm_dbgmsg("writing odr value 0x%x\n", odr_value);
+	}
+	mutex_unlock(&kr3dm->write_lock);
+	return res;
+}
+
+/*  ioctl command for KR3DM device file */
+static int kr3dm_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	struct kr3dm_data *kr3dm = file->private_data;
+	s64 delay_ns;
+	struct kr3dm_acc data;
+	int i;
+	struct kr3dm_acceldata sum = { 0, };
+
+	/* cmd mapping */
+	switch (cmd) {
+	case KR3DM_IOCTL_SET_DELAY:
+		if (copy_from_user(&delay_ns, (void __user *)arg,
+					sizeof(delay_ns)))
+			return -EFAULT;
+		err = kr3dm_set_delay(kr3dm, delay_ns);
+		break;
+	case KR3DM_IOCTL_GET_DELAY:
+		delay_ns = kr3dm_get_delay(kr3dm);
+		if (put_user(delay_ns, (s64 __user *)arg))
+			return -EFAULT;
+		break;
+	case KR3DM_IOCTL_READ_ACCEL_XYZ:
+		mutex_lock(&kr3dm->read_lock);
+		for (i = 0; i < READ_REPEAT; i++) {
+			err = kr3dm_read_accel_xyz(kr3dm, &data);
+			if (err)
+				break;
+			sum.x += data.x;
+			sum.y += data.y;
+			sum.z += data.z;
+		}
+		mutex_unlock(&kr3dm->read_lock);
+		if (err)
+			return err;
+		if (copy_to_user((void __user *)arg, &sum, sizeof(sum)))
+			return -EFAULT;
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static int kr3dm_suspend(struct device *dev)
+{
+	int res = 0;
+	struct kr3dm_data *kr3dm  = dev_get_drvdata(dev);
+
+	if (atomic_read(&kr3dm->opened))
+		res = i2c_smbus_write_byte_data(kr3dm->client,
+						CTRL_REG1, PM_OFF);
+
+	return res;
+}
+
+static int kr3dm_resume(struct device *dev)
+{
+	int res = 0;
+	struct kr3dm_data *kr3dm = dev_get_drvdata(dev);
+
+	if (atomic_read(&kr3dm->opened))
+		res = i2c_smbus_write_byte_data(kr3dm->client, CTRL_REG1,
+						kr3dm->ctrl_reg1_shadow);
+
+	return res;
+}
+
+
+static const struct dev_pm_ops kr3dm_pm_ops = {
+	.suspend = kr3dm_suspend,
+	.resume = kr3dm_resume,
+};
+
+static const struct file_operations kr3dm_fops = {
+	.owner = THIS_MODULE,
+	.open = kr3dm_open,
+	.release = kr3dm_close,
+	.ioctl = kr3dm_ioctl,
+};
+
+static int kr3dm_setup_irq(struct kr3dm_data *kr3dm)
+{
+	int rc = -EIO;
+	struct kr3dm_platform_data *pdata = kr3dm->pdata;
+	int irq;
+
+	rc = gpio_request(pdata->gpio_acc_int, "gpio_acc_int");
+	if (rc < 0) {
+		pr_err("%s: gpio %d request failed (%d)\n",
+			__func__, pdata->gpio_acc_int, rc);
+		return rc;
+	}
+
+	rc = gpio_direction_input(pdata->gpio_acc_int);
+	if (rc < 0) {
+		pr_err("%s: failed to set gpio %d as input (%d)\n",
+			__func__, pdata->gpio_acc_int, rc);
+		goto err_gpio_direction_input;
+	}
+
+	/* configure INT1 to deliver data ready interrupt */
+	rc = i2c_smbus_write_byte_data(kr3dm->client, CTRL_REG3, I1_CFG_DR);
+	if (rc) {
+		pr_err("%s: CTRL_REG3 write failed with error %d\n",
+			__func__, rc);
+		goto err_i2c_write_failed;
+	}
+
+	irq = gpio_to_irq(pdata->gpio_acc_int);
+
+	/* trigger high so we don't miss initial interrupt if it
+	 * is already pending
+	 */
+	rc = request_irq(irq, kr3dm_irq_handler, IRQF_TRIGGER_HIGH,
+			 "acc_int", kr3dm);
+	if (rc < 0) {
+		pr_err("%s: request_irq(%d) failed for gpio %d (%d)\n",
+			__func__, irq,
+			pdata->gpio_acc_int, rc);
+		goto err_request_irq;
+	}
+
+	/* start with interrupt disabled until the driver is enabled */
+	kr3dm->irq = irq;
+	kr3dm_disable_irq(kr3dm);
+
+	goto done;
+
+err_request_irq:
+err_i2c_write_failed:
+err_gpio_direction_input:
+	gpio_free(pdata->gpio_acc_int);
+done:
+	return rc;
+}
+
+static int kr3dm_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct kr3dm_data *kr3dm;
+	int err;
+	struct kr3dm_platform_data *pdata = client->dev.platform_data;
+
+	if (!pdata) {
+		pr_err("%s: missing pdata!\n", __func__);
+		return -ENODEV;
+	}
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {
+		pr_err("%s: i2c functionality check failed!\n", __func__);
+		err = -ENODEV;
+		goto exit;
+	}
+
+	kr3dm = kzalloc(sizeof(struct kr3dm_data), GFP_KERNEL);
+	if (kr3dm == NULL) {
+		dev_err(&client->dev,
+				"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	kr3dm->client = client;
+	kr3dm->pdata = pdata;
+	i2c_set_clientdata(client, kr3dm);
+
+	init_completion(&kr3dm->data_ready);
+	mutex_init(&kr3dm->read_lock);
+	mutex_init(&kr3dm->write_lock);
+	atomic_set(&kr3dm->opened, 0);
+
+	err = kr3dm_setup_irq(kr3dm);
+	if (err) {
+		pr_err("%s: could not setup irq\n", __func__);
+		goto err_setup_irq;
+	}
+
+	/* sensor HAL expects to find /dev/accelerometer */
+	kr3dm->kr3dm_device.minor = MISC_DYNAMIC_MINOR;
+	kr3dm->kr3dm_device.name = "accelerometer";
+	kr3dm->kr3dm_device.fops = &kr3dm_fops;
+
+	err = misc_register(&kr3dm->kr3dm_device);
+	if (err) {
+		pr_err("%s: misc_register failed\n", __FILE__);
+		goto err_misc_register;
+	}
+
+	return 0;
+
+err_misc_register:
+	free_irq(kr3dm->irq, kr3dm);
+	gpio_free(kr3dm->pdata->gpio_acc_int);
+err_setup_irq:
+	mutex_destroy(&kr3dm->read_lock);
+	mutex_destroy(&kr3dm->write_lock);
+	kfree(kr3dm);
+exit:
+	return err;
+}
+
+static int kr3dm_remove(struct i2c_client *client)
+{
+	struct kr3dm_data *kr3dm = i2c_get_clientdata(client);
+
+	misc_deregister(&kr3dm->kr3dm_device);
+	free_irq(kr3dm->irq, kr3dm);
+	gpio_free(kr3dm->pdata->gpio_acc_int);
+	mutex_destroy(&kr3dm->read_lock);
+	mutex_destroy(&kr3dm->write_lock);
+	kfree(kr3dm);
+
+	return 0;
+}
+
+static const struct i2c_device_id kr3dm_id[] = {
+	{ "kr3dm", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, kr3dm_id);
+
+static struct i2c_driver kr3dm_driver = {
+	.probe = kr3dm_probe,
+	.remove = __devexit_p(kr3dm_remove),
+	.id_table = kr3dm_id,
+	.driver = {
+		.pm = &kr3dm_pm_ops,
+		.owner = THIS_MODULE,
+		.name = "kr3dm",
+	},
+};
+
+static int __init kr3dm_init(void)
+{
+	return i2c_add_driver(&kr3dm_driver);
+}
+
+static void __exit kr3dm_exit(void)
+{
+	i2c_del_driver(&kr3dm_driver);
+}
+
+module_init(kr3dm_init);
+module_exit(kr3dm_exit);
+
+MODULE_DESCRIPTION("kr3dm accelerometer driver");
+MODULE_AUTHOR("Tim SK Lee Samsung Electronics <tim.sk.lee@samsung.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/kr3dm_reg.h tiny210/drivers/misc/kr3dm_reg.h
--- linux-2.6.35.7/drivers/misc/kr3dm_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/kr3dm_reg.h	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,169 @@
+/*
+ *  STMicroelectronics kr3dm acceleration sensor driver
+ *
+ *  Copyright (C) 2010 Samsung Electronics Co.Ltd
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+
+/* kr3dm i2c slave address & etc */
+#define KR3DM_I2C_ADDR          0x09
+/* kr3dm registers */
+#define WHO_AM_I		0x0F
+#define CTRL_REG1		0x20    /* power control reg */
+#define CTRL_REG2		0x21    /* power control reg */
+#define CTRL_REG3		0x22    /* power control reg */
+#define CTRL_REG4		0x23    /* interrupt control reg */
+#define CTRL_REG5		0x24    /* interrupt control reg */
+#define STATUS_REG		0x27
+#define AXISDATA_REG		0x28
+#define OUT_X			0x29
+#define OUT_Y			0x2B
+#define OUT_Z			0x2D
+#define INT1_CFG		0x30
+#define INT1_SOURCE		0x31
+#define INT1_THS		0x32
+#define INT1_DURATION		0x33
+#define INT2_CFG		0x34
+#define INT2_SOURCE		0x35
+#define INT2_THS		0x36
+#define INT2_DURATION		0x37
+
+#define KR3DM_G_2G		0x00
+#define KR3DM_G_4G		0x10
+#define KR3DM_G_8G		0x30
+
+/* CTRL_REG1 */
+/* ctrl 1: pm2 pm1 pm0 dr1 dr0 x-enable y-enable z-enable */
+#define PM_OFF			0x00
+#define ENABLE_ALL_AXES		0x07
+
+#define ODRHALF		0x40  /* 0.5Hz output data rate */
+#define ODR1		0x60  /* 1Hz output data rate */
+#define ODR2		0x80  /* 2Hz output data rate */
+#define ODR5		0xA0  /* 5Hz output data rate */
+#define ODR10		0xC0  /* 10Hz output data rate */
+#define ODR50		0x20  /* 50Hz output data rate */
+#define ODR100		0x28  /* 100Hz output data rate */
+#define ODR400		0x30  /* 400Hz output data rate */
+
+#define ODR_MASK        0xf8
+
+#define CTRL_REG1_PM2		(1 << 7)
+#define CTRL_REG1_PM1		(1 << 6)
+#define CTRL_REG1_PM0		(1 << 5)
+#define CTRL_REG1_DR1		(1 << 4)
+#define CTRL_REG1_DR0		(1 << 3)
+#define CTRL_REG1_Zen		(1 << 2)
+#define CTRL_REG1_Yen		(1 << 1)
+#define CTRL_REG1_Xen		(1 << 0)
+
+#define PM_down			0x00
+#define PM_Normal		(CTRL_REG1_PM0)
+#define PM_Low05		(CTRL_REG1_PM1)
+#define PM_Low1			(CTRL_REG1_PM1|CTRL_REG1_PM0)
+#define PM_Low2			(CTRL_REG1_PM2)
+#define PM_Low5			(CTRL_REG1_PM2|CTRL_REG1_PM0)
+#define PM_Low10		(CTRL_REG1_PM2|CTRL_REG1_PM1)
+
+/* CTRL_REG2 */
+#define CTRL_REG2_BOOT		(1 << 7)
+#define CTRL_REG2_HPM1		(1 << 6)
+#define CTRL_REG2_HPM0		(1 << 5)
+#define CTRL_REG2_FDS		(1 << 4)
+#define CTRL_REG2_HPen2		(1 << 3)
+#define CTRL_REG2_HPen1		(1 << 2)
+#define CTRL_REG2_HPCF1		(1 << 1)
+#define CTRL_REG2_HPCF0		(1 << 0)
+
+#define HPM_Normal		(CTRL_REG2_HPM1)
+#define HPM_Filter		(CTRL_REG2_HPM0)
+
+#define HPCF_ft8		0x00
+#define HPCF_ft4		(CTRL_REG2_HPCF0)
+#define HPCF_ft2		(CTRL_REG2_HPCF1)
+#define HPCF_ft1		(CTRL_REG2_HPCF1|CTRL_REG2_HPCF0)
+
+/* CTRL_REG3 */
+#define CTRL_REG3_IHL		(1 << 7)
+#define CTRL_REG3_PP_OD		(1 << 6)
+#define CTRL_REG3_LIR2		(1 << 5)
+#define CTRL_REG3_I2_CFG1	(1 << 4)
+#define ICTRL_REG3_2_CFG0	(1 << 3)
+#define CTRL_REG3_LIR1		(1 << 2)
+#define CTRL_REG3_I1_CFG1	(1 << 1)
+#define CTRL_REG3_I1_CFG0	(1 << 0)
+
+/* Interrupt 1 (2) source */
+#define I1_CFG_SC		(0x00)
+/* Interrupt 1 source OR Interrupt 2 source */
+#define I1_CFG_OR		(CTRL_REG3_I1_CFG0)
+/* Data Ready */
+#define I1_CFG_DR		(CTRL_REG3_I1_CFG1)
+/* Boot running */
+#define I1_CFG_BR		(CTRL_REG3_I1_CFG1|CTRL_REG3_I1_CFG0)
+
+ /* Interrupt 1 (2) source */
+#define I2_CFG_SC		(0x00)
+/* Interrupt 1 source OR Interrupt 2 source */
+#define I2_CFG_OR		(CTRL_REG3_I2_CFG0)
+/* Data Ready */
+#define I2_CFG_DR		(CTRL_REG3_I2_CFG1)
+/* Boot running */
+#define I2_CFG_BR		(CTRL_REG3_I2_CFG1|CTRL_REG3_I2_CFG0)
+
+/* CTRL_REG4 */
+#define CTRL_REG4_FS1		(1 << 5)
+#define CTRL_REG4_FS0		(1 << 4)
+#define CTRL_REG4_STsign	(1 << 3)
+#define CTRL_REG4_ST		(1 << 1)
+#define CTRL_REG4_SIM		(1 << 0)
+
+#define FS2g			0x00
+#define FS4g			(CTRL_REG4_FS0)
+#define FS8g			(CTRL_REG4_FS1|CTRL_REG4_FS0)
+
+/* CTRL_REG5 */
+#define CTRL_REG5_TurnOn1	(1 << 1)
+#define CTRL_REG5_TurnOn0	(1 << 0)
+
+/* STATUS_REG */
+#define ZYXOR			(1 << 7)
+#define ZOR			(1 << 6)
+#define YOR			(1 << 5)
+#define XOR			(1 << 4)
+#define ZYXDA			(1 << 3)
+#define ZDA			(1 << 2)
+#define YDA			(1 << 1)
+#define XDA			(1 << 0)
+
+/* INT1/2_CFG */
+#define INT_CFG_AOI		(1 << 7)
+#define INT_CFG_6D		(1 << 6)
+#define INT_CFG_ZHIE		(1 << 5)
+#define INT_CFG_ZLIE		(1 << 4)
+#define INT_CFG_YHIE		(1 << 3)
+#define INT_CFG_YLIE		(1 << 2)
+#define INT_CFG_XHIE		(1 << 1)
+#define INT_CFG_XLIE		(1 << 0)
+
+/* INT1/2_SRC */
+#define IA			(1 << 6)
+#define ZH			(1 << 5)
+#define ZL			(1 << 4)
+#define YH			(1 << 3)
+#define YL			(1 << 2)
+#define XH			(1 << 1)
+#define XL			(1 << 0)
+
+/* Register Auto-increase */
+#define AC			(1 << 7)
diff -Nur linux-2.6.35.7/drivers/misc/Makefile tiny210/drivers/misc/Makefile
--- linux-2.6.35.7/drivers/misc/Makefile	2010-09-29 09:09:08.000000000 +0800
+++ tiny210/drivers/misc/Makefile	2011-08-08 12:52:33.000000000 +0800
@@ -14,8 +14,10 @@
 obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
 obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
+obj-$(CONFIG_ANDROID_PMEM)	+= pmem.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
+obj-$(CONFIG_KERNEL_DEBUGGER_CORE)	+= kernel_debugger.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
@@ -26,8 +28,18 @@
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
+obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_VMWARE_BALLOON)	+= vmware_balloon.o
+obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
+obj-$(CONFIG_APANIC)		+= apanic.o
+obj-$(CONFIG_SENSORS_AK8973)	+= ak8973.o
+obj-$(CONFIG_SENSORS_AK8975)	+= akm8975.o
+obj-$(CONFIG_SENSORS_KR3DM)	+= kr3dm.o
+obj-$(CONFIG_PN544)		+= pn544.o
+obj-$(CONFIG_SAMSUNG_JACK)	+= sec_jack.o
+obj-$(CONFIG_USB_SWITCH_FSA9480)	+= fsa9480.o
+obj-$(CONFIG_SAMSUNG_MODEMCTL) += samsung_modemctl/
diff -Nur linux-2.6.35.7/drivers/misc/pmem.c tiny210/drivers/misc/pmem.c
--- linux-2.6.35.7/drivers/misc/pmem.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/pmem.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,1343 @@
+/* drivers/android/pmem.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/list.h>
+#include <linux/debugfs.h>
+#include <linux/android_pmem.h>
+#include <linux/mempolicy.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+
+#define PMEM_MAX_DEVICES 10
+#define PMEM_MAX_ORDER 128
+#define PMEM_MIN_ALLOC PAGE_SIZE
+
+#define PMEM_DEBUG 1
+
+/* indicates that a refernce to this file has been taken via get_pmem_file,
+ * the file should not be released until put_pmem_file is called */
+#define PMEM_FLAGS_BUSY 0x1
+/* indicates that this is a suballocation of a larger master range */
+#define PMEM_FLAGS_CONNECTED 0x1 << 1
+/* indicates this is a master and not a sub allocation and that it is mmaped */
+#define PMEM_FLAGS_MASTERMAP 0x1 << 2
+/* submap and unsubmap flags indicate:
+ * 00: subregion has never been mmaped
+ * 10: subregion has been mmaped, reference to the mm was taken
+ * 11: subretion has ben released, refernece to the mm still held
+ * 01: subretion has been released, reference to the mm has been released
+ */
+#define PMEM_FLAGS_SUBMAP 0x1 << 3
+#define PMEM_FLAGS_UNSUBMAP 0x1 << 4
+
+
+struct pmem_data {
+	/* in alloc mode: an index into the bitmap
+	 * in no_alloc mode: the size of the allocation */
+	int index;
+	/* see flags above for descriptions */
+	unsigned int flags;
+	/* protects this data field, if the mm_mmap sem will be held at the
+	 * same time as this sem, the mm sem must be taken first (as this is
+	 * the order for vma_open and vma_close ops */
+	struct rw_semaphore sem;
+	/* info about the mmaping process */
+	struct vm_area_struct *vma;
+	/* task struct of the mapping process */
+	struct task_struct *task;
+	/* process id of teh mapping process */
+	pid_t pid;
+	/* file descriptor of the master */
+	int master_fd;
+	/* file struct of the master */
+	struct file *master_file;
+	/* a list of currently available regions if this is a suballocation */
+	struct list_head region_list;
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list;
+#if PMEM_DEBUG
+	int ref;
+#endif
+};
+
+struct pmem_bits {
+	unsigned allocated:1;		/* 1 if allocated, 0 if free */
+	unsigned order:7;		/* size of the region in pmem space */
+};
+
+struct pmem_region_node {
+	struct pmem_region region;
+	struct list_head list;
+};
+
+#define PMEM_DEBUG_MSGS 0
+#if PMEM_DEBUG_MSGS
+#define DLOG(fmt,args...) \
+	do { printk(KERN_INFO "[%s:%s:%d] "fmt, __FILE__, __func__, __LINE__, \
+		    ##args); } \
+	while (0)
+#else
+#define DLOG(x...) do {} while (0)
+#endif
+
+struct pmem_info {
+	struct miscdevice dev;
+	/* physical start address of the remaped pmem space */
+	unsigned long base;
+	/* vitual start address of the remaped pmem space */
+	unsigned char __iomem *vbase;
+	/* total size of the pmem space */
+	unsigned long size;
+	/* number of entries in the pmem space */
+	unsigned long num_entries;
+	/* pfn of the garbage page in memory */
+	unsigned long garbage_pfn;
+	/* index of the garbage page in the pmem space */
+	int garbage_index;
+	/* the bitmap for the region indicating which entries are allocated
+	 * and which are free */
+	struct pmem_bits *bitmap;
+	/* indicates the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* indicates maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	unsigned buffered;
+	/* in no_allocator mode the first mapper gets the whole space and sets
+	 * this flag */
+	unsigned allocated;
+	/* for debugging, creates a list of pmem file structs, the
+	 * data_list_sem should be taken before pmem_data->sem if both are
+	 * needed */
+	struct semaphore data_list_sem;
+	struct list_head data_list;
+	/* pmem_sem protects the bitmap array
+	 * a write lock should be held when modifying entries in bitmap
+	 * a read lock should be held when reading data from bits or
+	 * dereferencing a pointer into bitmap
+	 *
+	 * pmem_data->sem protects the pmem data of a particular file
+	 * Many of the function that require the pmem_data->sem have a non-
+	 * locking version for when the caller is already holding that sem.
+	 *
+	 * IF YOU TAKE BOTH LOCKS TAKE THEM IN THIS ORDER:
+	 * down(pmem_data->sem) => down(bitmap_sem)
+	 */
+	struct rw_semaphore bitmap_sem;
+
+	long (*ioctl)(struct file *, unsigned int, unsigned long);
+	int (*release)(struct inode *, struct file *);
+};
+
+static struct pmem_info pmem[PMEM_MAX_DEVICES];
+static int id_count;
+
+#define PMEM_IS_FREE(id, index) !(pmem[id].bitmap[index].allocated)
+#define PMEM_ORDER(id, index) pmem[id].bitmap[index].order
+#define PMEM_BUDDY_INDEX(id, index) (index ^ (1 << PMEM_ORDER(id, index)))
+#define PMEM_NEXT_INDEX(id, index) (index + (1 << PMEM_ORDER(id, index)))
+#define PMEM_OFFSET(index) (index * PMEM_MIN_ALLOC)
+#define PMEM_START_ADDR(id, index) (PMEM_OFFSET(index) + pmem[id].base)
+#define PMEM_LEN(id, index) ((1 << PMEM_ORDER(id, index)) * PMEM_MIN_ALLOC)
+#define PMEM_END_ADDR(id, index) (PMEM_START_ADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_START_VADDR(id, index) (PMEM_OFFSET(id, index) + pmem[id].vbase)
+#define PMEM_END_VADDR(id, index) (PMEM_START_VADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_REVOKED(data) (data->flags & PMEM_FLAGS_REVOKED)
+#define PMEM_IS_PAGE_ALIGNED(addr) (!((addr) & (~PAGE_MASK)))
+#define PMEM_IS_SUBMAP(data) ((data->flags & PMEM_FLAGS_SUBMAP) && \
+	(!(data->flags & PMEM_FLAGS_UNSUBMAP)))
+
+static int pmem_release(struct inode *, struct file *);
+static int pmem_mmap(struct file *, struct vm_area_struct *);
+static int pmem_open(struct inode *, struct file *);
+static long pmem_ioctl(struct file *, unsigned int, unsigned long);
+
+struct file_operations pmem_fops = {
+	.release = pmem_release,
+	.mmap = pmem_mmap,
+	.open = pmem_open,
+	.unlocked_ioctl = pmem_ioctl,
+};
+
+static int get_id(struct file *file)
+{
+	return MINOR(file->f_dentry->d_inode->i_rdev);
+}
+
+int is_pmem_file(struct file *file)
+{
+	int id;
+
+	if (unlikely(!file || !file->f_dentry || !file->f_dentry->d_inode))
+		return 0;
+	id = get_id(file);
+	if (unlikely(id >= PMEM_MAX_DEVICES))
+		return 0;
+	if (unlikely(file->f_dentry->d_inode->i_rdev !=
+	     MKDEV(MISC_MAJOR, pmem[id].dev.minor)))
+		return 0;
+	return 1;
+}
+
+static int has_allocation(struct file *file)
+{
+	struct pmem_data *data;
+	/* check is_pmem_file first if not accessed via pmem_file_ops */
+
+	if (unlikely(!file->private_data))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (unlikely(data->index < 0))
+		return 0;
+	return 1;
+}
+
+static int is_master_owner(struct file *file)
+{
+	struct file *master_file;
+	struct pmem_data *data;
+	int put_needed, ret = 0;
+
+	if (!is_pmem_file(file) || !has_allocation(file))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (PMEM_FLAGS_MASTERMAP & data->flags)
+		return 1;
+	master_file = fget_light(data->master_fd, &put_needed);
+	if (master_file && data->master_file == master_file)
+		ret = 1;
+	fput_light(master_file, put_needed);
+	return ret;
+}
+
+static int pmem_free(int id, int index)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	int buddy, curr = index;
+	DLOG("index %d\n", index);
+
+	if (pmem[id].no_allocator) {
+		pmem[id].allocated = 0;
+		return 0;
+	}
+	/* clean up the bitmap, merging any buddies */
+	pmem[id].bitmap[curr].allocated = 0;
+	/* find a slots buddy Buddy# = Slot# ^ (1 << order)
+	 * if the buddy is also free merge them
+	 * repeat until the buddy is not free or end of the bitmap is reached
+	 */
+	do {
+		buddy = PMEM_BUDDY_INDEX(id, curr);
+		if (PMEM_IS_FREE(id, buddy) &&
+				PMEM_ORDER(id, buddy) == PMEM_ORDER(id, curr)) {
+			PMEM_ORDER(id, buddy)++;
+			PMEM_ORDER(id, curr)++;
+			curr = min(buddy, curr);
+		} else {
+			break;
+		}
+	} while (curr < pmem[id].num_entries);
+
+	return 0;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data);
+
+static int pmem_release(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	int id = get_id(file), ret = 0;
+
+
+	down(&pmem[id].data_list_sem);
+	/* if this file is a master, revoke all the memory in the connected
+	 *  files */
+	if (PMEM_FLAGS_MASTERMAP & data->flags) {
+		struct pmem_data *sub_data;
+		list_for_each(elt, &pmem[id].data_list) {
+			sub_data = list_entry(elt, struct pmem_data, list);
+			down_read(&sub_data->sem);
+			if (PMEM_IS_SUBMAP(sub_data) &&
+			    file == sub_data->master_file) {
+				up_read(&sub_data->sem);
+				pmem_revoke(file, sub_data);
+			}  else
+				up_read(&sub_data->sem);
+		}
+	}
+	list_del(&data->list);
+	up(&pmem[id].data_list_sem);
+
+
+	down_write(&data->sem);
+
+	/* if its not a conencted file and it has an allocation, free it */
+	if (!(PMEM_FLAGS_CONNECTED & data->flags) && has_allocation(file)) {
+		down_write(&pmem[id].bitmap_sem);
+		ret = pmem_free(id, data->index);
+		up_write(&pmem[id].bitmap_sem);
+	}
+
+	/* if this file is a submap (mapped, connected file), downref the
+	 * task struct */
+	if (PMEM_FLAGS_SUBMAP & data->flags)
+		if (data->task) {
+			put_task_struct(data->task);
+			data->task = NULL;
+		}
+
+	file->private_data = NULL;
+
+	list_for_each_safe(elt, elt2, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		list_del(elt);
+		kfree(region_node);
+	}
+	BUG_ON(!list_empty(&data->region_list));
+
+	up_write(&data->sem);
+	kfree(data);
+	if (pmem[id].release)
+		ret = pmem[id].release(inode, file);
+
+	return ret;
+}
+
+static int pmem_open(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+	int ret = 0;
+
+	DLOG("current %u file %p(%d)\n", current->pid, file, file_count(file));
+	/* setup file->private_data to indicate its unmapped */
+	/*  you can only open a pmem device one time */
+	if (file->private_data != NULL && file_count(file) != 1)
+		return -1;
+	data = kmalloc(sizeof(struct pmem_data), GFP_KERNEL);
+	if (!data) {
+		printk("pmem: unable to allocate memory for pmem metadata.");
+		return -1;
+	}
+	data->flags = 0;
+	data->index = -1;
+	data->task = NULL;
+	data->vma = NULL;
+	data->pid = 0;
+	data->master_file = NULL;
+#if PMEM_DEBUG
+	data->ref = 0;
+#endif
+	INIT_LIST_HEAD(&data->region_list);
+	init_rwsem(&data->sem);
+
+	file->private_data = data;
+	INIT_LIST_HEAD(&data->list);
+
+	down(&pmem[id].data_list_sem);
+	list_add(&data->list, &pmem[id].data_list);
+	up(&pmem[id].data_list_sem);
+	return ret;
+}
+
+static unsigned long pmem_order(unsigned long len)
+{
+	int i;
+
+	len = (len + PMEM_MIN_ALLOC - 1)/PMEM_MIN_ALLOC;
+	len--;
+	for (i = 0; i < sizeof(len)*8; i++)
+		if (len >> i == 0)
+			break;
+	return i;
+}
+
+static int pmem_allocate(int id, unsigned long len)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	/* return the corresponding pdata[] entry */
+	int curr = 0;
+	int end = pmem[id].num_entries;
+	int best_fit = -1;
+	unsigned long order = pmem_order(len);
+
+	if (pmem[id].no_allocator) {
+		DLOG("no allocator");
+		if ((len > pmem[id].size) || pmem[id].allocated)
+			return -1;
+		pmem[id].allocated = 1;
+		return len;
+	}
+
+	if (order > PMEM_MAX_ORDER)
+		return -1;
+	DLOG("order %lx\n", order);
+
+	/* look through the bitmap:
+	 * 	if you find a free slot of the correct order use it
+	 * 	otherwise, use the best fit (smallest with size > order) slot
+	 */
+	while (curr < end) {
+		if (PMEM_IS_FREE(id, curr)) {
+			if (PMEM_ORDER(id, curr) == (unsigned char)order) {
+				/* set the not free bit and clear others */
+				best_fit = curr;
+				break;
+			}
+			if (PMEM_ORDER(id, curr) > (unsigned char)order &&
+			    (best_fit < 0 ||
+			     PMEM_ORDER(id, curr) < PMEM_ORDER(id, best_fit)))
+				best_fit = curr;
+		}
+		curr = PMEM_NEXT_INDEX(id, curr);
+	}
+
+	/* if best_fit < 0, there are no suitable slots,
+	 * return an error
+	 */
+	if (best_fit < 0) {
+		printk("pmem: no space left to allocate!\n");
+		return -1;
+	}
+
+	/* now partition the best fit:
+	 * 	split the slot into 2 buddies of order - 1
+	 * 	repeat until the slot is of the correct order
+	 */
+	while (PMEM_ORDER(id, best_fit) > (unsigned char)order) {
+		int buddy;
+		PMEM_ORDER(id, best_fit) -= 1;
+		buddy = PMEM_BUDDY_INDEX(id, best_fit);
+		PMEM_ORDER(id, buddy) = PMEM_ORDER(id, best_fit);
+	}
+	pmem[id].bitmap[best_fit].allocated = 1;
+	return best_fit;
+}
+
+static pgprot_t phys_mem_access_prot(struct file *file, pgprot_t vma_prot)
+{
+	int id = get_id(file);
+#ifdef pgprot_noncached
+	if (pmem[id].cached == 0 || file->f_flags & O_SYNC)
+		return pgprot_noncached(vma_prot);
+#endif
+#ifdef pgprot_ext_buffered
+	else if (pmem[id].buffered)
+		return pgprot_ext_buffered(vma_prot);
+#endif
+	return vma_prot;
+}
+
+static unsigned long pmem_start_addr(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return PMEM_START_ADDR(id, 0);
+	else
+		return PMEM_START_ADDR(id, data->index);
+
+}
+
+static void *pmem_start_vaddr(int id, struct pmem_data *data)
+{
+	return pmem_start_addr(id, data) - pmem[id].base + pmem[id].vbase;
+}
+
+static unsigned long pmem_len(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return data->index;
+	else
+		return PMEM_LEN(id, data->index);
+}
+
+static int pmem_map_garbage(int id, struct vm_area_struct *vma,
+			    struct pmem_data *data, unsigned long offset,
+			    unsigned long len)
+{
+	int i, garbage_pages = len >> PAGE_SHIFT;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP | VM_SHARED | VM_WRITE;
+	for (i = 0; i < garbage_pages; i++) {
+		if (vm_insert_pfn(vma, vma->vm_start + offset + (i * PAGE_SIZE),
+		    pmem[id].garbage_pfn))
+			return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_unmap_pfn_range(int id, struct vm_area_struct *vma,
+				struct pmem_data *data, unsigned long offset,
+				unsigned long len)
+{
+	int garbage_pages;
+	DLOG("unmap offset %lx len %lx\n", offset, len);
+
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+
+	garbage_pages = len >> PAGE_SHIFT;
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	pmem_map_garbage(id, vma, data, offset, len);
+	return 0;
+}
+
+static int pmem_map_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	DLOG("map offset %lx len %lx\n", offset, len);
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_start));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_end));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(offset));
+
+	if (io_remap_pfn_range(vma, vma->vm_start + offset,
+		(pmem_start_addr(id, data) + offset) >> PAGE_SHIFT,
+		len, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_remap_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	/* hold the mm semp for the vma you are modifying when you call this */
+	BUG_ON(!vma);
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	return pmem_map_pfn_range(id, vma, data, offset, len);
+}
+
+static void pmem_vma_open(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+	int id = get_id(file);
+	/* this should never be called as we don't support copying pmem
+	 * ranges via fork */
+	BUG_ON(!has_allocation(file));
+	down_write(&data->sem);
+	/* remap the garbage pages, forkers don't get access to the data */
+	pmem_unmap_pfn_range(id, vma, data, 0, vma->vm_start - vma->vm_end);
+	up_write(&data->sem);
+}
+
+static void pmem_vma_close(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+
+	DLOG("current %u ppid %u file %p count %d\n", current->pid,
+	     current->parent->pid, file, file_count(file));
+	if (unlikely(!is_pmem_file(file) || !has_allocation(file))) {
+		printk(KERN_WARNING "pmem: something is very wrong, you are "
+		       "closing a vm backing an allocation that doesn't "
+		       "exist!\n");
+		return;
+	}
+	down_write(&data->sem);
+	if (data->vma == vma) {
+		data->vma = NULL;
+		if ((data->flags & PMEM_FLAGS_CONNECTED) &&
+		    (data->flags & PMEM_FLAGS_SUBMAP))
+			data->flags |= PMEM_FLAGS_UNSUBMAP;
+	}
+	/* the kernel is going to free this vma now anyway */
+	up_write(&data->sem);
+}
+
+static struct vm_operations_struct vm_ops = {
+	.open = pmem_vma_open,
+	.close = pmem_vma_close,
+};
+
+static int pmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct pmem_data *data;
+	int index;
+	unsigned long vma_size =  vma->vm_end - vma->vm_start;
+	int ret = 0, id = get_id(file);
+
+	if (vma->vm_pgoff || !PMEM_IS_PAGE_ALIGNED(vma_size)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: mmaps must be at offset zero, aligned"
+				" and a multiple of pages_size.\n");
+#endif
+		return -EINVAL;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	down_write(&data->sem);
+	/* check this file isn't already mmaped, for submaps check this file
+	 * has never been mmaped */
+	if ((data->flags & PMEM_FLAGS_SUBMAP) ||
+	    (data->flags & PMEM_FLAGS_UNSUBMAP)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: you can only mmap a pmem file once, "
+		       "this file is already mmaped. %x\n", data->flags);
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+	/* if file->private_data == unalloced, alloc*/
+	if (data && data->index == -1) {
+		down_write(&pmem[id].bitmap_sem);
+		index = pmem_allocate(id, vma->vm_end - vma->vm_start);
+		up_write(&pmem[id].bitmap_sem);
+		data->index = index;
+	}
+	/* either no space was available or an error occured */
+	if (!has_allocation(file)) {
+		ret = -EINVAL;
+		printk("pmem: could not find allocation for map.\n");
+		goto error;
+	}
+
+	if (pmem_len(id, data) < vma_size) {
+#if PMEM_DEBUG
+		printk(KERN_WARNING "pmem: mmap size [%lu] does not match"
+		       "size of backing region [%lu].\n", vma_size,
+		       pmem_len(id, data));
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+
+	vma->vm_pgoff = pmem_start_addr(id, data) >> PAGE_SHIFT;
+	vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_page_prot);
+
+	if (data->flags & PMEM_FLAGS_CONNECTED) {
+		struct pmem_region_node *region_node;
+		struct list_head *elt;
+		if (pmem_map_garbage(id, vma, data, 0, vma_size)) {
+			printk("pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		list_for_each(elt, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			DLOG("remapping file: %p %lx %lx\n", file,
+				region_node->region.offset,
+				region_node->region.len);
+			if (pmem_remap_pfn_range(id, vma, data,
+						 region_node->region.offset,
+						 region_node->region.len)) {
+				ret = -EAGAIN;
+				goto error;
+			}
+		}
+		data->flags |= PMEM_FLAGS_SUBMAP;
+		get_task_struct(current->group_leader);
+		data->task = current->group_leader;
+		data->vma = vma;
+#if PMEM_DEBUG
+		data->pid = current->pid;
+#endif
+		DLOG("submmapped file %p vma %p pid %u\n", file, vma,
+		     current->pid);
+	} else {
+		if (pmem_map_pfn_range(id, vma, data, 0, vma_size)) {
+			printk(KERN_INFO "pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		data->flags |= PMEM_FLAGS_MASTERMAP;
+		data->pid = current->pid;
+	}
+	vma->vm_ops = &vm_ops;
+error:
+	up_write(&data->sem);
+	return ret;
+}
+
+/* the following are the api for accessing pmem regions by other drivers
+ * from inside the kernel */
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		   unsigned long *len)
+{
+	struct pmem_data *data;
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from invalid"
+				  "file.\n");
+#endif
+		return -1;
+	}
+	data = (struct pmem_data *)file->private_data;
+	down_read(&data->sem);
+	if (data->vma) {
+		*start = data->vma->vm_start;
+		*len = data->vma->vm_end - data->vma->vm_start;
+	} else {
+		*start = 0;
+		*len = 0;
+	}
+	up_read(&data->sem);
+	return 0;
+}
+
+int get_pmem_addr(struct file *file, unsigned long *start,
+		  unsigned long *vstart, unsigned long *len)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return -1;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	if (data->index == -1) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from file with no "
+		       "allocation.\n");
+		return -1;
+#endif
+	}
+	id = get_id(file);
+
+	down_read(&data->sem);
+	*start = pmem_start_addr(id, data);
+	*len = pmem_len(id, data);
+	*vstart = (unsigned long)pmem_start_vaddr(id, data);
+	up_read(&data->sem);
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	data->ref++;
+	up_write(&data->sem);
+#endif
+	return 0;
+}
+
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *len, struct file **filp)
+{
+	struct file *file;
+
+	file = fget(fd);
+	if (unlikely(file == NULL)) {
+		printk(KERN_INFO "pmem: requested data from file descriptor "
+		       "that doesn't exist.");
+		return -1;
+	}
+
+	if (get_pmem_addr(file, start, vstart, len))
+		goto end;
+
+	if (filp)
+		*filp = file;
+	return 0;
+end:
+	fput(file);
+	return -1;
+}
+
+void put_pmem_file(struct file *file)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file))
+		return;
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	if (data->ref == 0) {
+		printk("pmem: pmem_put > pmem_get %s (pid %d)\n",
+		       pmem[id].dev.name, data->pid);
+		BUG();
+	}
+	data->ref--;
+	up_write(&data->sem);
+#endif
+	fput(file);
+}
+
+void flush_pmem_file(struct file *file, unsigned long offset, unsigned long len)
+{
+	struct pmem_data *data;
+	int id;
+	void *vaddr;
+	struct pmem_region_node *region_node;
+	struct list_head *elt;
+	void *flush_start, *flush_end;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return;
+	}
+
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+	if (!pmem[id].cached || file->f_flags & O_SYNC)
+		return;
+
+	down_read(&data->sem);
+	vaddr = pmem_start_vaddr(id, data);
+	/* if this isn't a submmapped file, flush the whole thing */
+	if (unlikely(!(data->flags & PMEM_FLAGS_CONNECTED))) {
+		dmac_flush_range(vaddr, vaddr + pmem_len(id, data));
+		goto end;
+	}
+	/* otherwise, flush the region of the file we are drawing */
+	list_for_each(elt, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		if ((offset >= region_node->region.offset) &&
+		    ((offset + len) <= (region_node->region.offset +
+			region_node->region.len))) {
+			flush_start = vaddr + region_node->region.offset;
+			flush_end = flush_start + region_node->region.len;
+			dmac_flush_range(flush_start, flush_end);
+			break;
+		}
+	}
+end:
+	up_read(&data->sem);
+}
+
+static int pmem_connect(unsigned long connect, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_data *src_data;
+	struct file *src_file;
+	int ret = 0, put_needed;
+
+	down_write(&data->sem);
+	/* retrieve the src file and check it is a pmem file with an alloc */
+	src_file = fget_light(connect, &put_needed);
+	DLOG("connect %p to %p\n", file, src_file);
+	if (!src_file) {
+		printk("pmem: src file not found!\n");
+		ret = -EINVAL;
+		goto err_no_file;
+	}
+	if (unlikely(!is_pmem_file(src_file) || !has_allocation(src_file))) {
+		printk(KERN_INFO "pmem: src file is not a pmem file or has no "
+		       "alloc!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	src_data = (struct pmem_data *)src_file->private_data;
+
+	if (has_allocation(file) && (data->index != src_data->index)) {
+		printk("pmem: file is already mapped but doesn't match this"
+		       " src_file!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	data->index = src_data->index;
+	data->flags |= PMEM_FLAGS_CONNECTED;
+	data->master_fd = connect;
+	data->master_file = src_file;
+
+err_bad_file:
+	fput_light(src_file, put_needed);
+err_no_file:
+	up_write(&data->sem);
+	return ret;
+}
+
+static void pmem_unlock_data_and_mm(struct pmem_data *data,
+				    struct mm_struct *mm)
+{
+	up_write(&data->sem);
+	if (mm != NULL) {
+		up_write(&mm->mmap_sem);
+		mmput(mm);
+	}
+}
+
+static int pmem_lock_data_and_mm(struct file *file, struct pmem_data *data,
+				 struct mm_struct **locked_mm)
+{
+	int ret = 0;
+	struct mm_struct *mm = NULL;
+	*locked_mm = NULL;
+lock_mm:
+	down_read(&data->sem);
+	if (PMEM_IS_SUBMAP(data)) {
+		mm = get_task_mm(data->task);
+		if (!mm) {
+#if PMEM_DEBUG
+			printk("pmem: can't remap task is gone!\n");
+#endif
+			up_read(&data->sem);
+			return -1;
+		}
+	}
+	up_read(&data->sem);
+
+	if (mm)
+		down_write(&mm->mmap_sem);
+
+	down_write(&data->sem);
+	/* check that the file didn't get mmaped before we could take the
+	 * data sem, this should be safe b/c you can only submap each file
+	 * once */
+	if (PMEM_IS_SUBMAP(data) && !mm) {
+		pmem_unlock_data_and_mm(data, mm);
+		goto lock_mm;
+	}
+	/* now check that vma.mm is still there, it could have been
+	 * deleted by vma_close before we could get the data->sem */
+	if ((data->flags & PMEM_FLAGS_UNSUBMAP) && (mm != NULL)) {
+		/* might as well release this */
+		if (data->flags & PMEM_FLAGS_SUBMAP) {
+			put_task_struct(data->task);
+			data->task = NULL;
+			/* lower the submap flag to show the mm is gone */
+			data->flags &= ~(PMEM_FLAGS_SUBMAP);
+		}
+		pmem_unlock_data_and_mm(data, mm);
+		return -1;
+	}
+	*locked_mm = mm;
+	return ret;
+}
+
+int pmem_remap(struct pmem_region *region, struct file *file,
+		      unsigned operation)
+{
+	int ret;
+	struct pmem_region_node *region_node;
+	struct mm_struct *mm = NULL;
+	struct list_head *elt, *elt2;
+	int id = get_id(file);
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+
+	/* pmem region must be aligned on a page boundry */
+	if (unlikely(!PMEM_IS_PAGE_ALIGNED(region->offset) ||
+		 !PMEM_IS_PAGE_ALIGNED(region->len))) {
+#if PMEM_DEBUG
+		printk("pmem: request for unaligned pmem suballocation "
+		       "%lx %lx\n", region->offset, region->len);
+#endif
+		return -EINVAL;
+	}
+
+	/* if userspace requests a region of len 0, there's nothing to do */
+	if (region->len == 0)
+		return 0;
+
+	/* lock the mm and data */
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	if (ret)
+		return 0;
+
+	/* only the owner of the master file can remap the client fds
+	 * that back in it */
+	if (!is_master_owner(file)) {
+#if PMEM_DEBUG
+		printk("pmem: remap requested from non-master process\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* check that the requested range is within the src allocation */
+	if (unlikely((region->offset > pmem_len(id, data)) ||
+		     (region->len > pmem_len(id, data)) ||
+		     (region->offset + region->len > pmem_len(id, data)))) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: suballoc doesn't fit in src_file!\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (operation == PMEM_MAP) {
+		region_node = kmalloc(sizeof(struct pmem_region_node),
+			      GFP_KERNEL);
+		if (!region_node) {
+			ret = -ENOMEM;
+#if PMEM_DEBUG
+			printk(KERN_INFO "No space to allocate metadata!");
+#endif
+			goto err;
+		}
+		region_node->region = *region;
+		list_add(&region_node->list, &data->region_list);
+	} else if (operation == PMEM_UNMAP) {
+		int found = 0;
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+				      list);
+			if (region->len == 0 ||
+			    (region_node->region.offset == region->offset &&
+			    region_node->region.len == region->len)) {
+				list_del(elt);
+				kfree(region_node);
+				found = 1;
+			}
+		}
+		if (!found) {
+#if PMEM_DEBUG
+			printk("pmem: Unmap region does not map any mapped "
+				"region!");
+#endif
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+
+	if (data->vma && PMEM_IS_SUBMAP(data)) {
+		if (operation == PMEM_MAP)
+			ret = pmem_remap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+		else if (operation == PMEM_UNMAP)
+			ret = pmem_unmap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+	}
+
+err:
+	pmem_unlock_data_and_mm(data, mm);
+	return ret;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data)
+{
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	struct mm_struct *mm = NULL;
+	int id = get_id(file);
+	int ret = 0;
+
+	data->master_file = NULL;
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	/* if lock_data_and_mm fails either the task that mapped the fd, or
+	 * the vma that mapped it have already gone away, nothing more
+	 * needs to be done */
+	if (ret)
+		return;
+	/* unmap everything */
+	/* delete the regions and region list nothing is mapped any more */
+	if (data->vma)
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			pmem_unmap_pfn_range(id, data->vma, data,
+					     region_node->region.offset,
+					     region_node->region.len);
+			list_del(elt);
+			kfree(region_node);
+	}
+	/* delete the master file */
+	pmem_unlock_data_and_mm(data, mm);
+}
+
+static void pmem_get_size(struct pmem_region *region, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	int id = get_id(file);
+
+	if (!has_allocation(file)) {
+		region->offset = 0;
+		region->len = 0;
+		return;
+	} else {
+		region->offset = pmem_start_addr(id, data);
+		region->len = pmem_len(id, data);
+	}
+	DLOG("offset %lx len %lx\n", region->offset, region->len);
+}
+
+
+static long pmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+
+	switch (cmd) {
+	case PMEM_GET_PHYS:
+		{
+			struct pmem_region region;
+			DLOG("get_phys\n");
+			if (!has_allocation(file)) {
+				region.offset = 0;
+				region.len = 0;
+			} else {
+				data = (struct pmem_data *)file->private_data;
+				region.offset = pmem_start_addr(id, data);
+				region.len = pmem_len(id, data);
+			}
+			printk(KERN_INFO "pmem: request for physical address of pmem region "
+					"from process %d.\n", current->pid);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_MAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_MAP);
+		}
+		break;
+	case PMEM_UNMAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_UNMAP);
+			break;
+		}
+	case PMEM_GET_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get_size\n");
+			pmem_get_size(&region, file);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_GET_TOTAL_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get total size\n");
+			region.offset = 0;
+			get_id(file);
+			region.len = pmem[id].size;
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_ALLOCATE:
+		{
+			if (has_allocation(file))
+				return -EINVAL;
+			data = (struct pmem_data *)file->private_data;
+			data->index = pmem_allocate(id, arg);
+			break;
+		}
+	case PMEM_CONNECT:
+		DLOG("connect\n");
+		return pmem_connect(arg, file);
+		break;
+	case PMEM_CACHE_FLUSH:
+		{
+			struct pmem_region region;
+			DLOG("flush\n");
+			if (copy_from_user(&region, (void __user *)arg,
+					   sizeof(struct pmem_region)))
+				return -EFAULT;
+			flush_pmem_file(file, region.offset, region.len);
+			break;
+		}
+	default:
+		if (pmem[id].ioctl)
+			return pmem[id].ioctl(file, cmd, arg);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if PMEM_DEBUG
+static ssize_t debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t debug_read(struct file *file, char __user *buf, size_t count,
+			  loff_t *ppos)
+{
+	struct list_head *elt, *elt2;
+	struct pmem_data *data;
+	struct pmem_region_node *region_node;
+	int id = (int)file->private_data;
+	const int debug_bufmax = 4096;
+	static char buffer[4096];
+	int n = 0;
+
+	DLOG("debug open\n");
+	n = scnprintf(buffer, debug_bufmax,
+		      "pid #: mapped regions (offset, len) (offset,len)...\n");
+
+	down(&pmem[id].data_list_sem);
+	list_for_each(elt, &pmem[id].data_list) {
+		data = list_entry(elt, struct pmem_data, list);
+		down_read(&data->sem);
+		n += scnprintf(buffer + n, debug_bufmax - n, "pid %u:",
+				data->pid);
+		list_for_each(elt2, &data->region_list) {
+			region_node = list_entry(elt2, struct pmem_region_node,
+				      list);
+			n += scnprintf(buffer + n, debug_bufmax - n,
+					"(%lx,%lx) ",
+					region_node->region.offset,
+					region_node->region.len);
+		}
+		n += scnprintf(buffer + n, debug_bufmax - n, "\n");
+		up_read(&data->sem);
+	}
+	up(&pmem[id].data_list_sem);
+
+	n++;
+	buffer[n] = 0;
+	return simple_read_from_buffer(buf, count, ppos, buffer, n);
+}
+
+static struct file_operations debug_fops = {
+	.read = debug_read,
+	.open = debug_open,
+};
+#endif
+
+#if 0
+static struct miscdevice pmem_dev = {
+	.name = "pmem",
+	.fops = &pmem_fops,
+};
+#endif
+
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *))
+{
+	int err = 0;
+	int i, index = 0;
+	int id = id_count;
+	id_count++;
+
+	pmem[id].no_allocator = pdata->no_allocator;
+	pmem[id].cached = pdata->cached;
+	pmem[id].buffered = pdata->buffered;
+	pmem[id].base = pdata->start;
+	pmem[id].size = pdata->size;
+	pmem[id].ioctl = ioctl;
+	pmem[id].release = release;
+	init_rwsem(&pmem[id].bitmap_sem);
+	init_MUTEX(&pmem[id].data_list_sem);
+	INIT_LIST_HEAD(&pmem[id].data_list);
+	pmem[id].dev.name = pdata->name;
+	pmem[id].dev.minor = id;
+	pmem[id].dev.fops = &pmem_fops;
+	printk(KERN_INFO "%s: %d init\n", pdata->name, pdata->cached);
+
+	err = misc_register(&pmem[id].dev);
+	if (err) {
+		printk(KERN_ALERT "Unable to register pmem driver!\n");
+		goto err_cant_register_device;
+	}
+	pmem[id].num_entries = pmem[id].size / PMEM_MIN_ALLOC;
+
+	pmem[id].bitmap = kmalloc(pmem[id].num_entries *
+				  sizeof(struct pmem_bits), GFP_KERNEL);
+	if (!pmem[id].bitmap)
+		goto err_no_mem_for_metadata;
+
+	memset(pmem[id].bitmap, 0, sizeof(struct pmem_bits) *
+					  pmem[id].num_entries);
+
+	for (i = sizeof(pmem[id].num_entries) * 8 - 1; i >= 0; i--) {
+		if ((pmem[id].num_entries) &  1<<i) {
+			PMEM_ORDER(id, index) = i;
+			index = PMEM_NEXT_INDEX(id, index);
+		}
+	}
+
+	if (pmem[id].cached)
+		pmem[id].vbase = ioremap_cached(pmem[id].base,
+						pmem[id].size);
+#ifdef ioremap_ext_buffered
+	else if (pmem[id].buffered)
+		pmem[id].vbase = ioremap_ext_buffered(pmem[id].base,
+						      pmem[id].size);
+#endif
+	else
+		pmem[id].vbase = ioremap(pmem[id].base, pmem[id].size);
+
+	if (pmem[id].vbase == 0)
+		goto error_cant_remap;
+
+	pmem[id].garbage_pfn = page_to_pfn(alloc_page(GFP_KERNEL));
+	if (pmem[id].no_allocator)
+		pmem[id].allocated = 0;
+
+#if PMEM_DEBUG
+	debugfs_create_file(pdata->name, S_IFREG | S_IRUGO, NULL, (void *)id,
+			    &debug_fops);
+#endif
+	return 0;
+error_cant_remap:
+	kfree(pmem[id].bitmap);
+err_no_mem_for_metadata:
+	misc_deregister(&pmem[id].dev);
+err_cant_register_device:
+	return -1;
+}
+
+static int pmem_probe(struct platform_device *pdev)
+{
+	struct android_pmem_platform_data *pdata;
+
+	if (!pdev || !pdev->dev.platform_data) {
+		printk(KERN_ALERT "Unable to probe pmem!\n");
+		return -1;
+	}
+	pdata = pdev->dev.platform_data;
+	return pmem_setup(pdata, NULL, NULL);
+}
+
+
+static int pmem_remove(struct platform_device *pdev)
+{
+	int id = pdev->id;
+	__free_page(pfn_to_page(pmem[id].garbage_pfn));
+	misc_deregister(&pmem[id].dev);
+	return 0;
+}
+
+static struct platform_driver pmem_driver = {
+	.probe = pmem_probe,
+	.remove = pmem_remove,
+	.driver = { .name = "android_pmem" }
+};
+
+
+static int __init pmem_init(void)
+{
+	return platform_driver_register(&pmem_driver);
+}
+
+static void __exit pmem_exit(void)
+{
+	platform_driver_unregister(&pmem_driver);
+}
+
+module_init(pmem_init);
+module_exit(pmem_exit);
+
diff -Nur linux-2.6.35.7/drivers/misc/pn544.c tiny210/drivers/misc/pn544.c
--- linux-2.6.35.7/drivers/misc/pn544.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/pn544.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,353 @@
+/*
+ * Copyright (C) 2010 Trusted Logic S.A.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/pn544.h>
+
+#define MAX_BUFFER_SIZE	256
+
+struct pn544_dev	{
+	wait_queue_head_t	read_wq;
+	struct mutex		read_mutex;
+	struct i2c_client	*client;
+	struct miscdevice	pn544_device;
+	unsigned int 		ven_gpio;
+	unsigned int 		firm_gpio;
+	unsigned int		irq_gpio;
+	bool			irq_enabled;
+	spinlock_t		irq_enabled_lock;
+};
+
+static void pn544_disable_irq(struct pn544_dev *pn544_dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pn544_dev->irq_enabled_lock, flags);
+	if (pn544_dev->irq_enabled) {
+		disable_irq_nosync(pn544_dev->client->irq);
+		pn544_dev->irq_enabled = false;
+	}
+	spin_unlock_irqrestore(&pn544_dev->irq_enabled_lock, flags);
+}
+
+static irqreturn_t pn544_dev_irq_handler(int irq, void *dev_id)
+{
+	struct pn544_dev *pn544_dev = dev_id;
+
+	pn544_disable_irq(pn544_dev);
+
+	/* Wake up waiting readers */
+	wake_up(&pn544_dev->read_wq);
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t pn544_dev_read(struct file *filp, char __user *buf,
+		size_t count, loff_t *offset)
+{
+	struct pn544_dev *pn544_dev = filp->private_data;
+	char tmp[MAX_BUFFER_SIZE];
+	int ret;
+
+	if (count > MAX_BUFFER_SIZE)
+		count = MAX_BUFFER_SIZE;
+
+	pr_debug("%s : reading %zu bytes.\n", __func__, count);
+
+	mutex_lock(&pn544_dev->read_mutex);
+
+	if (!gpio_get_value(pn544_dev->irq_gpio)) {
+		if (filp->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			goto fail;
+		}
+
+		pn544_dev->irq_enabled = true;
+		enable_irq(pn544_dev->client->irq);
+		ret = wait_event_interruptible(pn544_dev->read_wq,
+				gpio_get_value(pn544_dev->irq_gpio));
+
+		pn544_disable_irq(pn544_dev);
+
+		if (ret)
+			goto fail;
+
+	}
+
+	/* Read data */
+	ret = i2c_master_recv(pn544_dev->client, tmp, count);
+	mutex_unlock(&pn544_dev->read_mutex);
+
+	if (ret < 0) {
+		pr_err("%s: i2c_master_recv returned %d\n", __func__, ret);
+		return ret;
+	}
+	if (ret > count) {
+		pr_err("%s: received too many bytes from i2c (%d)\n",
+			__func__, ret);
+		return -EIO;
+	}
+	if (copy_to_user(buf, tmp, ret)) {
+		pr_warning("%s : failed to copy to user space\n", __func__);
+		return -EFAULT;
+	}
+	return ret;
+
+fail:
+	mutex_unlock(&pn544_dev->read_mutex);
+	return ret;
+}
+
+static ssize_t pn544_dev_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *offset)
+{
+	struct pn544_dev  *pn544_dev;
+	char tmp[MAX_BUFFER_SIZE];
+	int ret;
+
+	pn544_dev = filp->private_data;
+
+	if (count > MAX_BUFFER_SIZE)
+		count = MAX_BUFFER_SIZE;
+
+	if (copy_from_user(tmp, buf, count)) {
+		pr_err("%s : failed to copy from user space\n", __func__);
+		return -EFAULT;
+	}
+
+	pr_debug("%s : writing %zu bytes.\n", __func__, count);
+	/* Write data */
+	ret = i2c_master_send(pn544_dev->client, tmp, count);
+	if (ret != count) {
+		pr_err("%s : i2c_master_send returned %d\n", __func__, ret);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static int pn544_dev_open(struct inode *inode, struct file *filp)
+{
+	struct pn544_dev *pn544_dev = container_of(filp->private_data,
+						struct pn544_dev,
+						pn544_device);
+
+	filp->private_data = pn544_dev;
+
+	pr_debug("%s : %d,%d\n", __func__, imajor(inode), iminor(inode));
+
+	return 0;
+}
+
+static int pn544_dev_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	struct pn544_dev *pn544_dev = filp->private_data;
+
+	switch (cmd) {
+	case PN544_SET_PWR:
+		if (arg > 1) {  /* enable with firmware download */
+			pr_info("%s power on with firmware\n", __func__);
+			gpio_set_value(pn544_dev->firm_gpio, 1);
+			gpio_set_value(pn544_dev->ven_gpio, 1);
+			msleep(3);
+		} else if (arg == 1) {  /* enable */
+			pr_info("%s power on\n", __func__);
+			gpio_set_value(pn544_dev->firm_gpio, 0);
+			gpio_set_value(pn544_dev->ven_gpio, 1);
+			msleep(3);
+		} else {
+			pr_info("%s power off\n", __func__);
+			gpio_set_value(pn544_dev->firm_gpio, 0);
+			gpio_set_value(pn544_dev->ven_gpio, 0);
+			msleep(7);
+		}
+		break;
+	default:
+		pr_err("%s bad ioctl %u\n", __func__, cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct file_operations pn544_dev_fops = {
+	.owner	= THIS_MODULE,
+	.llseek	= no_llseek,
+	.read	= pn544_dev_read,
+	.write	= pn544_dev_write,
+	.open	= pn544_dev_open,
+	.ioctl  = pn544_dev_ioctl,
+};
+
+static int pn544_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int ret;
+	struct pn544_i2c_platform_data *platform_data;
+	struct pn544_dev *pn544_dev;
+
+	platform_data = client->dev.platform_data;
+
+	if (platform_data == NULL) {
+		pr_err("%s : nfc probe fail\n", __func__);
+		return  -ENODEV;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s : need I2C_FUNC_I2C\n", __func__);
+		return  -ENODEV;
+	}
+
+	ret = gpio_request(platform_data->irq_gpio, "nfc_int");
+	if (ret)
+		return  -ENODEV;
+	ret = gpio_request(platform_data->ven_gpio, "nfc_ven");
+	if (ret)
+		goto err_ven;
+	ret = gpio_request(platform_data->firm_gpio, "nfc_firm");
+	if (ret)
+		goto err_firm;
+
+	pn544_dev = kzalloc(sizeof(*pn544_dev), GFP_KERNEL);
+	if (pn544_dev == NULL) {
+		dev_err(&client->dev,
+				"failed to allocate memory for module data\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	pn544_dev->irq_gpio = platform_data->irq_gpio;
+	pn544_dev->ven_gpio  = platform_data->ven_gpio;
+	pn544_dev->firm_gpio  = platform_data->firm_gpio;
+	pn544_dev->client   = client;
+
+	/* init mutex and queues */
+	init_waitqueue_head(&pn544_dev->read_wq);
+	mutex_init(&pn544_dev->read_mutex);
+	spin_lock_init(&pn544_dev->irq_enabled_lock);
+
+	pn544_dev->pn544_device.minor = MISC_DYNAMIC_MINOR;
+	pn544_dev->pn544_device.name = "pn544";
+	pn544_dev->pn544_device.fops = &pn544_dev_fops;
+
+	ret = misc_register(&pn544_dev->pn544_device);
+	if (ret) {
+		pr_err("%s : misc_register failed\n", __FILE__);
+		goto err_misc_register;
+	}
+
+	/* request irq.  the irq is set whenever the chip has data available
+	 * for reading.  it is cleared when all data has been read.
+	 */
+	pr_info("%s : requesting IRQ %d\n", __func__, client->irq);
+	pn544_dev->irq_enabled = true;
+	ret = request_irq(client->irq, pn544_dev_irq_handler,
+			  IRQF_TRIGGER_HIGH, client->name, pn544_dev);
+	if (ret) {
+		dev_err(&client->dev, "request_irq failed\n");
+		goto err_request_irq_failed;
+	}
+	pn544_disable_irq(pn544_dev);
+	i2c_set_clientdata(client, pn544_dev);
+
+	return 0;
+
+err_request_irq_failed:
+	misc_deregister(&pn544_dev->pn544_device);
+err_misc_register:
+	mutex_destroy(&pn544_dev->read_mutex);
+	kfree(pn544_dev);
+err_exit:
+	gpio_free(platform_data->firm_gpio);
+err_firm:
+	gpio_free(platform_data->ven_gpio);
+err_ven:
+	gpio_free(platform_data->irq_gpio);
+	return ret;
+}
+
+static int pn544_remove(struct i2c_client *client)
+{
+	struct pn544_dev *pn544_dev;
+
+	pn544_dev = i2c_get_clientdata(client);
+	free_irq(client->irq, pn544_dev);
+	misc_deregister(&pn544_dev->pn544_device);
+	mutex_destroy(&pn544_dev->read_mutex);
+	gpio_free(pn544_dev->irq_gpio);
+	gpio_free(pn544_dev->ven_gpio);
+	gpio_free(pn544_dev->firm_gpio);
+	kfree(pn544_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id pn544_id[] = {
+	{ "pn544", 0 },
+	{ }
+};
+
+static struct i2c_driver pn544_driver = {
+	.id_table	= pn544_id,
+	.probe		= pn544_probe,
+	.remove		= pn544_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "pn544",
+	},
+};
+
+/*
+ * module load/unload record keeping
+ */
+
+static int __init pn544_dev_init(void)
+{
+	pr_info("Loading pn544 driver\n");
+	return i2c_add_driver(&pn544_driver);
+}
+module_init(pn544_dev_init);
+
+static void __exit pn544_dev_exit(void)
+{
+	pr_info("Unloading pn544 driver\n");
+	i2c_del_driver(&pn544_driver);
+}
+module_exit(pn544_dev_exit);
+
+MODULE_AUTHOR("Sylvain Fonteneau");
+MODULE_DESCRIPTION("NFC PN544 driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/Makefile tiny210/drivers/misc/samsung_modemctl/Makefile
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/Makefile	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1 @@
+obj-y += modem_ctl.o modem_io.o modem_dbg.o
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl.c tiny210/drivers/misc/samsung_modemctl/modem_ctl.c
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/modem_ctl.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,711 @@
+/* modem_ctl.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2010 Samsung Electronics.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/wakelock.h>
+
+#include "modem_ctl.h"
+#include "modem_ctl_p.h"
+
+/* The modem_ctl portion of this driver handles modem lifecycle
+ * transitions (OFF -> ON -> RUNNING -> ABNORMAL), the firmware
+ * download mechanism (via /dev/modem_ctl), and interrupts from
+ * the modem (direct and via onedram mailbox interrupt).
+ *
+ * It also handles tracking the ownership of the onedram "semaphore"
+ * which governs which processor (AP or BP) has access to the 16MB
+ * shared memory region.  The modem_mmio_{acquire,release,request}
+ * primitives are used by modem_io.c to obtain access to the shared
+ * memory region when necessary to do io.
+ *
+ * Further, modem_update_state() and modem_handle_io() are called
+ * when we gain control over the shared memory region (to update
+ * fifo state info) and when there may be io to process, respectively.
+ *
+ */
+
+#define WAIT_TIMEOUT                (HZ*5)
+
+void modem_request_sem(struct modemctl *mc)
+{
+	writel(MB_COMMAND | MB_VALID | MBC_REQ_SEM,
+	       mc->mmio + OFF_MBOX_AP);
+}
+
+static inline int mmio_sem(struct modemctl *mc)
+{
+	return readl(mc->mmio + OFF_SEM) & 1;
+}
+
+int modem_request_mmio(struct modemctl *mc)
+{
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&mc->lock, flags);
+	mc->mmio_req_count++;
+	ret = mc->mmio_owner;
+	if (!ret) {
+		if (mmio_sem(mc) == 1) {
+			/* surprise! we already have control */
+			ret = mc->mmio_owner = 1;
+			wake_up(&mc->wq);
+			modem_update_state(mc);
+			MODEM_COUNT(mc,request_no_wait);
+		} else {
+			/* ask the modem for mmio access */
+			if (modem_running(mc))
+				modem_request_sem(mc);
+			MODEM_COUNT(mc,request_wait);
+		}
+	} else {
+		MODEM_COUNT(mc,request_no_wait);
+	}
+	/* TODO: timer to retry? */
+	spin_unlock_irqrestore(&mc->lock, flags);
+	return ret;
+}
+
+void modem_release_mmio(struct modemctl *mc, unsigned bits)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&mc->lock, flags);
+	mc->mmio_req_count--;
+	mc->mmio_signal_bits |= bits;
+	if ((mc->mmio_req_count == 0) && modem_running(mc)) {
+		if (mc->mmio_bp_request) {
+			mc->mmio_bp_request = 0;
+			writel(0, mc->mmio + OFF_SEM);
+			writel(MB_COMMAND | MB_VALID | MBC_RES_SEM,
+			       mc->mmio + OFF_MBOX_AP);
+			MODEM_COUNT(mc,release_bp_waiting);
+		} else if (mc->mmio_signal_bits) {
+			writel(0, mc->mmio + OFF_SEM);
+			writel(MB_VALID | mc->mmio_signal_bits,
+			       mc->mmio + OFF_MBOX_AP);
+			MODEM_COUNT(mc,release_bp_signaled);
+		} else {
+			MODEM_COUNT(mc,release_no_action);
+		}
+		mc->mmio_owner = 0;
+		mc->mmio_signal_bits = 0;
+	}
+	spin_unlock_irqrestore(&mc->lock, flags);
+}
+
+static int mmio_owner_p(struct modemctl *mc)
+{
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&mc->lock, flags);
+	ret = mc->mmio_owner || modem_offline(mc);
+	spin_unlock_irqrestore(&mc->lock, flags);
+	return ret;
+}
+
+int modem_acquire_mmio(struct modemctl *mc)
+{
+	if (modem_request_mmio(mc) == 0) {
+		int ret = wait_event_interruptible_timeout(
+			mc->wq, mmio_owner_p(mc), 5 * HZ);
+		if (ret == 0) {
+			pr_err("modem_acquire_mmio() TIMEOUT\n");
+			return -ENODEV;
+		}
+		if (ret < 0) {
+			modem_release_mmio(mc, 0);
+			return -ERESTARTSYS;
+		}
+	}
+	if (!modem_running(mc)) {
+		modem_release_mmio(mc, 0);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int modemctl_open(struct inode *inode, struct file *filp)
+{
+	struct modemctl *mc = to_modemctl(filp->private_data);
+	filp->private_data = mc;
+
+	if (mc->open_count)
+		return -EBUSY;
+
+	mc->open_count++;
+	return 0;
+}
+
+static int modemctl_release(struct inode *inode, struct file *filp)
+{
+	struct modemctl *mc = filp->private_data;
+
+	mc->open_count = 0;
+	filp->private_data = NULL;
+	return 0;
+}
+
+static ssize_t modemctl_read(struct file *filp, char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	struct modemctl *mc = filp->private_data;
+	loff_t pos;
+	int ret;
+
+	mutex_lock(&mc->ctl_lock);
+	pos = mc->ramdump_pos;
+	if (mc->status != MODEM_DUMPING) {
+		pr_err("[MODEM] not in ramdump mode\n");
+		ret = -ENODEV;
+		goto done;
+	}
+	if (pos < 0) {
+		ret = -EINVAL;
+		goto done;
+	}
+	if (pos >= mc->ramdump_size) {
+		pr_err("[MODEM] ramdump EOF\n");
+		ret = 0;
+		goto done;
+	}
+	if (count > mc->ramdump_size - pos)
+		count = mc->ramdump_size - pos;
+
+	ret = copy_to_user(buf, mc->mmio + pos, count);
+	if (ret) {
+		ret = -EFAULT;
+		goto done;
+	}
+	pos += count;
+	ret = count;
+
+	if (pos == mc->ramdump_size) {
+		if (mc->ramdump_size == RAMDUMP_LARGE_SIZE) {
+			mc->ramdump_size = 0;
+			pr_info("[MODEM] requesting more ram\n");
+			writel(0, mc->mmio + OFF_SEM);
+			writel(MODEM_CMD_RAMDUMP_MORE, mc->mmio + OFF_MBOX_AP);
+			wait_event_timeout(mc->wq, mc->ramdump_size != 0, 10 * HZ);
+		} else {
+			pr_info("[MODEM] no more ram to dump\n");
+			mc->ramdump_size = 0;
+		}
+		mc->ramdump_pos = 0;
+	} else {
+		mc->ramdump_pos = pos;
+	}
+	
+done:
+	mutex_unlock(&mc->ctl_lock);
+	return ret;
+
+}
+
+static ssize_t modemctl_write(struct file *filp, const char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct modemctl *mc = filp->private_data;
+	u32 owner;
+	char *data;
+	loff_t pos = *ppos;
+	unsigned long ret;
+
+	mutex_lock(&mc->ctl_lock);
+	data = (char __force *)mc->mmio + pos;
+	owner = mmio_sem(mc);
+
+	if (mc->status != MODEM_POWER_ON) {
+		pr_err("modemctl_write: modem not powered on\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (!owner) {
+		pr_err("modemctl_write: doesn't own semaphore\n");
+		ret = -EIO;
+		goto done;
+	}
+
+	if (pos < 0) {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (pos >= mc->mmsize) {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (count > mc->mmsize - pos)
+		count = mc->mmsize - pos;
+
+	ret = copy_from_user(data, buf, count);
+	if (ret) {
+		ret = -EFAULT;
+		goto done;
+	}
+	*ppos = pos + count;
+	ret = count;
+
+done:
+	mutex_unlock(&mc->ctl_lock);
+	return ret;
+}
+
+
+static int modem_start(struct modemctl *mc, int ramdump)
+{
+	int ret;
+
+	pr_info("[MODEM] modem_start() %s\n",
+		ramdump ? "ramdump" : "normal");
+
+	if (mc->status != MODEM_POWER_ON) {
+		pr_err("[MODEM] modem not powered on\n");
+		return -EINVAL;
+	}
+
+	if (readl(mc->mmio + OFF_MBOX_BP) != MODEM_MSG_SBL_DONE) {
+		pr_err("[MODEM] bootloader not ready\n");
+		return -EIO;
+	}
+
+	if (mmio_sem(mc) != 1) {
+		pr_err("[MODEM] we do not own the semaphore\n");
+		return -EIO;
+	}
+
+	writel(0, mc->mmio + OFF_SEM);
+	if (ramdump) {
+		mc->status = MODEM_BOOTING_RAMDUMP;
+		mc->ramdump_size = 0;
+		mc->ramdump_pos = 0;
+		writel(MODEM_CMD_RAMDUMP_START, mc->mmio + OFF_MBOX_AP);
+
+		ret = wait_event_timeout(mc->wq, mc->status == MODEM_DUMPING, 25 * HZ);
+		if (ret == 0)
+			return -ENODEV;
+	} else {
+		mc->status = MODEM_BOOTING_NORMAL;
+		writel(MODEM_CMD_BINARY_LOAD, mc->mmio + OFF_MBOX_AP);
+
+		ret = wait_event_timeout(mc->wq, modem_running(mc), 25 * HZ);
+		if (ret == 0)
+			return -ENODEV;
+	}
+
+	pr_info("[MODEM] modem_start() DONE\n");
+	return 0;
+}
+
+static int modem_reset(struct modemctl *mc)
+{
+	pr_info("[MODEM] modem_reset()\n");
+
+	/* ensure phone active pin irq type */
+	set_irq_type(mc->gpio_phone_active, IRQ_TYPE_EDGE_BOTH);
+
+	/* ensure pda active pin set to low */
+	gpio_set_value(mc->gpio_pda_active, 0);
+
+	/* read inbound mbox to clear pending IRQ */
+	(void) readl(mc->mmio + OFF_MBOX_BP);
+
+	/* write outbound mbox to assert outbound IRQ */
+	writel(0, mc->mmio + OFF_MBOX_AP);
+
+	/* ensure cp_reset pin set to low */
+	gpio_set_value(mc->gpio_cp_reset, 0);
+	msleep(100);
+
+	gpio_set_value(mc->gpio_cp_reset, 0);
+	msleep(100);
+
+	gpio_set_value(mc->gpio_cp_reset, 1);
+
+	/* Follow RESET timming delay not Power-On timming,
+	   because CP_RST & PHONE_ON have been set high already. */
+	msleep(100); /*wait modem stable */
+
+	gpio_set_value(mc->gpio_pda_active, 1);
+
+	mc->status = MODEM_POWER_ON;
+
+	return 0;
+}
+
+static int modem_off(struct modemctl *mc)
+{
+	pr_info("[MODEM] modem_off()\n");
+	gpio_set_value(mc->gpio_cp_reset, 0);
+	mc->status = MODEM_OFF;
+	return 0;
+}
+
+static long modemctl_ioctl(struct file *filp,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct modemctl *mc = filp->private_data;
+	int ret;
+
+	mutex_lock(&mc->ctl_lock);
+	switch (cmd) {
+	case IOCTL_MODEM_RESET:
+		ret = modem_reset(mc);
+		MODEM_COUNT(mc,resets);
+		break;
+	case IOCTL_MODEM_START:
+		ret = modem_start(mc, 0);
+		break;
+	case IOCTL_MODEM_RAMDUMP:
+		ret = modem_start(mc, 1);
+		break;
+	case IOCTL_MODEM_OFF:
+		ret = modem_off(mc);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&mc->ctl_lock);
+	pr_info("modemctl_ioctl() %d\n", ret);
+	return ret;
+}
+
+static const struct file_operations modemctl_fops = {
+	.owner =		THIS_MODULE,
+	.open =			modemctl_open,
+	.release =		modemctl_release,
+	.read =			modemctl_read,
+	.write =		modemctl_write,
+	.unlocked_ioctl =	modemctl_ioctl,
+};
+
+static irqreturn_t modemctl_bp_irq_handler(int irq, void *_mc)
+{
+	pr_info("[MODEM] bp_irq()\n");
+	return IRQ_HANDLED;
+
+}
+
+static void modemctl_handle_offline(struct modemctl *mc, unsigned cmd)
+{
+	switch (mc->status) {
+	case MODEM_BOOTING_NORMAL:
+		if (cmd == MODEM_MSG_BINARY_DONE) {
+			pr_info("[MODEM] binary load done\n");
+			mc->status = MODEM_RUNNING;
+			wake_up(&mc->wq);
+		}
+		break;
+	case MODEM_BOOTING_RAMDUMP:
+	case MODEM_DUMPING:
+		if (cmd == MODEM_MSG_RAMDUMP_LARGE) {
+			mc->status = MODEM_DUMPING;
+			mc->ramdump_size = RAMDUMP_LARGE_SIZE;
+			wake_up(&mc->wq);
+			pr_info("[MODEM] ramdump - %d bytes available\n",
+				mc->ramdump_size);
+		} else if (cmd == MODEM_MSG_RAMDUMP_SMALL) {
+			mc->status = MODEM_DUMPING;
+			mc->ramdump_size = RAMDUMP_SMALL_SIZE;
+			wake_up(&mc->wq);
+			pr_info("[MODEM] ramdump - %d bytes available\n",
+				mc->ramdump_size);
+		} else {
+			pr_err("[MODEM] unknown msg %08x in ramdump mode\n", cmd);
+		}
+		break;
+	}
+}
+
+static irqreturn_t modemctl_mbox_irq_handler(int irq, void *_mc)
+{
+	struct modemctl *mc = _mc;
+	unsigned cmd;
+	unsigned long flags;
+
+	cmd = readl(mc->mmio + OFF_MBOX_BP);
+
+	if (unlikely(mc->status != MODEM_RUNNING)) {
+		modemctl_handle_offline(mc, cmd);
+		return IRQ_HANDLED;
+	}
+
+	if (!(cmd & MB_VALID)) {
+		if (cmd == MODEM_MSG_LOGDUMP_DONE) {
+			pr_info("modem: logdump done!\n");
+			mc->logdump_data = 1;
+			wake_up(&mc->wq);
+		} else {
+			pr_info("modem: what is %08x\n",cmd);
+		}
+		return IRQ_HANDLED;
+	}
+
+	spin_lock_irqsave(&mc->lock, flags);
+
+	if (cmd & MB_COMMAND) {
+		switch (cmd & 15) {
+		case MBC_REQ_SEM:
+			if (mmio_sem(mc) == 0) {
+				/* Sometimes the modem may ask for the
+				 * sem when it already owns it.  Humor
+				 * it and ack that request.
+				 */
+				writel(MB_COMMAND | MB_VALID | MBC_RES_SEM,
+				       mc->mmio + OFF_MBOX_AP);
+				MODEM_COUNT(mc,bp_req_confused);
+			} else if (mc->mmio_req_count == 0) {
+				/* No references? Give it to the modem. */
+				mc->mmio_owner = 0;
+				writel(0, mc->mmio + OFF_SEM);
+				writel(MB_COMMAND | MB_VALID | MBC_RES_SEM,
+				       mc->mmio + OFF_MBOX_AP);
+				MODEM_COUNT(mc,bp_req_instant);
+				goto done;
+			} else {
+				/* Busy now, remember the modem needs it. */
+				mc->mmio_bp_request = 1;
+				MODEM_COUNT(mc,bp_req_delayed);
+				break;
+			}
+		case MBC_RES_SEM:
+			break;
+		case MBC_PHONE_START:
+			/* TODO: should we avoid sending any other messages
+			 * to the modem until this message is received and
+			 * acknowledged?
+			 */
+			writel(MB_COMMAND | MB_VALID |
+			       MBC_INIT_END | CP_BOOT_AIRPLANE | AP_OS_ANDROID,
+			       mc->mmio + OFF_MBOX_AP);
+
+			/* TODO: probably unsafe to send this back-to-back
+			 * with the INIT_END message.
+			 */
+			/* if somebody is waiting for mmio access... */
+			if (mc->mmio_req_count)
+				modem_request_sem(mc);
+			break;
+		case MBC_RESET:
+			pr_err("$$$ MODEM RESET $$$\n");
+			mc->status = MODEM_CRASHED;
+			wake_up(&mc->wq);
+			break;
+		case MBC_ERR_DISPLAY: {
+			char buf[SIZ_ERROR_MSG + 1];
+			int i;
+			pr_err("$$$ MODEM ERROR $$$\n");
+			mc->status = MODEM_CRASHED;
+			wake_up(&mc->wq);
+			memcpy(buf, mc->mmio + OFF_ERROR_MSG, SIZ_ERROR_MSG);
+			for (i = 0; i < SIZ_ERROR_MSG; i++)
+				if ((buf[i] < 0x20) || (buf[1] > 0x7e))
+					buf[i] = 0x20;
+			buf[i] = 0;
+			i--;
+			while ((i > 0) && (buf[i] == 0x20))
+				buf[i--] = 0;
+			pr_err("$$$ %s $$$\n", buf);
+			break;
+		}
+		case MBC_SUSPEND:
+			break;
+		case MBC_RESUME:
+			break;
+		}
+	}
+
+	/* On *any* interrupt from the modem it may have given
+	 * us ownership of the mmio hw semaphore.  If that
+	 * happens, we should claim the semaphore if we have
+	 * threads waiting for it and we should process any
+	 * messages that the modem has enqueued in its fifos
+	 * by calling modem_handle_io().
+	 */
+	if (mmio_sem(mc) == 1) {
+		if (!mc->mmio_owner) {
+			modem_update_state(mc);
+			if (mc->mmio_req_count) {
+				mc->mmio_owner = 1;
+				wake_up(&mc->wq);
+			}
+		}
+
+		modem_handle_io(mc);
+
+		/* If we have a signal to send and we're not
+		 * hanging on to the mmio hw semaphore, give
+		 * it back to the modem and send the signal.
+		 * Otherwise this will happen when we give up
+		 * the mmio hw sem in modem_release_mmio().
+		 */
+		if (mc->mmio_signal_bits && !mc->mmio_owner) {
+			writel(0, mc->mmio + OFF_SEM);
+			writel(MB_VALID | mc->mmio_signal_bits,
+			       mc->mmio + OFF_MBOX_AP);
+			mc->mmio_signal_bits = 0;
+		}
+	}
+done:
+	spin_unlock_irqrestore(&mc->lock, flags);
+	return IRQ_HANDLED;
+}
+
+void modem_force_crash(struct modemctl *mc)
+{
+	unsigned long int flags;
+	pr_info("modem_force_crash() BOOM!\n");
+	spin_lock_irqsave(&mc->lock, flags);
+	mc->status = MODEM_CRASHED;
+	wake_up(&mc->wq);
+	spin_unlock_irqrestore(&mc->lock, flags);
+}
+
+static int __devinit modemctl_probe(struct platform_device *pdev)
+{
+	int r = -ENOMEM;
+	struct modemctl *mc;
+	struct modemctl_data *pdata;
+	struct resource *res;
+
+	pdata = pdev->dev.platform_data;
+
+	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
+	if (!mc)
+		return -ENOMEM;
+
+	init_waitqueue_head(&mc->wq);
+	spin_lock_init(&mc->lock);
+	mutex_init(&mc->ctl_lock);
+
+	mc->irq_bp = platform_get_irq_byname(pdev, "active");
+	mc->irq_mbox = platform_get_irq_byname(pdev, "onedram");
+
+	mc->gpio_phone_active = pdata->gpio_phone_active;
+	mc->gpio_pda_active = pdata->gpio_pda_active;
+	mc->gpio_cp_reset = pdata->gpio_cp_reset;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		goto err_free;
+	mc->mmbase = res->start;
+	mc->mmsize = resource_size(res);
+
+	mc->mmio = ioremap_nocache(mc->mmbase, mc->mmsize);
+	if (!mc->mmio)
+		goto err_free;
+
+	platform_set_drvdata(pdev, mc);
+
+	mc->dev.name = "modem_ctl";
+	mc->dev.minor = MISC_DYNAMIC_MINOR;
+	mc->dev.fops = &modemctl_fops;
+	r = misc_register(&mc->dev);
+	if (r)
+		goto err_ioremap;
+
+	/* hide control registers from userspace */
+	mc->mmsize -= 0x800;
+	mc->status = MODEM_OFF;
+
+	wake_lock_init(&mc->ip_tx_wakelock,
+		       WAKE_LOCK_SUSPEND, "modem_ip_tx");
+	wake_lock_init(&mc->ip_rx_wakelock,
+		       WAKE_LOCK_SUSPEND, "modem_ip_rx");
+
+	modem_io_init(mc, mc->mmio);
+
+	r = request_irq(mc->irq_bp, modemctl_bp_irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"modemctl_bp", mc);
+	if (r)
+		goto err_ioremap;
+
+	r = request_irq(mc->irq_mbox, modemctl_mbox_irq_handler,
+			IRQF_TRIGGER_LOW, "modemctl_mbox", mc);
+	if (r)
+		goto err_irq_bp;
+
+	enable_irq_wake(mc->irq_bp);
+	enable_irq_wake(mc->irq_mbox);
+
+	modem_debugfs_init(mc);
+
+	return 0;
+
+err_irq_mbox:
+	free_irq(mc->irq_mbox, mc);
+err_irq_bp:
+	free_irq(mc->irq_bp, mc);
+err_ioremap:
+	iounmap(mc->mmio);
+err_free:
+	kfree(mc);
+	return r;
+}
+
+static int modemctl_suspend(struct device *pdev)
+{
+	struct modemctl *mc = dev_get_drvdata(pdev);
+	gpio_set_value(mc->gpio_pda_active, 0);
+	return 0;
+}
+
+static int modemctl_resume(struct device *pdev)
+{
+	struct modemctl *mc = dev_get_drvdata(pdev);
+	gpio_set_value(mc->gpio_pda_active, 1);
+	return 0;
+}
+
+static const struct dev_pm_ops modemctl_pm_ops = {
+	.suspend    = modemctl_suspend,
+	.resume     = modemctl_resume,
+};
+
+static struct platform_driver modemctl_driver = {
+	.probe = modemctl_probe,
+	.driver = {
+		.name = "modemctl",
+		.pm   = &modemctl_pm_ops,
+	},
+};
+
+static int __init modemctl_init(void)
+{
+	return platform_driver_register(&modemctl_driver);
+}
+
+module_init(modemctl_init);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Samsung Modem Control Driver");
+
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl.h tiny210/drivers/misc/samsung_modemctl/modem_ctl.h
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl.h	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/modem_ctl.h	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2010 Samsung Electronics.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MODEM_CONTROL_H__
+#define __MODEM_CONTROL_H__
+
+#define IOCTL_MODEM_RAMDUMP             _IO('o', 0x19)
+#define IOCTL_MODEM_RESET               _IO('o', 0x20)
+#define IOCTL_MODEM_START               _IO('o', 0x21)
+#define IOCTL_MODEM_OFF                 _IO('o', 0x22)
+
+#define IOCTL_MODEM_SEND		_IO('o', 0x23)
+#define IOCTL_MODEM_RECV		_IO('o', 0x24)
+
+struct modem_io {
+	uint32_t size;
+	uint32_t id;
+	uint32_t cmd;
+	void *data;
+};
+
+/* platform data */
+struct modemctl_data {
+	const char *name;
+	unsigned gpio_phone_active;
+	unsigned gpio_pda_active;
+	unsigned gpio_cp_reset;
+};
+
+#endif
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl_p.h tiny210/drivers/misc/samsung_modemctl/modem_ctl_p.h
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_ctl_p.h	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/modem_ctl_p.h	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,312 @@
+/*
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2010 Samsung Electronics.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MODEM_CONTROL_P_H__
+#define __MODEM_CONTROL_P_H__
+
+#define MODEM_OFF		0
+#define MODEM_CRASHED		1
+#define MODEM_RAMDUMP		2
+#define MODEM_POWER_ON		3
+#define MODEM_BOOTING_NORMAL	4
+#define MODEM_BOOTING_RAMDUMP	5
+#define MODEM_DUMPING		6
+#define MODEM_RUNNING		7
+
+#define modem_offline(mc) ((mc)->status < MODEM_POWER_ON)
+#define modem_running(mc) ((mc)->status == MODEM_RUNNING)
+
+#define M_PIPE_MAX_HDR 16
+
+struct net_device;
+
+struct m_pipe {
+	int (*push_header)(struct modem_io *io, void *header);
+	int (*pull_header)(struct modem_io *io, void *header);
+
+	unsigned header_size;
+
+	struct m_fifo *tx;
+	struct m_fifo *rx;
+
+	struct modemctl *mc;
+	unsigned ready;
+
+	struct miscdevice dev;
+
+	struct mutex tx_lock;
+	struct mutex rx_lock;
+
+	struct wake_lock wakelock;
+};
+#define to_m_pipe(misc) container_of(misc, struct m_pipe, dev)
+
+struct m_fifo {
+	unsigned *head;
+	unsigned *tail;
+	unsigned size;
+	void *data;
+
+	unsigned avail;
+	unsigned bits;
+	unsigned unused1;
+	unsigned unused2;
+};
+
+struct modemstats {
+	unsigned request_no_wait;
+	unsigned request_wait;
+
+	unsigned release_no_action;
+	unsigned release_bp_waiting;
+	unsigned release_bp_signaled;
+
+	unsigned bp_req_instant;
+	unsigned bp_req_delayed;
+	unsigned bp_req_confused;
+
+	unsigned rx_unknown;
+	unsigned rx_dropped;
+	unsigned rx_purged;
+	unsigned rx_received;
+
+	unsigned tx_no_delay;
+	unsigned tx_queued;
+	unsigned tx_bp_signaled;
+	unsigned tx_fifo_full;
+
+	unsigned pipe_tx;
+	unsigned pipe_rx;
+	unsigned pipe_tx_delayed;
+	unsigned pipe_rx_purged;
+
+	unsigned resets;
+};
+
+#define MODEM_COUNT(mc,s) (((mc)->stats.s)++)
+
+struct modemctl {
+	void __iomem *mmio;
+	struct modemstats stats;
+
+	/* lock and waitqueue for shared memory state */
+	spinlock_t lock;
+	wait_queue_head_t wq;
+
+	/* shared memory semaphore management */
+	unsigned mmio_req_count;
+	unsigned mmio_bp_request;
+	unsigned mmio_owner;
+	unsigned mmio_signal_bits;
+
+	struct m_fifo fmt_tx;
+	struct m_fifo fmt_rx;
+	struct m_fifo raw_tx;
+	struct m_fifo raw_rx;
+	struct m_fifo rfs_tx;
+	struct m_fifo rfs_rx;
+
+	struct wake_lock ip_tx_wakelock;
+	struct wake_lock ip_rx_wakelock;
+
+	struct net_device *ndev;
+
+	int open_count;
+	int status;
+
+	unsigned mmbase;
+	unsigned mmsize;
+
+	int irq_bp;
+	int irq_mbox;
+
+	unsigned gpio_phone_active;
+	unsigned gpio_pda_active;
+	unsigned gpio_cp_reset;
+
+	struct miscdevice dev;
+
+	struct m_pipe cmd_pipe;
+	struct m_pipe rfs_pipe;
+
+	struct mutex ctl_lock;
+	ktime_t mmio_t0;
+
+	/* used for ramdump mode */
+	unsigned ramdump_size;
+	loff_t ramdump_pos;
+
+	unsigned logdump;
+	unsigned logdump_data;
+};
+#define to_modemctl(misc) container_of(misc, struct modemctl, dev)
+
+
+/* called when semaphore is held and there may be io to process */
+void modem_handle_io(struct modemctl *mc);
+void modem_update_state(struct modemctl *mc);
+
+/* called once at probe() */
+int modem_io_init(struct modemctl *mc, void __iomem *mmio);
+
+/* called when modem boots and goes offline */
+void modem_io_enable(struct modemctl *mc);
+void modem_io_disable(struct modemctl *mc);
+
+
+/* Block until control of mmio area is obtained (0)
+ * or interrupt (-ERESTARTSYS) or failure (-ENODEV)
+ * occurs.
+ */
+int modem_acquire_mmio(struct modemctl *mc);
+
+/* Request control of mmio area.  Returns 1 if
+ * control obtained, 0 if not (request pending).
+ * Either way, release_mmio() must be called to
+ * balance this.
+ */
+int modem_request_mmio(struct modemctl *mc);
+
+/* Return control of mmio area once requested
+ * by modem_request_mmio() or acquired by a
+ * successful modem_acquire_mmio().
+ *
+ * The onedram semaphore is only actually returned
+ * to the BP if there is an outstanding request
+ * for it from the BP, or if the bits argument
+ * to one of the release_mmio() calls was nonzero.
+ */
+void modem_release_mmio(struct modemctl *mc, unsigned bits);
+
+/* Send a request for the hw mmio sem to the modem.
+ * Used ONLY by the internals of modem_request_mmio() and
+ * some trickery in vnet_xmit().  Please do not use elsewhere.
+ */
+void modem_request_sem(struct modemctl *mc);
+
+
+/* internal glue */
+void modem_debugfs_init(struct modemctl *mc);
+void modem_force_crash(struct modemctl *mc);
+
+/* protocol definitions */
+#define MB_VALID		0x0080
+#define MB_COMMAND		0x0040
+
+/* CMD_INIT_END extended bit */
+#define CP_BOOT_ONLINE		0x0000
+#define CP_BOOT_AIRPLANE	0x1000
+#define AP_OS_ANDROID		0x0100
+#define AP_OS_WINMOBILE		0x0200
+#define AP_OS_LINUX		0x0300
+#define AP_OS_SYMBIAN		0x0400
+
+/* CMD_PHONE_START extended bit */
+#define CP_QUALCOMM		0x0100
+#define CP_INFINEON		0x0200
+#define CP_BROADCOM		0x0300
+
+#define MBC_NONE		0x0000
+#define MBC_INIT_START		0x0001
+#define MBC_INIT_END		0x0002
+#define MBC_REQ_ACTIVE		0x0003
+#define MBC_RES_ACTIVE		0x0004
+#define MBC_TIME_SYNC		0x0005
+#define MBC_POWER_OFF		0x0006
+#define MBC_RESET		0x0007
+#define MBC_PHONE_START		0x0008
+#define MBC_ERR_DISPLAY		0x0009
+#define MBC_SUSPEND		0x000A
+#define MBC_RESUME		0x000B
+#define MBC_EMER_DOWN		0x000C
+#define MBC_REQ_SEM		0x000D
+#define MBC_RES_SEM		0x000E
+#define MBC_MAX			0x000F
+
+/* data mailbox flags */
+#define MBD_SEND_FMT		0x0002
+#define MBD_SEND_RAW		0x0001
+#define MBD_SEND_RFS		0x0100
+
+#define MODEM_MSG_SBL_DONE		0x12341234
+#define MODEM_CMD_BINARY_LOAD		0x45674567
+#define MODEM_MSG_BINARY_DONE		0xabcdabcd
+
+#define MODEM_CMD_RAMDUMP_START		0xDEADDEAD
+#define MODEM_MSG_RAMDUMP_LARGE		0x0ADD0ADD // 16MB - 2KB
+#define MODEM_CMD_RAMDUMP_MORE		0xEDEDEDED
+#define MODEM_MSG_RAMDUMP_SMALL		0xFADEFADE // 5MB + 4KB
+
+#define MODEM_CMD_LOGDUMP_START		0x19732864
+//#define MODEM_MSG_LOGDUMP_DONE		0x28641973
+#define MODEM_MSG_LOGDUMP_DONE		0x00001973
+
+#define RAMDUMP_LARGE_SIZE	(16*1024*1024 - 2*1024)
+#define RAMDUMP_SMALL_SIZE	(5*1024*1024 + 4*1024)
+
+
+/* onedram shared memory map */
+#define OFF_MAGIC		0x00000000
+#define OFF_ACCESS		0x00000004
+
+#define OFF_FMT_TX_HEAD		0x00000010
+#define OFF_FMT_TX_TAIL		0x00000014
+#define OFF_FMT_RX_HEAD		0x00000018
+#define OFF_FMT_RX_TAIL		0x0000001C
+#define OFF_RAW_TX_HEAD		0x00000020
+#define OFF_RAW_TX_TAIL		0x00000024
+#define OFF_RAW_RX_HEAD		0x00000028
+#define OFF_RAW_RX_TAIL		0x0000002C
+#define OFF_RFS_TX_HEAD		0x00000030
+#define OFF_RFS_TX_TAIL		0x00000034
+#define OFF_RFS_RX_HEAD		0x00000038
+#define OFF_RFS_RX_TAIL		0x0000003C
+
+#define OFF_ERROR_MSG		0x00001000
+#define SIZ_ERROR_MSG		160
+
+#define OFF_FMT_TX_DATA		0x000FE000
+#define OFF_FMT_RX_DATA		0x000FF000
+#define SIZ_FMT_DATA		0x00001000
+#define OFF_RAW_TX_DATA		0x00100000
+#define OFF_RAW_RX_DATA		0x00200000
+#define SIZ_RAW_DATA		0x00100000
+#define OFF_RFS_TX_DATA		0x00300000
+#define OFF_RFS_RX_DATA		0x00400000
+#define SIZ_RFS_DATA		0x00100000
+
+#define OFF_LOGDUMP_DATA	0x00A00000
+#define SIZ_LOGDUMP_DATA	0x00300000
+
+#define INIT_M_FIFO(name, type, dir, base) \
+	name.head = base + OFF_##type##_##dir##_HEAD; \
+	name.tail = base + OFF_##type##_##dir##_TAIL; \
+	name.data = base + OFF_##type##_##dir##_DATA; \
+	name.size = SIZ_##type##_DATA;
+
+/* onedram registers */
+
+/* Mailboxes are named based on who writes to them.
+ * MBOX_BP is written to by the (B)aseband (P)rocessor
+ * and only readable by the (A)pplication (P)rocessor.
+ * MBOX_AP is the opposite.
+ */
+#define OFF_SEM		0xFFF800
+#define OFF_MBOX_BP	0xFFF820
+#define OFF_MBOX_AP	0xFFF840
+#define OFF_CHECK_BP	0xFFF8A0
+#define OFF_CHECK_AP	0xFFF8C0
+
+#endif
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_dbg.c tiny210/drivers/misc/samsung_modemctl/modem_dbg.c
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_dbg.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/modem_dbg.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,211 @@
+/* modem_dbg.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2010 Samsung Electronics.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/wakelock.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+#include "modem_ctl.h"
+#include "modem_ctl_p.h"
+
+static int crash_open(struct inode *inode, struct file *file)
+{
+	struct modemctl *mc = inode->i_private;
+	modem_force_crash(mc);
+	return 0;
+}
+
+static const struct file_operations crash_ops = {
+	.open = crash_open,
+};
+
+#define SHOW(name) seq_printf(sf, "%-20s %d\n", #name, stats->name)
+
+static int stats_show(struct seq_file *sf, void *unused)
+{
+	struct modemstats *stats = sf->private;
+
+	SHOW(request_no_wait);
+	SHOW(request_wait);
+
+	SHOW(release_no_action);
+	SHOW(release_bp_waiting);
+	SHOW(release_bp_signaled);
+
+	SHOW(bp_req_instant);
+	SHOW(bp_req_delayed);
+	SHOW(bp_req_confused);
+
+	SHOW(rx_unknown);
+	SHOW(rx_dropped);
+	SHOW(rx_purged);
+	SHOW(rx_received);
+
+	SHOW(tx_no_delay);
+	SHOW(tx_queued);
+	SHOW(tx_bp_signaled);
+	SHOW(tx_fifo_full);
+
+	SHOW(pipe_tx);
+	SHOW(pipe_rx);
+	SHOW(pipe_tx_delayed);
+	SHOW(pipe_rx_purged);
+
+	SHOW(resets);
+
+	return 0;
+}
+
+static int stats_open(struct inode *inode, struct file *file)
+{
+	struct modemctl *mc = inode->i_private;
+	struct modemstats *stats;
+	unsigned long int flags;
+	int ret;
+
+	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
+	if (!stats)
+		return -ENOMEM;
+
+	spin_lock_irqsave(&mc->lock, flags);
+	memcpy(stats, &mc->stats, sizeof(*stats));
+	memset(&mc->stats, 0, sizeof(*stats));
+	spin_unlock_irqrestore(&mc->lock, flags);
+
+	ret = single_open(file, stats_show, stats);
+	if (ret)
+		kfree(stats);
+
+	return ret;
+}
+
+static int stats_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct modemstats *stats = seq->private;
+	int ret;
+	ret = single_release(inode, file);
+	kfree(stats);
+	return ret;
+}
+
+static const struct file_operations stats_ops = {
+	.open = stats_open,
+	.release = stats_release,
+	.read = seq_read,
+	.llseek = seq_lseek,
+};
+
+static int log_open(struct inode *inode, struct file *file)
+{
+	struct modemctl *mc = inode->i_private;
+	unsigned long int flags;
+	int ret = 0;
+
+	file->private_data = mc;
+
+	mutex_lock(&mc->ctl_lock);
+	if (mc->logdump) {
+		mutex_unlock(&mc->ctl_lock);
+		return -EBUSY;
+	}
+	mc->logdump = 1;
+	mutex_unlock(&mc->ctl_lock);
+
+	spin_lock_irqsave(&mc->lock, flags);
+	mc->logdump_data = 0;
+	pr_err("modem: send LOGDUMP\n");
+	writel(MODEM_CMD_LOGDUMP_START, mc->mmio + OFF_MBOX_AP);
+	spin_unlock_irqrestore(&mc->lock, flags);
+
+	ret = wait_event_timeout(mc->wq, mc->logdump_data, 10 * HZ);
+	if (ret == 0) {
+		mutex_lock(&mc->ctl_lock);
+		mc->logdump = 0;
+		mutex_unlock(&mc->ctl_lock);
+		return -ETIMEDOUT;
+	} else {
+		return 0;
+	}
+}
+
+static int log_release(struct inode *inode, struct file *file)
+{
+	struct modemctl *mc = file->private_data;
+	mutex_lock(&mc->ctl_lock);
+	mc->logdump = 0;
+	mutex_unlock(&mc->ctl_lock);
+	return 0;
+}
+
+static ssize_t log_read(struct file *filp, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	struct modemctl *mc = filp->private_data;
+	loff_t pos = *ppos;
+	int ret;
+
+	if (pos < 0)
+		return -EINVAL;
+	if (pos >= SIZ_LOGDUMP_DATA)
+		return 0;
+
+	ret = modem_acquire_mmio(mc);
+	if (ret)
+		return ret;
+
+	mutex_lock(&mc->ctl_lock);
+	if (count > SIZ_LOGDUMP_DATA - pos)
+		count = SIZ_LOGDUMP_DATA - pos;
+	ret = copy_to_user(buf, mc->mmio + OFF_LOGDUMP_DATA + pos, count);
+	if (ret) {
+		ret = -EFAULT;
+	} else {
+		pos += count;
+		ret = count;
+	}
+	*ppos = pos;
+	mutex_unlock(&mc->ctl_lock);
+
+	modem_release_mmio(mc, 0);
+	return ret;
+}
+
+static const struct file_operations log_ops = {
+	.open = log_open,
+	.release = log_release,
+	.read = log_read,
+};
+
+void modem_debugfs_init(struct modemctl *mc)
+{
+	struct dentry *dent;
+
+	dent = debugfs_create_dir("modemctl", 0);
+	if (IS_ERR(dent))
+		return;
+
+	debugfs_create_file("crash", 0200, dent, mc, &crash_ops);
+	debugfs_create_file("stats", 0444, dent, mc, &stats_ops);
+	debugfs_create_file("log", 0440, dent, mc, &log_ops);
+}
diff -Nur linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_io.c tiny210/drivers/misc/samsung_modemctl/modem_io.c
--- linux-2.6.35.7/drivers/misc/samsung_modemctl/modem_io.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/samsung_modemctl/modem_io.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,680 @@
+/* modem_io.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2010 Samsung Electronics.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* TODO
+ * - on modem crash return -ENODEV from recv/send, poll==readable
+ * - ensure all modem off/reset cases fault out io properly
+ * - request thread irq?
+ * - stats/debugfs
+ * - purge txq on restart
+ * - test, test, test
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+
+#include <linux/circ_buf.h>
+#include <linux/wakelock.h>
+
+#include "modem_ctl.h"
+#include "modem_ctl_p.h"
+
+#define RAW_CH_VNET0 10
+
+
+/* general purpose fifo access routines */
+
+typedef void * (*copyfunc)(void *, const void *, __kernel_size_t);
+
+static void *x_copy_to_user(void *dst, const void *src, __kernel_size_t sz)
+{
+	if (copy_to_user((void __user *) dst, src, sz) != 0)
+		pr_err("modemctl: cannot copy userdata\n");
+	return dst;
+}
+
+static void *x_copy_from_user(void *dst, const void *src, __kernel_size_t sz)
+{
+	if (copy_from_user(dst, (const void __user *) src, sz) != 0)
+		pr_err("modemctl: cannot copy userdata\n");
+	return dst;
+}
+
+static unsigned _fifo_read(struct m_fifo *q, void *dst,
+			   unsigned count, copyfunc copy)
+{
+	unsigned n;
+	unsigned head = *q->head;
+	unsigned tail = *q->tail;
+	unsigned size = q->size;
+
+	if (CIRC_CNT(head, tail, size) < count)
+		return 0;
+
+	n = CIRC_CNT_TO_END(head, tail, size);
+
+	if (likely(n >= count)) {
+		copy(dst, q->data + tail, count);
+	} else {
+		copy(dst, q->data + tail, n);
+		copy(dst + n, q->data, count - n);
+	}
+	*q->tail = (tail + count) & (size - 1);
+
+	return count;
+}
+
+static unsigned _fifo_write(struct m_fifo *q, void *src,
+			    unsigned count, copyfunc copy)
+{
+	unsigned n;
+	unsigned head = *q->head;
+	unsigned tail = *q->tail;
+	unsigned size = q->size;
+
+	if (CIRC_SPACE(head, tail, size) < count)
+		return 0;
+
+	n = CIRC_SPACE_TO_END(head, tail, size);
+
+	if (likely(n >= count)) {
+		copy(q->data + head, src, count);
+	} else {
+		copy(q->data + head, src, n);
+		copy(q->data, src + n, count - n);
+	}
+	*q->head = (head + count) & (size - 1);
+
+	return count;
+}
+
+static void fifo_purge(struct m_fifo *q)
+{
+	*q->head = 0;
+	*q->tail = 0;
+}
+
+static unsigned fifo_skip(struct m_fifo *q, unsigned count)
+{
+	if (CIRC_CNT(*q->head, *q->tail, q->size) < count)
+		return 0;
+	*q->tail = (*q->tail + count) & (q->size - 1);
+	return count;
+}
+
+#define fifo_read(q, dst, count) \
+	_fifo_read(q, dst, count, memcpy)
+#define fifo_read_user(q, dst, count) \
+	_fifo_read(q, dst, count, x_copy_to_user)
+
+#define fifo_write(q, src, count) \
+	_fifo_write(q, src, count, memcpy)
+#define fifo_write_user(q, src, count) \
+	_fifo_write(q, src, count, x_copy_from_user)
+
+#define fifo_count(mf) CIRC_CNT(*(mf)->head, *(mf)->tail, (mf)->size)
+#define fifo_space(mf) CIRC_SPACE(*(mf)->head, *(mf)->tail, (mf)->size)
+
+static void fifo_dump(const char *tag, struct m_fifo *q,
+		      unsigned start, unsigned count)
+{
+	if (count > 64)
+		count = 64;
+
+	if ((start + count) <= q->size) {
+		print_hex_dump_bytes(tag, DUMP_PREFIX_ADDRESS,
+				     q->data + start, count);
+	} else {
+		print_hex_dump_bytes(tag, DUMP_PREFIX_ADDRESS,
+				     q->data + start, q->size - start);
+		print_hex_dump_bytes(tag, DUMP_PREFIX_ADDRESS,
+				     q->data, count - (q->size - start));
+	}
+}
+
+
+
+/* Called with mc->lock held whenever we gain access
+ * to the mmio region.
+ */
+void modem_update_state(struct modemctl *mc)
+{
+	/* update our idea of space available in fifos */
+	mc->fmt_tx.avail = fifo_space(&mc->fmt_tx);
+	mc->fmt_rx.avail = fifo_count(&mc->fmt_rx);
+	if (mc->fmt_rx.avail)
+		wake_lock(&mc->cmd_pipe.wakelock);
+	else
+		wake_unlock(&mc->cmd_pipe.wakelock);
+
+	mc->rfs_tx.avail = fifo_space(&mc->rfs_tx);
+	mc->rfs_rx.avail = fifo_count(&mc->rfs_rx);
+	if (mc->rfs_rx.avail)
+		wake_lock(&mc->rfs_pipe.wakelock);
+	else
+		wake_unlock(&mc->rfs_pipe.wakelock);
+
+	mc->raw_tx.avail = fifo_space(&mc->raw_tx);
+	mc->raw_rx.avail = fifo_count(&mc->raw_rx);
+
+	/* wake up blocked or polling read/write operations */
+	wake_up(&mc->wq);
+}
+
+void modem_update_pipe(struct m_pipe *pipe)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&pipe->mc->lock, flags);
+	pipe->tx->avail = fifo_space(pipe->tx);
+	pipe->rx->avail = fifo_count(pipe->rx);
+	if (pipe->rx->avail)
+		wake_lock(&pipe->wakelock);
+	else
+		wake_unlock(&pipe->wakelock);
+	spin_unlock_irqrestore(&pipe->mc->lock, flags);
+}
+
+
+/* must be called with pipe->tx_lock held */
+static int modem_pipe_send(struct m_pipe *pipe, struct modem_io *io)
+{
+	char hdr[M_PIPE_MAX_HDR];
+	static char ftr = 0x7e;
+	unsigned size;
+	int ret;
+
+	ret = pipe->push_header(io, hdr);
+	if (ret)
+		return ret;
+
+	size = io->size + pipe->header_size + 1;
+
+	if (io->size > 0x10000000)
+		return -EINVAL;
+	if (size >= (pipe->tx->size - 1))
+		return -EINVAL;
+
+	for (;;) {
+		ret = modem_acquire_mmio(pipe->mc);
+		if (ret)
+			return ret;
+
+		modem_update_pipe(pipe);
+
+		if (pipe->tx->avail >= size) {
+			fifo_write(pipe->tx, hdr, pipe->header_size);
+			fifo_write_user(pipe->tx, io->data, io->size);
+			fifo_write(pipe->tx, &ftr, 1);
+			modem_update_pipe(pipe);
+			modem_release_mmio(pipe->mc, pipe->tx->bits);
+			MODEM_COUNT(pipe->mc, pipe_tx);
+			return 0;
+		}
+
+		pr_info("modem_pipe_send: wait for space\n");
+		MODEM_COUNT(pipe->mc, pipe_tx_delayed);
+		modem_release_mmio(pipe->mc, 0);
+
+		ret = wait_event_interruptible_timeout(
+			pipe->mc->wq,
+			(pipe->tx->avail >= size) || modem_offline(pipe->mc),
+			5 * HZ);
+		if (ret == 0)
+			return -ENODEV;
+		if (ret < 0)
+			return ret;
+	}
+}
+
+static int modem_pipe_read(struct m_pipe *pipe, struct modem_io *io)
+{
+	unsigned data_size = io->size;
+	char hdr[M_PIPE_MAX_HDR];
+	int ret;
+
+	if (fifo_read(pipe->rx, hdr, pipe->header_size) == 0)
+		return -EAGAIN;
+
+	ret = pipe->pull_header(io, hdr);
+	if (ret)
+		return ret;
+
+	if (data_size < io->size) {
+		pr_info("modem_pipe_read: discarding packet (%d)\n", io->size);
+		if (fifo_skip(pipe->rx, io->size + 1) != (io->size + 1))
+			return -EIO;
+		return -EAGAIN;
+	} else {
+		if (fifo_read_user(pipe->rx, io->data, io->size) != io->size)
+			return -EIO;
+		if (fifo_skip(pipe->rx, 1) != 1)
+			return -EIO;
+	}
+	return 0;
+}
+
+/* must be called with pipe->rx_lock held */
+static int modem_pipe_recv(struct m_pipe *pipe, struct modem_io *io)
+{
+	int ret;
+
+	ret = modem_acquire_mmio(pipe->mc);
+	if (ret)
+		return ret;
+
+	ret = modem_pipe_read(pipe, io);
+
+	modem_update_pipe(pipe);
+
+	if ((ret != 0) && (ret != -EAGAIN)) {
+		pr_err("[MODEM] purging %s fifo\n", pipe->dev.name);
+		fifo_purge(pipe->rx);
+		MODEM_COUNT(pipe->mc, pipe_rx_purged);
+	} else if (ret == 0) {
+		MODEM_COUNT(pipe->mc, pipe_rx);
+	}
+
+	modem_release_mmio(pipe->mc, 0);
+
+	return ret;
+}
+
+struct raw_hdr {
+	u8 start;
+	u32 len;
+	u8 channel;
+	u8 control;
+} __attribute__ ((packed));
+
+struct vnet {
+	struct modemctl *mc;
+	struct sk_buff_head txq;
+};
+
+static void handle_raw_rx(struct modemctl *mc)
+{
+	struct raw_hdr raw;
+	struct sk_buff *skb = NULL;
+	int recvdata = 0;
+
+	/* process inbound packets */
+	while (fifo_read(&mc->raw_rx, &raw, sizeof(raw)) == sizeof(raw)) {
+		struct net_device *dev = mc->ndev;
+		unsigned sz = raw.len - (sizeof(raw) - 1);
+
+		if (unlikely(raw.channel != RAW_CH_VNET0)) {
+			MODEM_COUNT(mc, rx_unknown);
+			pr_err("[VNET] unknown channel %d\n", raw.channel);
+			if (fifo_skip(&mc->raw_rx, sz + 1) != (sz + 1))
+				goto purge_raw_fifo;
+			continue;
+		}
+
+		skb = dev_alloc_skb(sz + NET_IP_ALIGN);
+		if (skb == NULL) {
+			MODEM_COUNT(mc, rx_dropped);
+			/* TODO: consider timer + retry instead of drop? */
+			pr_err("[VNET] cannot alloc %d byte packet\n", sz);
+			if (fifo_skip(&mc->raw_rx, sz + 1) != (sz + 1))
+				goto purge_raw_fifo;
+			continue;
+		}
+		skb->dev = dev;
+		skb_reserve(skb, NET_IP_ALIGN);
+
+		if (fifo_read(&mc->raw_rx, skb_put(skb, sz), sz) != sz)
+			goto purge_raw_fifo;
+		if (fifo_skip(&mc->raw_rx, 1) != 1)
+			goto purge_raw_fifo;
+
+		skb->protocol = __constant_htons(ETH_P_IP);
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
+
+		netif_rx(skb);
+		recvdata = 1;
+		MODEM_COUNT(mc, rx_received);
+	}
+
+	if (recvdata)
+		wake_lock_timeout(&mc->ip_rx_wakelock, HZ * 2);
+	return;
+
+purge_raw_fifo:
+	if (skb)
+		dev_kfree_skb_irq(skb);
+	pr_err("[VNET] purging raw rx fifo!\n");
+	fifo_purge(&mc->raw_tx);
+	MODEM_COUNT(mc, rx_purged);
+}
+
+int handle_raw_tx(struct modemctl *mc, struct sk_buff *skb)
+{
+	struct raw_hdr raw;
+	unsigned char ftr = 0x7e;
+	unsigned sz;
+
+	sz = skb->len + sizeof(raw) + 1;
+
+	if (fifo_space(&mc->raw_tx) < sz) {
+		MODEM_COUNT(mc, tx_fifo_full);
+		return -1;
+	}
+
+	raw.start = 0x7f;
+	raw.len = 6 + skb->len;
+	raw.channel = RAW_CH_VNET0;
+	raw.control = 0;
+
+	fifo_write(&mc->raw_tx, &raw, sizeof(raw));
+	fifo_write(&mc->raw_tx, skb->data, skb->len);
+	fifo_write(&mc->raw_tx, &ftr, 1);
+
+	mc->ndev->stats.tx_packets++;
+	mc->ndev->stats.tx_bytes += skb->len;
+
+	mc->mmio_signal_bits |= MBD_SEND_RAW;
+
+	dev_kfree_skb_irq(skb);
+	return 0;
+}
+
+void modem_handle_io(struct modemctl *mc)
+{
+	struct sk_buff *skb;
+	struct vnet *vn = netdev_priv(mc->ndev);
+
+	handle_raw_rx(mc);
+
+	while ((skb = skb_dequeue(&vn->txq)))
+		if (handle_raw_tx(mc, skb)) {
+			skb_queue_head(&vn->txq, skb);
+			break;
+		}
+	if (skb == NULL)
+		wake_unlock(&vn->mc->ip_tx_wakelock);
+}
+
+static int vnet_open(struct net_device *ndev)
+{
+	netif_start_queue(ndev);
+	return 0;
+}
+
+static int vnet_stop(struct net_device *ndev)
+{
+	netif_stop_queue(ndev);
+	return 0;
+}
+
+static int vnet_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct vnet *vn = netdev_priv(ndev);
+	struct modemctl *mc = vn->mc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mc->lock, flags);
+	if (readl(mc->mmio + OFF_SEM) & 1) {
+		/* if we happen to hold the hw mmio sem, transmit NOW */
+		if (handle_raw_tx(mc, skb)) {
+			wake_lock(&mc->ip_tx_wakelock);
+			skb_queue_tail(&vn->txq, skb);
+		} else {
+			MODEM_COUNT(mc, tx_no_delay);
+		}
+		if (!mc->mmio_owner) {
+			/* if we don't own the semaphore, immediately
+			 * give it back to the modem and signal the modem
+			 * to process the packet
+			 */
+			writel(0, mc->mmio + OFF_SEM);
+			writel(MB_VALID | MBD_SEND_RAW,
+			       mc->mmio + OFF_MBOX_AP);
+			MODEM_COUNT(mc, tx_bp_signaled);
+		}
+	} else {
+		/* otherwise request the hw mmio sem and queue */
+		modem_request_sem(mc);
+		skb_queue_tail(&vn->txq, skb);
+		MODEM_COUNT(mc, tx_queued);
+	}
+	spin_unlock_irqrestore(&mc->lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static struct net_device_ops vnet_ops = {
+	.ndo_open =		vnet_open,
+	.ndo_stop =		vnet_stop,
+	.ndo_start_xmit =	vnet_xmit,
+};
+
+static void vnet_setup(struct net_device *ndev)
+{
+	ndev->netdev_ops = &vnet_ops;
+	ndev->type = ARPHRD_PPP;
+	ndev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+	ndev->hard_header_len = 0;
+	ndev->addr_len = 0;
+	ndev->tx_queue_len = 1000;
+	ndev->mtu = ETH_DATA_LEN;
+	ndev->watchdog_timeo = 5 * HZ;
+}
+
+struct fmt_hdr {
+	u8 start;
+	u16 len;
+	u8 control;
+} __attribute__ ((packed));
+
+static int push_fmt_header(struct modem_io *io, void *header)
+{
+	struct fmt_hdr *fh = header;
+
+	if (io->id)
+		return -EINVAL;
+	if (io->cmd)
+		return -EINVAL;
+	fh->start = 0x7f;
+	fh->len = io->size + 3;
+	fh->control = 0;
+	return 0;
+}
+
+static int pull_fmt_header(struct modem_io *io, void *header)
+{
+	struct fmt_hdr *fh = header;
+
+	if (fh->start != 0x7f)
+		return -EINVAL;
+	if (fh->control != 0x00)
+		return -EINVAL;
+	if (fh->len < 3)
+		return -EINVAL;
+	io->size = fh->len - 3;
+	io->id = 0;
+	io->cmd = 0;
+	return 0;
+}
+
+struct rfs_hdr {
+	u8 start;
+	u32 len;
+	u8 cmd;
+	u8 id;
+} __attribute__ ((packed));
+
+static int push_rfs_header(struct modem_io *io, void *header)
+{
+	struct rfs_hdr *rh = header;
+
+	if (io->id > 0xFF)
+		return -EINVAL;
+	if (io->cmd > 0xFF)
+		return -EINVAL;
+	rh->start = 0x7f;
+	rh->len = io->size + 6;
+	rh->id = io->id;
+	rh->cmd = io->cmd;
+	return 0;
+}
+
+static int pull_rfs_header(struct modem_io *io, void *header)
+{
+	struct rfs_hdr *rh = header;
+
+	if (rh->start != 0x7f)
+		return -EINVAL;
+	if (rh->len < 6)
+		return -EINVAL;
+	io->size = rh->len - 6;
+	io->id = rh->id;
+	io->cmd = rh->cmd;
+	return 0;
+}
+
+static int pipe_open(struct inode *inode, struct file *filp)
+{
+	struct m_pipe *pipe = to_m_pipe(filp->private_data);
+	filp->private_data = pipe;
+	return 0;
+}
+
+static long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long _arg)
+{
+	void __user *arg = (void *) _arg;
+	struct m_pipe *pipe = filp->private_data;
+	struct modem_io mio;
+	int ret;
+
+	switch (cmd) {
+	case IOCTL_MODEM_SEND:
+		if (copy_from_user(&mio, arg, sizeof(mio)) != 0)
+			return -EFAULT;
+		if (mutex_lock_interruptible(&pipe->tx_lock))
+			return -EINTR;
+		ret = modem_pipe_send(pipe, &mio);
+		mutex_unlock(&pipe->tx_lock);
+		return ret;
+
+	case IOCTL_MODEM_RECV:
+		if (copy_from_user(&mio, arg, sizeof(mio)) != 0)
+			return -EFAULT;
+		if (mutex_lock_interruptible(&pipe->rx_lock))
+			return -EINTR;
+		ret = modem_pipe_recv(pipe, &mio);
+		mutex_unlock(&pipe->rx_lock);
+		if (copy_to_user(arg, &mio, sizeof(mio)) != 0)
+			return -EFAULT;
+		return ret;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static unsigned int pipe_poll(struct file *filp, poll_table *wait)
+{
+	unsigned long flags;
+	struct m_pipe *pipe = filp->private_data;
+	int ret;
+
+	poll_wait(filp, &pipe->mc->wq, wait);
+
+	spin_lock_irqsave(&pipe->mc->lock, flags);
+	if (pipe->rx->avail || modem_offline(pipe->mc))
+		ret = POLLIN | POLLRDNORM;
+	else
+		ret = 0;
+	spin_unlock_irqrestore(&pipe->mc->lock, flags);
+
+	return ret;
+}
+
+static const struct file_operations modem_io_fops = {
+	.owner =		THIS_MODULE,
+	.open =			pipe_open,
+	.poll =			pipe_poll,
+	.unlocked_ioctl =	pipe_ioctl,
+};
+
+static int modem_pipe_register(struct m_pipe *pipe, const char *devname)
+{
+	pipe->dev.minor = MISC_DYNAMIC_MINOR;
+	pipe->dev.name = devname;
+	pipe->dev.fops = &modem_io_fops;
+
+	wake_lock_init(&pipe->wakelock, WAKE_LOCK_SUSPEND, devname);
+
+	mutex_init(&pipe->tx_lock);
+	mutex_init(&pipe->rx_lock);
+	return misc_register(&pipe->dev);
+}
+
+int modem_io_init(struct modemctl *mc, void __iomem *mmio)
+{
+	struct net_device *ndev;
+	struct vnet *vn;
+	int r;
+
+	INIT_M_FIFO(mc->fmt_tx, FMT, TX, mmio);
+	INIT_M_FIFO(mc->fmt_rx, FMT, RX, mmio);
+	INIT_M_FIFO(mc->raw_tx, RAW, TX, mmio);
+	INIT_M_FIFO(mc->raw_rx, RAW, RX, mmio);
+	INIT_M_FIFO(mc->rfs_tx, RFS, TX, mmio);
+	INIT_M_FIFO(mc->rfs_rx, RFS, RX, mmio);
+
+	ndev = alloc_netdev(0, "rmnet%d", vnet_setup);
+	if (ndev) {
+		vn = netdev_priv(ndev);
+		vn->mc = mc;
+		skb_queue_head_init(&vn->txq);
+		r = register_netdev(ndev);
+		if (r)
+			free_netdev(ndev);
+		else
+			mc->ndev = ndev;
+	}
+
+	mc->cmd_pipe.tx = &mc->fmt_tx;
+	mc->cmd_pipe.rx = &mc->fmt_rx;
+	mc->cmd_pipe.tx->bits = MBD_SEND_FMT;
+	mc->cmd_pipe.push_header = push_fmt_header;
+	mc->cmd_pipe.pull_header = pull_fmt_header;
+	mc->cmd_pipe.header_size = sizeof(struct fmt_hdr);
+	mc->cmd_pipe.mc = mc;
+	if (modem_pipe_register(&mc->cmd_pipe, "modem_fmt"))
+		pr_err("failed to register modem_fmt pipe\n");
+
+	mc->rfs_pipe.tx = &mc->rfs_tx;
+	mc->rfs_pipe.rx = &mc->rfs_rx;
+	mc->rfs_pipe.tx->bits = MBD_SEND_RFS;
+	mc->rfs_pipe.push_header = push_rfs_header;
+	mc->rfs_pipe.pull_header = pull_rfs_header;
+	mc->rfs_pipe.header_size = sizeof(struct rfs_hdr);
+	mc->rfs_pipe.mc = mc;
+	if (modem_pipe_register(&mc->rfs_pipe, "modem_rfs"))
+		pr_err("failed to register modem_rfs pipe\n");
+
+	return 0;
+}
diff -Nur linux-2.6.35.7/drivers/misc/sec_jack.c tiny210/drivers/misc/sec_jack.c
--- linux-2.6.35.7/drivers/misc/sec_jack.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/sec_jack.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,336 @@
+/*  drivers/misc/sec_jack.c
+ *
+ *  Copyright (C) 2010 Samsung Electronics Co.Ltd
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/switch.h>
+#include <linux/input.h>
+#include <linux/timer.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/sec_jack.h>
+
+#define MAX_ZONE_LIMIT		10
+#define SEND_KEY_CHECK_TIME_MS	30		/* 30ms */
+#define DET_CHECK_TIME_MS	200		/* 200ms */
+#define WAKE_LOCK_TIME		(HZ * 5)	/* 5 sec */
+
+struct sec_jack_info {
+	struct sec_jack_platform_data *pdata;
+	struct delayed_work jack_detect_work;
+	struct wake_lock det_wake_lock;
+	struct sec_jack_zone *zone;
+	int det_irq;
+	int dev_id;
+	struct platform_device *send_key_dev;
+	unsigned int cur_jack_type;
+};
+
+/* with some modifications like moving all the gpio structs inside
+ * the platform data and getting the name for the switch and
+ * gpio_event from the platform data, the driver could support more than
+ * one headset jack, but currently user space is looking only for
+ * one key file and switch for a headset so it'd be overkill and
+ * untestable so we limit to one instantiation for now.
+ */
+static atomic_t instantiated = ATOMIC_INIT(0);
+
+/* sysfs name HeadsetObserver.java looks for to track headset state
+ */
+struct switch_dev switch_jack_detection = {
+	.name = "h2w",
+};
+
+static struct gpio_event_direct_entry sec_jack_key_map[] = {
+	{
+		.code	= KEY_MEDIA,
+	},
+};
+
+static struct gpio_event_input_info sec_jack_key_info = {
+	.info.func = gpio_event_input_func,
+	.info.no_suspend = true,
+	.type = EV_KEY,
+	.debounce_time.tv.nsec = SEND_KEY_CHECK_TIME_MS * NSEC_PER_MSEC,
+	.keymap = sec_jack_key_map,
+	.keymap_size = ARRAY_SIZE(sec_jack_key_map)
+};
+
+static struct gpio_event_info *sec_jack_input_info[] = {
+	&sec_jack_key_info.info,
+};
+
+static struct gpio_event_platform_data sec_jack_input_data = {
+	.name = "sec_jack",
+	.info = sec_jack_input_info,
+	.info_count = ARRAY_SIZE(sec_jack_input_info),
+};
+
+static void sec_jack_set_type(struct sec_jack_info *hi, int jack_type)
+{
+	struct sec_jack_platform_data *pdata = hi->pdata;
+
+	/* this can happen during slow inserts where we think we identified
+	 * the type but then we get another interrupt and do it again
+	 */
+	if (jack_type == hi->cur_jack_type)
+		return;
+
+	if (jack_type == SEC_HEADSET_4POLE) {
+		/* for a 4 pole headset, enable detection of send/end key */
+		if (hi->send_key_dev == NULL)
+			/* enable to get events again */
+			hi->send_key_dev = platform_device_register_data(NULL,
+					GPIO_EVENT_DEV_NAME,
+					hi->dev_id,
+					&sec_jack_input_data,
+					sizeof(sec_jack_input_data));
+	} else {
+		/* for all other jacks, disable send/end key detection */
+		if (hi->send_key_dev != NULL) {
+			/* disable to prevent false events on next insert */
+			platform_device_unregister(hi->send_key_dev);
+			hi->send_key_dev = NULL;
+		}
+		/* micbias is left enabled for 4pole and disabled otherwise */
+		pdata->set_micbias_state(false);
+	}
+
+	hi->cur_jack_type = jack_type;
+	pr_info("%s : jack_type = %d\n", __func__, jack_type);
+
+	/* prevent suspend to allow user space to respond to switch */
+	wake_lock_timeout(&hi->det_wake_lock, WAKE_LOCK_TIME);
+
+	switch_set_state(&switch_jack_detection, jack_type);
+}
+
+static void handle_jack_not_inserted(struct sec_jack_info *hi)
+{
+	sec_jack_set_type(hi, SEC_JACK_NO_DEVICE);
+	hi->pdata->set_micbias_state(false);
+}
+
+static void determine_jack_type(struct sec_jack_info *hi)
+{
+	struct sec_jack_zone *zones = hi->pdata->zones;
+	int size = hi->pdata->num_zones;
+	int count[MAX_ZONE_LIMIT] = {0};
+	int adc;
+	int i;
+	unsigned npolarity = !hi->pdata->det_active_high;
+
+	while (gpio_get_value(hi->pdata->det_gpio) ^ npolarity) {
+		adc = hi->pdata->get_adc_value();
+		pr_debug("%s: adc = %d\n", __func__, adc);
+
+		/* determine the type of headset based on the
+		 * adc value.  An adc value can fall in various
+		 * ranges or zones.  Within some ranges, the type
+		 * can be returned immediately.  Within others, the
+		 * value is considered unstable and we need to sample
+		 * a few more types (up to the limit determined by
+		 * the range) before we return the type for that range.
+		 */
+		for (i = 0; i < size; i++) {
+			if (adc <= zones[i].adc_high) {
+				if (++count[i] > zones[i].check_count) {
+					sec_jack_set_type(hi,
+							  zones[i].jack_type);
+					return;
+				}
+				msleep(zones[i].delay_ms);
+				break;
+			}
+		}
+	}
+	/* jack removed before detection complete */
+	pr_debug("%s : jack removed before detection complete\n", __func__);
+	handle_jack_not_inserted(hi);
+}
+
+/* thread run whenever the headset detect state changes (either insertion
+ * or removal).
+ */
+static irqreturn_t sec_jack_detect_irq_thread(int irq, void *dev_id)
+{
+	struct sec_jack_info *hi = dev_id;
+	struct sec_jack_platform_data *pdata = hi->pdata;
+	int time_left_ms = DET_CHECK_TIME_MS;
+	unsigned npolarity = !hi->pdata->det_active_high;
+
+	/* set mic bias to enable adc */
+	pdata->set_micbias_state(true);
+
+	/* debounce headset jack.  don't try to determine the type of
+	 * headset until the detect state is true for a while.
+	 */
+	while (time_left_ms > 0) {
+		if (!(gpio_get_value(hi->pdata->det_gpio) ^ npolarity)) {
+			/* jack not detected. */
+			handle_jack_not_inserted(hi);
+			return IRQ_HANDLED;
+		}
+		msleep(10);
+		time_left_ms -= 10;
+	}
+	/* jack presence was detected the whole time, figure out which type */
+	determine_jack_type(hi);
+	return IRQ_HANDLED;
+}
+
+static int sec_jack_probe(struct platform_device *pdev)
+{
+	struct sec_jack_info *hi;
+	struct sec_jack_platform_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+	pr_info("%s : Registering jack driver\n", __func__);
+	if (!pdata) {
+		pr_err("%s : pdata is NULL.\n", __func__);
+		return -ENODEV;
+	}
+
+	if (!pdata->get_adc_value || !pdata->zones ||
+	    !pdata->set_micbias_state || pdata->num_zones > MAX_ZONE_LIMIT) {
+		pr_err("%s : need to check pdata\n", __func__);
+		return -ENODEV;
+	}
+
+	if (atomic_xchg(&instantiated, 1)) {
+		pr_err("%s : already instantiated, can only have one\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	sec_jack_key_map[0].gpio = pdata->send_end_gpio;
+
+	hi = kzalloc(sizeof(struct sec_jack_info), GFP_KERNEL);
+	if (hi == NULL) {
+		pr_err("%s : Failed to allocate memory.\n", __func__);
+		ret = -ENOMEM;
+		goto err_kzalloc;
+	}
+
+	hi->pdata = pdata;
+
+	/* make the id of our gpi_event device the same as our platform device,
+	 * which makes it the responsiblity of the board file to make sure
+	 * it is unique relative to other gpio_event devices
+	 */
+	hi->dev_id = pdev->id;
+
+	ret = gpio_request(pdata->det_gpio, "ear_jack_detect");
+	if (ret) {
+		pr_err("%s : gpio_request failed for %d\n",
+		       __func__, pdata->det_gpio);
+		goto err_gpio_request;
+	}
+
+	ret = switch_dev_register(&switch_jack_detection);
+	if (ret < 0) {
+		pr_err("%s : Failed to register switch device\n", __func__);
+		goto err_switch_dev_register;
+	}
+
+	wake_lock_init(&hi->det_wake_lock, WAKE_LOCK_SUSPEND, "sec_jack_det");
+
+	hi->det_irq = gpio_to_irq(pdata->det_gpio);
+	ret = request_threaded_irq(hi->det_irq, NULL,
+				   sec_jack_detect_irq_thread,
+				   IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+				   IRQF_ONESHOT, "sec_headset_detect", hi);
+	if (ret) {
+		pr_err("%s : Failed to request_irq.\n", __func__);
+		goto err_request_detect_irq;
+	}
+
+	/* to handle insert/removal when we're sleeping in a call */
+	ret = enable_irq_wake(hi->det_irq);
+	if (ret) {
+		pr_err("%s : Failed to enable_irq_wake.\n", __func__);
+		goto err_enable_irq_wake;
+	}
+
+	dev_set_drvdata(&pdev->dev, hi);
+
+	return 0;
+
+err_enable_irq_wake:
+	free_irq(hi->det_irq, hi);
+err_request_detect_irq:
+	wake_lock_destroy(&hi->det_wake_lock);
+	switch_dev_unregister(&switch_jack_detection);
+err_switch_dev_register:
+	gpio_free(pdata->det_gpio);
+err_gpio_request:
+	kfree(hi);
+err_kzalloc:
+	atomic_set(&instantiated, 0);
+
+	return ret;
+}
+
+static int sec_jack_remove(struct platform_device *pdev)
+{
+
+	struct sec_jack_info *hi = dev_get_drvdata(&pdev->dev);
+
+	pr_info("%s :\n", __func__);
+	disable_irq_wake(hi->det_irq);
+	free_irq(hi->det_irq, hi);
+	platform_device_unregister(hi->send_key_dev);
+	wake_lock_destroy(&hi->det_wake_lock);
+	switch_dev_unregister(&switch_jack_detection);
+	gpio_free(hi->pdata->det_gpio);
+	kfree(hi);
+	atomic_set(&instantiated, 0);
+
+	return 0;
+}
+
+static struct platform_driver sec_jack_driver = {
+	.probe = sec_jack_probe,
+	.remove = sec_jack_remove,
+	.driver = {
+			.name = "sec_jack",
+			.owner = THIS_MODULE,
+		   },
+};
+static int __init sec_jack_init(void)
+{
+	return platform_driver_register(&sec_jack_driver);
+}
+
+static void __exit sec_jack_exit(void)
+{
+	platform_driver_unregister(&sec_jack_driver);
+}
+
+module_init(sec_jack_init);
+module_exit(sec_jack_exit);
+
+MODULE_AUTHOR("ms17.kim@samsung.com");
+MODULE_DESCRIPTION("Samsung Electronics Corp Ear-Jack detection driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.35.7/drivers/misc/uid_stat.c tiny210/drivers/misc/uid_stat.c
--- linux-2.6.35.7/drivers/misc/uid_stat.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/uid_stat.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,156 @@
+/* drivers/misc/uid_stat.c
+ *
+ * Copyright (C) 2008 - 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+#include <linux/uid_stat.h>
+#include <net/activity_stats.h>
+
+static DEFINE_SPINLOCK(uid_lock);
+static LIST_HEAD(uid_list);
+static struct proc_dir_entry *parent;
+
+struct uid_stat {
+	struct list_head link;
+	uid_t uid;
+	atomic_t tcp_rcv;
+	atomic_t tcp_snd;
+};
+
+static struct uid_stat *find_uid_stat(uid_t uid) {
+	unsigned long flags;
+	struct uid_stat *entry;
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_for_each_entry(entry, &uid_list, link) {
+		if (entry->uid == uid) {
+			spin_unlock_irqrestore(&uid_lock, flags);
+			return entry;
+		}
+	}
+	spin_unlock_irqrestore(&uid_lock, flags);
+	return NULL;
+}
+
+static int tcp_snd_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_snd) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+static int tcp_rcv_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_rcv) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+/* Create a new entry for tracking the specified uid. */
+static struct uid_stat *create_stat(uid_t uid) {
+	unsigned long flags;
+	char uid_s[32];
+	struct uid_stat *new_uid;
+	struct proc_dir_entry *entry;
+
+	/* Create the uid stat struct and append it to the list. */
+	if ((new_uid = kmalloc(sizeof(struct uid_stat), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	new_uid->uid = uid;
+	/* Counters start at INT_MIN, so we can track 4GB of network traffic. */
+	atomic_set(&new_uid->tcp_rcv, INT_MIN);
+	atomic_set(&new_uid->tcp_snd, INT_MIN);
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_add_tail(&new_uid->link, &uid_list);
+	spin_unlock_irqrestore(&uid_lock, flags);
+
+	sprintf(uid_s, "%d", uid);
+	entry = proc_mkdir(uid_s, parent);
+
+	/* Keep reference to uid_stat so we know what uid to read stats from. */
+	create_proc_read_entry("tcp_snd", S_IRUGO, entry , tcp_snd_read_proc,
+		(void *) new_uid);
+
+	create_proc_read_entry("tcp_rcv", S_IRUGO, entry, tcp_rcv_read_proc,
+		(void *) new_uid);
+
+	return new_uid;
+}
+
+int uid_stat_tcp_snd(uid_t uid, int size) {
+	struct uid_stat *entry;
+	activity_stats_update();
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_snd);
+	return 0;
+}
+
+int uid_stat_tcp_rcv(uid_t uid, int size) {
+	struct uid_stat *entry;
+	activity_stats_update();
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_rcv);
+	return 0;
+}
+
+static int __init uid_stat_init(void)
+{
+	parent = proc_mkdir("uid_stat", NULL);
+	if (!parent) {
+		pr_err("uid_stat: failed to create proc entry\n");
+		return -1;
+	}
+	return 0;
+}
+
+__initcall(uid_stat_init);
diff -Nur linux-2.6.35.7/drivers/misc/wl127x-rfkill.c tiny210/drivers/misc/wl127x-rfkill.c
--- linux-2.6.35.7/drivers/misc/wl127x-rfkill.c	1970-01-01 08:00:00.000000000 +0800
+++ tiny210/drivers/misc/wl127x-rfkill.c	2011-08-08 12:52:33.000000000 +0800
@@ -0,0 +1,121 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/rfkill.h>
+#include <linux/platform_device.h>
+#include <linux/wl127x-rfkill.h>
+
+static int wl127x_rfkill_set_power(void *data, enum rfkill_state state)
+{
+	int nshutdown_gpio = (int) data;
+
+	switch (state) {
+	case RFKILL_STATE_UNBLOCKED:
+		gpio_set_value(nshutdown_gpio, 1);
+		break;
+	case RFKILL_STATE_SOFT_BLOCKED:
+		gpio_set_value(nshutdown_gpio, 0);
+		break;
+	default:
+		printk(KERN_ERR "invalid bluetooth rfkill state %d\n", state);
+	}
+	return 0;
+}
+
+static int wl127x_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
+
+	rc = gpio_request(pdata->nshutdown_gpio, "wl127x_nshutdown_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_direction_output(pdata->nshutdown_gpio, 0);
+	if (unlikely(rc))
+		return rc;
+
+	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
+	wl127x_rfkill_set_power(NULL, default_state);
+
+	pdata->rfkill = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+	if (unlikely(!pdata->rfkill))
+		return -ENOMEM;
+
+	pdata->rfkill->name = "wl127x";
+	pdata->rfkill->state = default_state;
+	/* userspace cannot take exclusive control */
+	pdata->rfkill->user_claim_unsupported = 1;
+	pdata->rfkill->user_claim = 0;
+	pdata->rfkill->data = (void *) pdata->nshutdown_gpio;
+	pdata->rfkill->toggle_radio = wl127x_rfkill_set_power;
+
+	rc = rfkill_register(pdata->rfkill);
+
+	if (unlikely(rc))
+		rfkill_free(pdata->rfkill);
+
+	return 0;
+}
+
+static int wl127x_rfkill_remove(struct platform_device *pdev)
+{
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+
+	rfkill_unregister(pdata->rfkill);
+	rfkill_free(pdata->rfkill);
+	gpio_free(pdata->nshutdown_gpio);
+
+	return 0;
+}
+
+static struct platform_driver wl127x_rfkill_platform_driver = {
+	.probe = wl127x_rfkill_probe,
+	.remove = wl127x_rfkill_remove,
+	.driver = {
+		   .name = "wl127x-rfkill",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init wl127x_rfkill_init(void)
+{
+	return platform_driver_register(&wl127x_rfkill_platform_driver);
+}
+
+static void __exit wl127x_rfkill_exit(void)
+{
+	platform_driver_unregister(&wl127x_rfkill_platform_driver);
+}
+
+module_init(wl127x_rfkill_init);
+module_exit(wl127x_rfkill_exit);
+
+MODULE_ALIAS("platform:wl127x");
+MODULE_DESCRIPTION("wl127x-rfkill");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
